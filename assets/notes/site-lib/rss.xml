<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[CS]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>site-lib/media/favicon.png</url><title>CS</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Thu, 18 Dec 2025 10:57:22 GMT</lastBuildDate><atom:link href="site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Thu, 18 Dec 2025 10:56:16 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Bayes' Nets]]></title><description><![CDATA[在我们进入新主题之前，先总结一下何时应该（或不应该）使用强化学习。
序列决策问题: 当你需要做出一系列决策时。
长远影响: 当当前的动作会影响到未来的状态和回报时。
模型未知或过大: 当你不知道环境的转移动态 ()，或者状态空间太大以至于无法使用动态规划 (如价值迭代) 时。
有明确的奖励信号: 当你可以定义一个明确的目标、分数或奖励函数 ()，即使你不知道如何通过动作序列来最大化它。
探索可行: 当你有一个模拟器 (simulator) 或者可以在真实世界中安全地收集经验（生成“回合 (episodes)”）时。
寻求创新的超人解: 当你需要一个创造性的、甚至超越人类水平的解决方案时 (例如 AlphaGo)。 单步或静态问题: 例如图像分类。你对一张图片分类并不会影响下一张图片是什么。
没有明确的奖励信号: 如果你无法定义什么是“好”的，RL 就无法优化。 例外: 存在“奖励学习 (Reward Learning)”技术，但如果始终无法获得奖励函数，RL 就没用。 模型已知且可解: 如果你有一个明确且易于处理的环境模型（例如确定性的），那么使用规划 (Planning) (如 A*) 可能更有效。
对探索的容忍度低: 如果“试错”的成本过高（例如在医疗保健中）。 例外: 离线强化学习 (Offline RL)。这种方法从一个固定的、已有的经验数据集中学习，而不需要在环境中进行新的探索。 不需要自适应或新颖的解: 如果目标只是以一种高度可预测的方式执行任务，那么硬编码的解决方案可能更好。
从今天开始，我们进入一个新的主题：概率推理 (Probabilistic Inference)。
模型是世界运作方式的一种简化的、抽象的描述。
模型总是不完美的。
一句名言 (George E. P. Box): “所有的模型都是错的，但有些是有用的。”
我们需要让我们的智能体 (agents) 能够：
推理不确定性: 在信息不完整时做出判断。
解释 (Explanation): 进行诊断推理 (Diagnostic reasoning)。 例子: 医生根据病人的咳嗽和发烧，推断他们患有某种疾病的概率。 预测 (Prediction): 进行因果推理 (Causal reasoning)。 例子: 预测我的行为将对环境产生什么影响。 信息价值 (Value of Information): 判断获取哪些新信息（例如做哪项检查）对于减少不确定性和最大化效用最有价值。
我们需要牢记以下几个核心概念：
条件概率 (Conditional Probability): 乘积法则 (Product Rule): 链式法则 (Chain Rule): 贝叶斯法则 (Bayes' Rule): (绝对) 独立: 当且仅当 条件独立 (Conditional Independence): 定义 1: 定义 2 (等价): 直观含义: 一旦我们知道了 的信息，再知道 并不会为我们提供关于 的任何新信息。 例子: 下雨 (R), 交通 (T), 雨伞 (U)
因果关系 (Causal links): Rain -&gt; Traffic (下雨导致交通堵塞)
Rain -&gt; Umbrella (下雨导致人们带雨伞) 合理的假设: Umbrella 和 Traffic 在给定 Rain 的条件下是相互独立的。 即: 含义: 如果我已经知道外面在下雨，那么观察到交通堵塞并不会改变我对是否会看到有人带雨伞的看法。 应用链式法则: 标准链式法则 (Trivial): 应用条件独立性假设 ():
我们可以简化最后一项 为什么这很有用? 更紧凑的表示: 我们不再需要一个包含 (R, T, U) 所有组合的巨大表格，只需要几个小的条件概率表 (CPTs)。
更易于计算和学习: 我们需要指定或从数据中学习的参数更少了。 贝叶斯网络 (Bayes' Nets) / 图模型 (Graphical Models) 正是帮助我们表达和利用这些条件独立性假设的工具。
表示问题: 变量一多，表格就大到无法表示。 例子: 一个包含 27 个二元 (True/False) 变量的保险模型，其全联合分布表需要 (约 1.34 亿) 行！ 学习问题: 很难从数据中经验性地估计这么多参数。 定义: 贝叶斯网络是一种使用简单的、局部的分布 (即条件概率) 来描述复杂的联合分布的技术。
结构: 它是一个有向无环图 (DAG - Directed Acyclic Graph)。 节点 (Nodes): 代表随机变量 (例如: Rain, Traffic)。
弧/边 (Arcs/Edges): 代表变量间的“直接影响”。箭头编码了条件独立性假设。 直观理解 (非严格): 暂时可以把箭头 理解为 "A 是 B 的原因 (Cause)"。
例子: 汽车诊断 (Car Diagnosis)、保险网络 (Insurance Network)。 BNs 被用于多种领域，包括基因调控网络、文档分类、系统生物学和垃圾邮件过滤。 示例 1: 垃圾邮件过滤 (Naive Bayes) 一个简单的 BN 应用是 朴素贝叶斯 (Naive Bayes) 分类器。
结构: 一个代表“标签” (Spam/Ham) 的父节点 Y，指向多个代表“特征” (例如单词 'FREE!', 'viagra' 是否出现) 的子节点 。
假设: 这是一个“朴素”的模型，因为它假设所有特征 在给定标签 Y 的情况下是条件独立的。
公式: 这个假设虽然很强 (在现实中通常不成立)，但使得模型参数大大减少，非常高效，且在实践中效果不错。 示例 2: Clippy (Office 助手) 微软 Office 早期版本中的助手 Clippy 使用了贝叶斯网络。
它会观察用户的行为 (如鼠标点击、编辑图表)，并将这些行为作为“证据”。
然后，它会进行概率推理，推断用户的高级目标 (例如“正在尝试插入图表”)，并主动提供帮助。 示例 3: 医学诊断 医生可以使用 BNs 来推理疾病。
节点可以是“疾病” (如肺病、感冒) 和“症状” (如咳嗽、发烧)。
箭头通常从疾病指向症状 (因果关系)。
医生观察到“证据” (病人咳嗽、发烧)，然后查询网络，计算特定疾病 (如“肺病”) 的后验概率。 这是一个经典的贝叶斯网络示例。
<img alt="Pasted image 20251101133725.png" src="cs4300/attachments/pasted-image-20251101133725.png" target="_self" style="width: 300px; max-width: 100%;">
情景: 你家装了一个防盗警报 (Alarm, A)。
地震 (Earthquake, E) 或 入室盗窃 (Burglary, B) 都可能触发警报。
警报响起后，你的两个邻居 John (J) 和 Mary (M) 可能会打电话给你。 变量: B, E, A, J, M (均为布尔值)
一个贝叶斯网络由两部分定义：
拓扑结构 (Topology): 一个有向无环图 (DAG)。
局部条件概率 (Local Conditional Probabilities): 每个节点 都有一个条件概率表 (CPT)。
这个 CPT 定义了 ，即该节点在给定其所有直接父节点取值下的概率分布。 贝叶斯网络的核心语义是：一个系统的全联合概率分布等于所有节点的局部条件概率的乘积。公式:
示例 (牙医):
结构: Cavity (蛀牙) -&gt; Toothache (牙痛), Cavity -&gt; Catch (探针钩住)
联合分布: 这个公式是链式法则和条件独立性假设共同作用的结果。 链式法则 (恒成立): (一个变量的概率取决于所有在它之前排序的变量) 贝叶斯网络的关键假设:
一个节点 ，在给定其父节点 的条件下，与其所有非后代节点 (non-descendants) (即链式法则中排在它前面的 中非父节点的其他变量) 条件独立。 推论:
因此，链式法则中的 被简化为 。
这就得到了贝叶斯网络的联合分布公式。 结构: , , ..., (没有箭头，因为它们相互独立)。
CPTs: 每个 都是 。
计算: 结构: R -&gt; T
CPTs: 和 查询: 计算: (从 CPTs 中查找对应的值，例如 )
<br><img alt="Pasted image 20251101133541.png" src="cs4300/attachments/pasted-image-20251101133541.png" target="_self"> 结构: B -&gt; A, E -&gt; A, A -&gt; J, A -&gt; M 查询: (发生盗窃、地震、警报响、J 打电话、M 打电话) 计算 (应用 BN 公式): 查找 CPTs: (这是一个非常小的数字) 效率对比: 全联合表: 需要 个条目。
BN CPTs: [2], [2], [8], [4], [4]。总共 20 个条目。
随着网络变大，这种参数节省是指数级的。 一个包含 N 个布尔变量的全联合分布表需要 行来存储。
一个 N 个节点的 Bayes Net，如果每个节点最多有 k 个父节点，则其 CPTs 总共只需要 个参数。
如果 k 远小于 N (即网络是稀疏的 (sparse))，BNs 会带来指数级的空间节省。
这不仅节省了空间，也使得从数据中学习参数变得更容易，并且加快了查询推理的速度。
一个重要的问题：BN 箭头是否必须代表因果关系？答案：否。
示例: 反向交通模型 (T -&gt; R) 我们可以构建一个模型，其中 Traffic 是父节点，Rain 是子节点。
我们需要 和 这两个 CPTs。
惊人的事实: 我们可以设计 和 的 CPTs，使得这个 (T -&gt; R) 模型能表示与 (R -&gt; T) 模型完全相同的联合概率分布 。 箭头的数学含义: 拓扑结构真正编码的是条件独立性假设。它严格定义了计算联合分布的公式 。
箭头的实际应用: 虽然在数学上 T -&gt; R 和 R -&gt; T 可以等价，但在实践中，我们强烈倾向于让箭头反映真实的因果关系。
为什么? 更简单: 因果模型通常具有更少的父节点 (更稀疏的图)。
更易于思考: 人类专家 (如医生) 更容易提供 而不是 。 缺失变量 (Missing Variables): 有时两个变量 (如 Traffic 和 Drips [屋顶漏水]) 之间没有直接因果关系，但它们是相关的，因为它们有一个共同原因 (Rain)。
T &lt;- R -&gt; D
如果我们构建一个只包含 T 和 D 的模型，我们必须画一个 T -&gt; D 或 D -&gt; T 的箭头来表示它们的相关性，即使这在物理上没有意义。
此时，箭头反映的是相关性 (Correlation)，而非因果性 (Causation)。 到目前为止，我们学习了贝叶斯网络如何编码 (Encode) 一个联合概率分布。下一步是，我们如何从图的结构中读出 (Read) 它所隐含的条件独立性假设？<br>
<img alt="Pasted image 20251105231204.png" src="cs4300/attachments/pasted-image-20251105231204.png" target="_self">
问题: 给定一个 BN 图，我们如何判断“在给定一组证据变量 的情况下，变量 是否必然与变量 条件独立？” (即 是否成立？)
方法: 我们可以通过代数（如前所述）来证明，但这很繁琐。一个更系统的方法是使用 D-Separation (“d” 代表 "directed") 算法。
就像上图, 由于阻挡了和的连接, 所以给定后, , 相互独立. D-Separation 是一种图算法，用于快速判断 是否成立。
核心思想: 我们将“独立性”视为“信息流被阻断 (blocked)”。
我们检查 和 之间所有的无向路径 (undirected paths) (暂时忽略箭头方向)。
如果所有路径都被证据 阻断，那么 成立。
如果存在至少一条活跃 (active) (未被阻断) 的路径，那么独立性不被保证 (它们可能是相关的)。
一条路径是否活跃，取决于该路径上的每一个三元组 (三个节点的子结构) 是否活跃。我们只需要分析三种基本的三元组结构 (A, B, C)，其中 B 是中间节点。
这里所说的活跃是由下面三条规则定义, 而不是单纯的看节点的连接关系!!! 结构: (例如: 低气压 -&gt; 下雨 -&gt; 交通)
路径: A-B-C
规则: 未观测 B 时: (路径是活跃的)。知道低气压会增加你对交通堵塞的相信程度。
观测 B 时: (路径是非活跃/被阻断的)。如果你已经知道正在下雨 (B)，那么知道低气压 (A) 并不会提供关于交通 (C) 的额外信息。 结构: (例如: 项目截止 -&gt; Piazza 繁忙; 项目截止 -&gt; Lab 爆满)
路径: A-B-C
规则: 未观测 B 时: (路径是活跃的)。看到 Piazza 繁忙 (A) 会让你更相信项目快截止了，从而也更相信 Lab 会爆满 (C)。A 和 C 相关。
观测 B 时: (路径是非活跃/被阻断的)。如果你已经知道项目截止 (B)，那么 Piazza 是否繁忙 (A) 和 Lab 是否爆满 (C) 之间就条件独立了。观测原因会阻断其效应之间的关联。 结构: (例如: 下雨 -&gt; 交通; 球赛 -&gt; 交通)
路径: A-B-C
这是最特殊、最反直觉的情况!
规则: 未观测 B 时: (路径是非活跃/被阻断的)。默认情况下，“下雨” (A) 和“球赛” (C) 这两个独立的原因是相互独立的。
观测 B 时: (路径是活跃的)。如果你知道发生了交通堵塞 (B)，那么 A 和 C 之间变得相关。
解释 (Explaining Away): 如果你知道堵车了 (B)，但你又知道今天没有球赛 ()，那么你就更倾向于相信堵车是“下雨” () 引起的。观测共同效应会使其原因之间产生竞争性解释，从而变得相关。
扩展规则: 如果观测到 B 或 B 的任何后代 (descendant)，这条路径都会变为活跃。 我们要判断 (Z 是证据集)。 找到 和 之间所有的无向路径。 对每一条路径，检查它是否被 阻断。 一条路径被阻断 (blocked/inactive)，当且仅当它至少包含一个三元组 A-B-C 满足以下任一条件： 因果链或共同原因被观测: 或 ，且中间节点 B 在证据集 Z 中。
共同效应未被观测: ，且中间节点 B 不在 证据集 Z 中，并且 B 的任何后代 (descendant) 也不在 Z 中。 如果一条路径未被阻断，则称其为活跃路径 (active path)。 最终裁决: 如果 和 之间的所有路径都被阻断，则 成立 (它们保证独立)。
如果至少存在一条活跃路径，则 不被保证 (它们可能是相关的)。 我们已经知道如何构建 BN 并从中读取独立性。现在，我们要使用网络来回答查询 (Answering Queries)，这个过程称为推理。推理 (Inference) 是指从已知的联合概率分布（由 BN 编码）中计算某个有用数量的过程。最常见的查询类型包括： 后验概率 (Posterior Probability): “给定我所看到的证据 E (例如病人咳嗽)，我所关心的查询变量 Q (例如患有肺炎) 的概率是多少？” 最可能的解释 (Most Likely Explanation, MPE): “给定证据 E，哪个 Q 的状态 (例如哪种疾病) 是最有可能的？” 在任何推理任务中，我们将所有变量分为三类：
查询变量 (Query Variables, Q): 我们想要在推理结束时知道其概率分布的变量。
证据变量 (Evidence Variables, E): 我们已经观测到其确定值的变量（例如，JohnCalls = true）。
隐藏变量 (Hidden Variables, H): 既不是查询变量也不是证据变量的所有其他变量。
这是最基础、最直接的推理方法。核心思想：我们通过求和（边缘化）来“消除”所有隐藏变量。步骤：
选择 (Select): 找出联合分布中所有与证据 相一致的条目。
求和 (Sum out / Marginalize): 通过对所有可能的隐藏变量 进行求和，来“消除”所有隐藏变量 。 归一化 (Normalize): 我们得到的结果 不是一个关于 的有效概率分布。我们需要将其归一化，使其总和为 1。 示例： (警报网络)<br>
<img alt="Pasted image 20251101133725.png" src="cs4300/attachments/pasted-image-20251101133725.png" target="_self" style="width: 300px; max-width: 100%;">
查询: 证据: , 隐藏: , 根据 BN 公式写出全联合分布： 对隐藏变量 和 求和 - 由于, 是隐藏变量, 所以我们需要考虑到他们的所有可能 (比如发生和没有发生地震), 这就是为什么求和需要和 ：
分别计算 和 。
归一化：
问题: 这种方法非常慢。它必须在求和之前“连接 (join)”所有变量，创建一个巨大的中间表。其复杂度与隐藏变量的数量成指数关系 (NP-hard)。
思想: 避免构建完整的联合分布表。而是交错地 (interleave) 进行乘法 (join) 和求和 (marginalize)。
过程: 我们可以重排上一个例子的计算顺序，将求和尽可能向内推： 我们可以在计算过程中动态地生成和消除这些小的中间因子。
结果: 仍然是 NP-hard (最坏情况下)，但对于稀疏网络，它通常比纯粹的枚举法快得多。
当精确推理（如 VE）在计算上不可行时（例如网络非常大或连接紧密），我们转而使用近似方法。 思想: 采样就像进行大量重复模拟 (repeated simulation)。 优势: 获取一个样本通常非常快。
这是一个 "anytime" 算法：我们可以根据可用的时间来决定采样的数量 N。时间越长，样本越多，结果越接近真实概率。 基本技术: 如何从 CPT 采样 我们假设有一个能生成 [0, 1) 之间均匀随机数的函数 random()。
我们将 [0, 1) 的区间根据 CPT 划分为 "桶 (buckets)"。
示例 CPT: 规则: [0, 0.6) red
[0.6, 0.7) green (0.6 + 0.1)
[0.7, 1.0) blue (0.7 + 0.3) 如果 random() 返回 0.83，我们就选择 "blue"。 这是最简单、最直观的采样方法。<br>
<img alt="Pasted image 20251109212244.png" src="cs4300/attachments/pasted-image-20251109212244.png" target="_self" style="width: 500px; max-width: 100%;">
算法: 按照拓扑排序 (从父节点到子节点，例如 B, E, A, J, M) 遍历所有变量 。
对于每个变量 ，根据其 CPT 进行采样。 (对于根节点如 B，就是从 采样)。
(对于 A，我们使用已经采样得到的 B 和 E 的值，查找 CPT 对应的行，然后采样)。 一个完整的列表 就是一个样本。 特点: 生成的样本 完全服从 BN 的真实联合分布 。
非常简单，我们不需要计算完整的联合分布表。 如何使用 (回答查询): P(W) (无条件查询): 只需统计样本中 出现 true 和 false 的次数，然后归一化。 示例: 收集 5 个样本，得到 &lt;+w: 4, -w: 1&gt;。
估计: 。 P(C | +w) (条件查询): 拒绝 (Reject) 所有 不为 +w 的样本。
在剩余的样本中，统计 的次数并归一化。 问题: 效率极低。如果证据 (如 +w) 是一个罕见事件 (例如 )，我们必须丢弃 99.9% 的样本，造成巨大浪费。 思想: 这是对先验采样的一种简单优化，用于回答条件查询 。
算法: 像先验采样一样从上到下开始采样。
一旦采样的某个变量 与证据 不一致 (例如，证据是 S=+s，但我们采样得到了 S=-s)：
立即停止 (Reject)，丢弃这个（未完成的）样本，从头开始一个新的。 特点: 避免了在已知无效的样本上浪费计算 (例如，在采样到 -s 后还继续采样 R 和 W)。
问题: 如果证据 是低概率事件，我们仍然会拒绝绝大多数样本，效率依然很低。
<br><img alt="Pasted image 20251109231226.png" src="cs4300/attachments/pasted-image-20251109231226.png" target="_self">
思想: 解决拒绝采样的浪费问题。我们不再拒绝，而是强制让样本与证据一致，并通过一个“权重”来修正。
算法: 初始化样本权重 。
从上到下拓扑遍历所有变量 。
Case 1: 不是证据变量: 就像先验采样一样，根据 正常采样。 Case 2: 是证据变量 (值为 ): 不要采样！ 将 的值固定 (fix) 为 , 比如我们需要知道的概率, 但已知, 所以遍历到的时候, 我们直接把这个值设定成
更新权重: 。 (这个概率是从 CPT 查到的，它代表了我们“强制”的这一步发生的可能性)。 返回样本 和它的权重 。 如何使用 (回答查询 ): 收集 N 个带权重的样本 (注意：所有样本都与证据 一致)。
初始化一个空的计数器 (例如，Counts[q] = 0.0)。
对于每个样本 ： 提取 的值 。
Counts[q] = Counts[q] + w (按权重累加)。 对 Counts 字典进行归一化，得到最终的概率分布 - 也就是 问题: LW 仍然存在问题。证据 只影响其下游 (downstream) 变量的采样。其上游 (upstream) 变量（即 的祖先）在采样时 "不知道" 的存在。如果上游变量的采样结果与 "不匹配" (即导致 非常小)，该样本的权重就会极小，导致高方差。 思想: 一种完全不同的方法，属于 MCMC (马尔可夫链蒙特卡洛)。它允许证据在所有方向 (上游和下游) 传播，解决了 LW 的问题。
算法: 固定 (Fix) 所有证据变量 的值为 。
随机初始化所有隐藏变量 的值（赋任意值）。
重复执行 N 次 (N 很大):
a. 随机选择一个非证据 (隐藏) 变量 。
b. 重新采样 (Resample) 的值，其条件是所有其他当前变量（即它的马尔可夫毯 - Markov Blanket）。 如何使用: 这个过程会生成一系列完整的状态（样本）。
丢弃前 K 个样本 (称为 "burn-in" 预热期)，因为初始的随机状态可能很差。
在剩余的 (N-K) 个样本中，像先验采样一样直接计数 (所有样本都为 1)。 特点: 在极限情况下，样本来自真实的后验分布 。这是现代贝叶斯推理的标准方法之一。
我们之前讨论的贝叶斯网络主要用于处理不确定性。现在我们要结合动作 (Actions) 和效用 (Utility)，从而做出决策。决策网络（有时也称为影响图 Influence Diagrams）将贝叶斯网络与决策论结合在一起。我们的目标是创建一个效用最大化 (Utility Maximizers) 的系统。<br>
<img alt="Pasted image 20251115145159.png" src="cs4300/attachments/pasted-image-20251115145159.png" target="_self">决策网络在普通贝叶斯网络的基础上增加了两种新节点：
机会节点 (Chance Nodes) (椭圆/圆形): 普通的随机变量，就像在贝叶斯网络中一样。
代表不确定的世界状态（例如：Weather，Forecast）。 动作节点 (Action Nodes) (矩形): 代表智能体可以做出的决策。
没有父节点：我们在这个节点“选择”一个值，而不是观察它。
例如：Take Umbrella 或 Leave Umbrella。 效用节点 (Utility Nodes) (菱形): 代表智能体的“快乐程度”或奖励。
取决于动作和/或世界状态。
例如：。如果带了伞且下雨，效用可能一般；如果没带伞且下雨，效用很低。 我们的目标是选择一个动作 ，使得期望效用 (Expected Utility, EU) 最大化。 公式: : 给定当前证据 (如预报)，状态 (如天气) 的后验概率。
: 在状态 下采取动作 的效用。 决策过程: 实例化证据: 填入所有已知的观测值 (例如 Forecast = bad)。
计算后验: 对效用节点的每个父节点 (如 Weather)，计算其在当前证据下的后验概率 。
计算期望效用: 对每个可能的动作 ，计算 。
<br>选择最优: 选择 最高的动作。这被称为 MEU (Maximum Expected Utility)。<img alt="Pasted image 20251115150807.png" src="cs4300/attachments/pasted-image-20251115150807.png" target="_self"> 这里的的这个表格通常是用贝叶斯定理算出来的 (拿和得到) - 因为很容易就能知道天气是好是坏的概率, 和给定一个天气, 当天的天气预报是好是坏的概率 我们在做决策时，通常有机会在行动之前获取更多信息（例如：听天气预报、进行医疗检测、派侦察兵）。信息的价值在于它能改变我们的信念，从而可能改变我们的决策，最终提高期望效用。
完全信息的价值 (Value of Perfect Information, VPI): 我们愿意为“完全消除关于某个变量的不确定性”支付多少代价？
直观理解：如果知道了某个信息能让你改变决策并获得更好的结果，那么这个信息就有价值。如果无论你知道什么，你的决策都不变，那么这个信息的价值为 0。
假设我们当前的证据是 ，我们考虑是否要获取关于变量 的新证据。
当前 (Acting Now): 不获取新信息，直接根据当前证据 做出的最大期望效用。 假设获取信息后 (Acting After): 假设我们观察到了 ，我们会根据这个新证据做出最佳决策。 期望 (Expectation): 但我们现在还不知道 的结果是什么，所以我们需要对 的所有可能结果取期望。 价值 (VPI): 就像上面天气预报的例子: 如果我们去听天气预报, 这个额外的信息价值多少呢?
假设我们已经知道: - 当我们不看天气预报, 最大的Reward是70
这时候, 我们就需要考虑天气预报报好天气的概率大还是坏天气的概率大了:
假设天气预报结果概率如下:
我们就可以知道: 在的情况下, 天气预报会说是好天气, 这样我们的MEU就会是, 反之是这说明了, 如果我们额外获取了天气预报的信息, 我们的最大MEU从提升到了 - 这就说明, 天气预报这个信息大约价值的Reward
非负性 (Non-negative): 。 获取信息永远不会降低你的期望效用。最坏的情况是你忽略这个信息，保持原来的决策（价值为 0）。 非加性 (Non-additive): 。 通常存在边际收益递减。例如，买第二个天气预报的价值通常低于买第一个。 顺序无关性 (Order-independent): 获取信息的顺序不影响其总价值。 如果效用节点的父节点 (Parents of U) 在给定当前证据 的情况下与变量 条件独立，那么 。
这意味着了解 不会改变我们要最大化的那个分布，因此也不会改变我们的决策。<br>
<img alt="Pasted image 20251115222021.png" src="cs4300/attachments/pasted-image-20251115222021.png" target="_self" style="width: 500px; max-width: 100%;">
这部分只是一个简短的介绍。
MDPs: 状态 、动作 、转移 、奖励 。我们总是知道自己在哪个状态 。
POMDPs (Partially Observable MDPs): 增加了 观测 (Observations, O) 和 观测函数 。
我们永远不知道确切的当前状态 ，只知道一个信念状态 (Belief State) (即状态 上的概率分布)。
POMDP 可以被视为是在“信念状态空间”上的 MDP。这个空间是连续的，因此求解非常困难。 到目前为止，我们的贝叶斯网络都是静态的。马尔可夫模型将贝叶斯网络引入了时间 (Time) 维度。马尔可夫模型可以看作是一个随时间延伸的贝叶斯网络链。
变量: (代表每个时间步的状态)。
参数: 初始分布: 转移模型 (Transition Model): 为了简化模型，我们做出两个假设：
马尔可夫假设 (Markov Assumption): “未来仅取决于现在，与过去无关。”
数学表达: 这意味着在贝叶斯网络中，每个节点只与其前一个时间步的节点相连。 平稳性假设 (Stationarity Assumption): 转移模型 在所有时间步 都是相同的。
这大大减少了参数数量：我们只需要一个条件概率表 (CPT) 就可以描述整个时间序列的动态。 基于上述假设，马尔可夫模型的联合分布可以写为：
如果我们要计算 时刻的状态分布 ，我们可以通过链式法则递推： 这本质上是利用上一时刻的分布，通过转移矩阵“推”到下一时刻。<br>
<img alt="Pasted image 20251115234536.png" src="cs4300/attachments/pasted-image-20251115234536.png" target="_self">
比如上图中, 给定Day 1, 观测到是完全晴天. 并且我们知道晴天有0.9的概率明天还是晴天. 所以我们就可以由此得到Day 2晴天和阴天的概率
<br><img alt="Pasted image 20251115234816.png" src="cs4300/attachments/pasted-image-20251115234816.png" target="_self"><br>
<img alt="Pasted image 20251115235935.png" src="cs4300/attachments/pasted-image-20251115235935.png" target="_self">
随着时间推移 ()，如果不确定性不再变化，系统可能会进入一个平稳分布 。 就可以认为, 几万年后的某天的天气, 跟今天的天气关系并不大 定义: 在这个分布下，经过一次时间步转移后，分布保持不变： 这相当于求解线性方程组。
应用: Google PageRank Larry Page 和 Sergey Brin 利用这个概念创建了 Google。
Web 作为马尔可夫模型: 每个网页是一个状态，超链接是转移。
PageRank: 本质上就是这个巨大的马尔可夫链的平稳分布。用户在网页间随机跳转（Random Surfer Model），最终停留在某个页面的概率就是该页面的排名 (Rank)。 在现实世界中 (如机器人定位、语音识别)，我们通常无法直接观察到系统的真实状态 (如确切位置 )，只能获得有噪的观测数据 (如传感器读数 )。这就是隐马尔可夫模型。HMM 是在马尔可夫链的基础上增加了观测/证据变量。
隐藏状态 (Hidden States): (不可见，如真实的幽灵位置、真实的天气)。
观测变量 (Evidence/Observations): (可见，如传感器读数、导师是否带伞)。
参数: 初始分布: 转移模型: (描述状态如何演变)
发射/传感器模型 (Emission/Sensor Model): (描述观测证据如何由状态产生) 示例: 悲伤的研究生 (Weather HMM)
隐藏状态: 真实天气 (Rain, Sun)。
观测: 导师是否带伞 (Umbrella: True/False)。
我们无法看到窗外，只能通过看导师是否带伞来推测天气。<br>
<img alt="Pasted image 20251116004211.png" src="cs4300/attachments/pasted-image-20251116004211.png" target="_self">
HMM 具有两个关键的条件独立性：
马尔可夫假设 (同 MM): (状态仅依赖于上一状态)。
传感器假设 (Sensor Assumption): 。 即：当前的观测仅取决于当前的状态。 重要提示 (关于证据的相关性):
虽然给定 时 独立于其他变量，但在未观测到状态 X 的情况下，证据变量 和 是高度相关的！
原因：通过未观测的 存在路径 (D-Separation 中的未观测公共原因或因果链)。这正是我们能通过一系列观测来推断状态的原因。 任务: 给定直到现在的证据序列 ，计算当前状态的信念分布 (Belief State)。
目标: 计算 。
这是一个在线 (Online) 算法，随着时间推移不断更新。算法分为两步循环：时间流逝 (Passage of Time) 和 观测 (Observation)。在获得新的证据之前，先根据转移模型预测下一时刻的状态。
输入: 上一时刻的后验信念 输出: 当前时刻的先验信念 (注意证据只到 )
公式: 直观理解: 这就是马尔可夫模型的“前向模拟”。我们将信念“推”过转移矩阵。通常这会增加不确定性（概率分布变平坦）。
获得当前时刻的新证据 ，用它来修正我们的预测。
输入: 预测的信念 和 新证据 输出: 当前时刻的后验信念 公式: 直观理解: 使用贝叶斯法则。 是先验 (从第一步得到)。 是似然 (从传感器模型 CPT 查表)。
我们需要对结果进行归一化。 这一步通常会减少不确定性（波函数坍缩，排除不可能的状态）。<br>
<img alt="Pasted image 20251122201213.png" src="cs4300/attachments/pasted-image-20251122201213.png" target="_self">
比如上图的表示的就是当没有观测到当前的证据的时候, 我们认为这个事件(下雨) 发生的概率.
这里假设两天观测到的都是带伞了 从到, 由于没有任何证据, 并且从概率表上可以看出, 如果今天的概率是一半一半, 那么明天的概率仍然是一半一半()由于我们已经知道导师在不同天气带伞的概率了(表2), 所以我们可以用贝叶斯公式去计算反过来的概率: 当导师带伞, 那么下雨的概率是多少
由于公式是: , 所以我们还需要知道没有证据情况下带伞的概率. 我们可以边缘化一下, 通过, 也就是带伞概率是, 不带伞的概率是
接着, 用贝叶斯算出当带伞的时候, 下雨的概率是多少:
这里等同于直接相乘, 然后归一化()
接下来到下一天, 当我们没有任何证据的时候, 我们就会用表一去推测这一天的天气, 并在观测到证据后用表二去计算. 可以看到, 每次第二天, 我们的预测都会逐渐模糊(也就是会开始靠近0.5, 0.5), 但当我们观测到有没有带伞的这个证据后, 预测概率又会被矫正将上述两步合并，我们得到递推公式：
加权 (Weight): 根据 加权。
转移 (Predict): 通过 预测。
修正 (Update): 通过 修正。
归一化 (Normalize): 确保总和为 1。
复杂度: ，其中 是状态数量， 是时间步数。比枚举法 () 高效得多。
场景: 机器人在网格地图中移动，不知道确切位置。
观测: 传感器检测墙壁 (如：四周是否有墙，读数为 NSWE 的位向量)。
过程: 初始: 均匀分布 (Belief 分布在所有可能的格子上)。
观测 : 比如看到“左边有墙”。排除所有左边没墙的格子 (概率变0)。概率分布坍缩。
移动: 概率分布根据运动模型“弥散” (增加不确定性，可能滑倒没动，也可能动了)。
观测 : 结合新的传感器读数，再次锐化概率分布。
结果: 随着时间推移，通过不断排除不可能的状态，机器人能迅速确定自己的位置。<br>
<img alt="Pasted image 20251116010758.png" src="cs4300/attachments/pasted-image-20251116010758.png" target="_self" style="width: 220px; max-width: 100%;"><img alt="Pasted image 20251116010805.png" src="cs4300/attachments/pasted-image-20251116010805.png" target="_self" style="width: 220px; max-width: 100%;"><img alt="Pasted image 20251116010811.png" src="cs4300/attachments/pasted-image-20251116010811.png" target="_self" style="width: 220px; max-width: 100%;"> 当前向算法 (精确推理) 因为状态空间过大而无法计算时，我们使用粒子滤波。
问题: 前向算法的时间复杂度是 。
如果状态空间 非常大 (例如 Pac-Man 游戏中所有鬼魂位置的组合)，或者状态是连续的 (机器人精确坐标)，精确推理太慢甚至不可行。
状态空间太大，甚至无法存储整个信念分布 。 解决方案: 使用采样 (Sampling) 进行近似推理 (Approximate Inference)。 粒子 (Particles): 我们用一个包含 个样本的列表来表示信念分布 。 列表: 每个粒子 代表系统状态的一个可能假设 (例如：鬼魂在 (3,3) 位置)。 密度即概率: 某个区域内的粒子越密集，表示该状态的概率越高。
如果某个区域没有粒子，表示该状态概率接近 0。 近似: 越大，近似越精确。
当 时，粒子滤波收敛于精确推理。 粒子滤波通过不断更新粒子列表来跟踪状态。每一步包含两个阶段：时间流逝和观测。
操作: 对列表中的每一个粒子，根据转移模型 进行采样，得到新的位置。 效果: 这类似于 HMM 中的预测步骤。
增加了状态的不确定性 (粒子会扩散开)。
这一步利用了现有的转移模型 (Transition Model) 来模拟物理过程。 操作: 获得证据 后，根据发射模型 为每个粒子计算权重 。 效果: 如果粒子所在的位置与观测证据吻合 (例如：粒子在墙边，传感器也显示有墙)，则权重高。
如果不吻合，权重低。
这类似于 HMM 中的观测更新步骤 (Likelihood Weighting)。 操作: 我们现在有一个带权重的粒子列表。
我们通过有放回采样 (Sample with replacement)，根据权重 从旧列表中抽取 个粒子，形成新列表。 效果: 适者生存 (Survival of the fittest): 高权重的粒子会被多次选中 (复制)，低权重的粒子可能会消失。
这一步将权重归一化，并让粒子集中在后验概率高的区域。
重采样后，所有新粒子的权重恢复为 1。 单粒子问题 (One Particle): 如果 ，粒子滤波将失效。
因为重采样是从 1 个粒子中采 1 个，无论权重是多少，结果永远是它自己。这导致证据被完全忽略。 确定性转移问题 (Deterministic Transition): 如果转移模型完全没有噪声 (Deterministic)，粒子在重采样后会不断重复，最终所有粒子都会坍缩成单一的轨迹。
解决方案: 即使物理模型是确定性的，也必须在转移函数中人为添加噪声，以确保粒子能够分散开来探索状态空间。 SLAM (Simultaneous Localization and Mapping): 粒子滤波不仅可以用于定位 (已知地图，求位置)，还可以扩展用于 SLAM (未知地图，同时求位置和构建地图)。
每个粒子携带一个“假设的地图”和一个“假设的位置”。 ]]></description><link>cs4300/bayes&apos;-nets.html</link><guid isPermaLink="false">CS4300/Bayes&apos; Nets.md</guid><pubDate>Thu, 11 Dec 2025 21:14:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[JavaScript]]></title><description><![CDATA[JS 为了让浏览器实现实时交互 - 这样就不用当用户每次操作都得与服务器交流并返回新的HTML了.JS可以做到
增删元素
更改数据
布局元素
给元素修改class, 这样就能挂上CSS规则
JS比较容易学习, 跟Python有点像, 不过:
定义变量要用let
用for(let val of arr)来遍历对象, 而不是for ... in
需要用{}定义Scope
用function定义函数
支持Lambda, 如.withCallback((e)=&gt;{return doSomething(e);});
最好使用===比较, 而不是==
如果想在HTML使用JS, 则需要写:&lt;script src="file.js" type="module"&gt;&lt;/script&gt;
可以看到, 我们需要用src定义文件位置, 还需要标注type的值浏览器会直接在服务器下载这个js文件, 然后会先执行这些脚本, 然后再把HTML渲染到浏览器上在JS中, 我们可以通过下面这种方式选择元素. 这里的Selector跟CSS的一样//返回选择的单个元素
document.querySelector("selector")
//返回选择的所有元素
document.querySelectorAll("selector") let paragraphs = document.querySelectorAll("p")
paragraphs[1]
paragraphs[2]
for(let p of paragraphs) //当然, 还可以选择class和id
document.querySelector("#id")
document.querySelectorAll(".foo")
document.querySelectorAll("form input")//所有在form中的input
当然, 我们单纯选择元素没意思, 我们需要有什么办法当用户做某件事触发一个函数//element表示的就是上面我们选择的某个元素, 如果是多个元素, 我们需要用for循环add事件
//type支持hover, click, 和submit等
// 除此之外, 还有focus, blur表示用户是否正在选择这个元素
element.addEventListener("type", (e)=&gt;{ do_something
}); //或者, 我们也可以把(e)=&gt;{xxxx}替换成一个函数, 其中函数的第一个参数是e. 不过这样会导致我们无法访问scope的内容, 除非把需要的内容当参数传递进去
由于有时候浏览器会有自己的行为定义, 如点击链接会转跳. 我们可以覆写这种行为element.preventDefault();
这样对应的这些元素都无法执行原有的行为
不过在大部分时间, 不要用JS把元素改掉原本的行为: 因为用户本来就期待如此, 就像点击链接转跳, 而是应该增强体验: 如用户输入时实时检索
首先, 我们可以用document.querySelector("#id")先选择某个元素.
然后, 我们就可以直接对这个变量进行某个属性的赋值就可以修改属性了:let elt = document.querySelector("#someElement")
elt.value = "xxx"
let show_pwd_box = document.querySelector("#show_pwd_box")
if(show_pwd_box){ show_pwd_box.addEventListener("click", (e)=&gt;{ let form = show_pwd_box.closest("form"); let pwd_input = form.querySelector("input[name=password]"); if(show_pwd_box.checked){ pwd_input.type = "text"; }else { pwd_input.type = "password" } })
}
由于class用得太多了, 所以有一系列专门添加class的函数element.classList.add("selected")
element.classList.toggle("selected")
element.classList.remove("selected")
element.classList.contains("selected")
并且, 我们还可以在创建HTML的时候, 创建专门给JS用的属性&lt;a class="cat" data-cat-name="{{cat.name}}" href=xxx&gt;&lt;/a&gt;
然后在JS中, cat-name就会变成catNamelet name = cat.dataset.catName
<img alt="Pasted image 20251111091834.png" src="cs3550/attachments/pasted-image-20251111091834.png" target="_self"><br>
<img alt="Pasted image 20251111091934.png" src="cs3550/attachments/pasted-image-20251111091934.png" target="_self">在之前, 一般如果用户需要新信息, 都需要转跳到一个新网页. 但是到Web 2.0, 我们引入了一个新概念: AJAX - asynchronous JavaScript And XML
也就是当用户需要新信息的时候, 会在网页上执行Json代码, 然后去跟网页的API交互, 并在网页上显示出来.Fetch就是JavaScript中的一个重要函数: 它会去请求某个网页, 并返回一个Promise对象.
虽然这个方法是异步的, 但由于JS是单线程的, 所以如果有其他的函数正在进行一个长耗时计算的时候, then可能需要等一会才会被调用(因为它不会打断现有执行)
这个Promise对象表示的就是 "我可以保证这是个网络资源, 但我不保证这个资源什么时候可用"
所以我们就需要在fetch后面跟上一个then函数告诉拿到数据后准备干什么fetch("/").then( (resp)=&gt;{console.log(resp)} )
同样的, 我们不仅仅可以用fetch获得数据, 也可以用fetch给网页发送post请求fetch("/"){ method="POST", body="hello",
}
在fetch请求到网页后, 如果我们想访问到里面的真正内容, 我们需要使用resp.text()来读取里面的内容. 但这个函数返回的也是一个promise, 所以我们得再叠一层thenfetch("/").then((resp)=&gt;{ //发起请求 return resp.text()
}).then((data)=&gt;{ //开始回应请求 console.log(data) //真正得到响应
}) 所以, 这就会导致这个过程中有两个地方可能出现问题:
请求错误 (如网址不存在)
响应错误 (服务器响应了, 但返回了错误代码, 如500)
fetch("/").catch( (e)=&gt;{ console.log("request error") //catch 可以放在then前面或后面. 但不能放到第二个then后面. 不然就变成catch第二个then的error了
}).then((resp)=&gt;{ if(!resp.ok){ condole.log("response error") return; } return resp.text()
}).then((data)=&gt;{ console.log(data) })
上面这种写法太难看了, 我们可以用下面这种await的方法替换try{ let resp = await fetch("xxx") if(!resp.ok){ throw Error(resp) } let data = await resp.json() console.log(data)
}catch(e){ throw Error(e)
}
当然, 如果我们想用代码请求接口来获得数据, 我们肯定不能直接fetch之前的给用户看的网页 - 上面全是没用的HTML.
更好的解决办法是创建一些独立的urls, 比如是/api/xxx用来专门返回给JS读取的数据, 如JSONdef api_view(request, id): ... return JsonResponse({ "name": obj.name, ... })
如果我们知道API返回的是JSON, 则我们可以直接调用resp.json()来把JSON解析回数据结构fetch("/").catch( (e)=&gt;{ console.log("request error") }).then((resp)=&gt;{ if(!resp.ok){ condole.log("response error") return; } return resp.json() //Parse Json to Obj
}).then((data)=&gt;{ console.log(data.name) //Use Obj.xxx to access field
})
在这里, JS也包含在Front End中 - 因为只要是运行在用户电脑上而不是服务器上的, 都可以称为Front End性能是个很重要的事情, 因为人们很容易察觉如果页面有卡顿. 比如在用手指拖拽某个元素的时候, 最高的不可感知延迟大约是18ms - 页面稍微卡一点都能察觉出来在检查我们性能的时候, 我们通常关心三个耗时
第一次加载 - Uncache Load: 通常叫做LCP 重复访问 - Cached Load
实时交互: 比如点击按钮等, 通常叫做INP
浏览器的开发者工具中在每次加载页面的时候, 会显示LCP. 在与网页交互的时候会显示INP.我们可以根据这些数据来判断哪些地方可以优化, 比如请求小资源太多, 我们可以合并一些请求]]></description><link>cs3550/javascript.html</link><guid isPermaLink="false">CS3550/JavaScript.md</guid><pubDate>Tue, 09 Dec 2025 02:54:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[HTML]]></title><description><![CDATA[在HTML中, 文字可以用Tag进行装饰:This is a text, and &lt;em&gt; this is italic&lt;/em&gt; &lt;a href="https://..."&gt; display text&lt;/a&gt;比如上面的&lt;a xxx&gt;xxx&lt;/a&gt;和&lt;em&gt;xxx&lt;/em&gt;都是Tag - Text Formatting Tag<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Reference" target="_self">更多资源</a>常见的文本修饰标签有： &lt;a href="..."&gt;text&lt;/a&gt;
超链接标签，用来创建跳转 href属性是链接的地址
&lt;a href="https://example.com"&gt;Visit&lt;/a&gt; 不要和&lt;link&gt;搞混了! &lt;em&gt;text&lt;/em&gt;
表示强调，通常渲染成斜体 &lt;strong&gt;text&lt;/strong&gt;
表示重点强调，通常渲染成粗体 &lt;code&gt;code here&lt;/code&gt;
表示代码片段，通常渲染成等宽字体 &lt;img src="..." alt="..."&gt;
插入图片，其中 src 是图片路径，alt 提供文字替代（对无障碍很重要） 用于结构化文本的标签：&lt;p&gt; paragraph &lt;/p&gt; &lt;!-- 段落 --&gt; &lt;h1&gt;Heading 1&lt;/h1&gt; ... &lt;h6&gt;Heading 6&lt;/h6&gt; &lt;!-- 六级标题 --&gt; &lt;pre&gt; pre formatted text &lt;/pre&gt; &lt;!-- 保留空格/换行 --&gt; 这里的&lt;h1&gt;标签和&lt;h&gt;标签不是同样的效果, 后者是用来高亮文字的
用于页面布局的标签：&lt;header&gt;：页眉区域
&lt;footer&gt;：页脚区域
&lt;main&gt;：页面主体（唯一）
&lt;nav&gt;：导航区域
这些称为 landmark 元素，对无障碍（Accessibility）很重要 Tag还可以包含一些数据, 告诉浏览器一些信息:&lt;!doctype html&gt; &lt;!-- 声明HTML版本 --&gt; &lt;meta charset="UTF-8"&gt; &lt;!-- 网页编码 --&gt; &lt;title&gt;Page Title&lt;/title&gt; &lt;!-- 页签标题 --&gt; &lt;link rel="icon" href="..."&gt; &lt;!-- 网页图标 --&gt; 注意：&lt;head&gt; 中包含这些 Metadata 标签，和 &lt;header&gt; 不同 &lt;ul&gt; &lt;!-- 无序列表 --&gt; &lt;li&gt;Item 1&lt;/li&gt; &lt;li&gt;Item 2&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;!-- 有序列表 --&gt; &lt;li&gt;First&lt;/li&gt; &lt;li&gt;Second&lt;/li&gt; &lt;/ol&gt; &lt;menu&gt; &lt;li&gt;item 1&lt;/li&gt;
&lt;/menu&gt;
&lt;table&gt; &lt;tr&gt; &lt;td&gt;Row1 Col1&lt;/td&gt; &lt;td&gt;Row1 Col2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Row2 Col1&lt;/td&gt; &lt;td&gt;Row2 Col2&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;table&gt; 表示表格
&lt;tr&gt; 表示一行 table row
&lt;td&gt; 表示单元格 table data &amp;lt; 表示 &lt; &amp;rt; 表示 &gt; &amp;amp; 表示&amp;
&lt;!-- ..--&gt; 表示注释
但为什么这么多不同的Tag呢? 而且就比如&lt;span&gt;和&lt;div&gt;在单独使用后根本就没有区别首先这些不同名字的tag拥有不同的语义(Semantics), 他们不仅仅可以让不同的开发者一起合作, 更多的还是给css分辨, 这样就可以在我们更改格式的时候不用更改内容世界上有很多有缺陷的人, 如:
Motor, 如帕金森
Vision, 如盲人
英语不是第一语言的
让网页增加Accessibility, 不仅仅可以帮助这些有缺陷的人, 还可以让普通人使用起来更加方便对于盲人来说, 他们会使用阅读器来阅读网页, 而阅读器不像人眼可以看到整个网页, 它是线性的 - 也就是如果我们的网页如果没有结构, 则阅读器需要从开始一直读到想要的地方. 但如果有一个好用的结构, 阅读器可以在&lt;Header&gt;, &lt;nav&gt;和不同的&lt;h1&gt;, &lt;h2&gt;, ...转跳<br>还有, 就是在网页上, 元素都最好是自洽的, 如 "在<a data-tooltip-position="top" aria-label="" rel="noopener nofollow" class="external-link is-unresolved" href="" target="_self">这里</a>填入表格", 和"请填入<a data-tooltip-position="top" aria-label="" rel="noopener nofollow" class="external-link is-unresolved" href="" target="_self">表格</a>". 前者的"这里"很容易被人忽略, 而后者更容易阅读. 在form中的input前, 最好不要使用&lt;p&gt;来描述这个输入框, 而是用&lt;label&gt;, 并在lable中用for="xxx"跟输入框的id进行关联, 这是因为不仅仅阅读器可以在阅读的时候, 会同时读出label和输入框, 不像&lt;p&gt;那样是分开读的
而且如果把输入框放入&lt;label&gt;中还可以让输入框有更大的hitbox (点击label的时候也会自动转跳到输入框), 手机会更容易点击到.在元素中如&lt;div lang=es&gt;插入语言标识也是一个好处, 比如这里就可以告诉浏览器这部分是西班牙语, 这样浏览器就可以提供翻译等功能并且文字的阅读性也很重要, 通常需要让contract ratio保持在1:7 或1:4.5左右总的来说, 要增加网页的Accessibility, 可以遵循:
使用 正确的标题层级 (&lt;h1&gt; → &lt;h2&gt; → &lt;h3&gt;) 为图片添加 alt 描述 在 &lt;html&gt; 中声明语言属性 lang="en" 或 lang="zh"
表单元素要配合 &lt;label&gt; 使用
使用 &lt;main&gt;, &lt;nav&gt;, &lt;header&gt;, &lt;footer&gt; 来标记页面区域 需要能识别和修复常见错误：
标签未闭合 嵌套顺序错误 缺少必要属性（如 &lt;img&gt; 缺 alt） block 和 inline 混用错误 混淆相似标签： &lt;head&gt; vs &lt;header&gt; &lt;a&gt; vs &lt;link&gt; &lt;h1&gt; vs &lt;header&gt; 在最初的时候, HTML是没有办法进行排版的. 在后面, 增加了一些elements(Tags)可以提供修改格式的功能, 如颜色, 大小等但这样的问题就是, 每个HTML元素都需要加上同样的Tag来做到格式统一, 尤其是完成整个网页后, 如果想修改某个东西的格式, 是非常困难的 - 需要找到所有的元素然后修改它的Tag这就是CSS的好处: 另外一个语言专门用来负责表示排版的, 并且一个CSS可以被多个网页共用.&lt;link rel=stylesheet href="/static/main.css" /&gt;
CSS就是一系列的规则, 是由Selectors和body组成的.strong {color : red;} ~~~~~~~~~~~~~~~~~~~~~~ -&gt;rule
.action {background : blue;} ~~~~~~~~~~~~~~~~~~~-&gt;body
.action strong{color : yellow} ~~~~~~~~~~~~~~~ -&gt;Selector Selector 就是通过Tag进行选择. 比如我们在没有创建CSS的时候, 浏览器会使用自带的CSS, 这就是为什么&lt;h1&gt;是大字体, 链接是蓝色的. 上面是一些常用的Selector选择方法Class和ID都能让Selector定位到某个元素. 但是不同的是同一个Class可以对多个元素进行标记, 而一个网页中只能有一个相同的ID
在元素上挂上class=就可以标注某个元素是什么class了&lt;h2&gt;Cat: &lt;em class="class feature"&gt;ABC&lt;em/&gt;&lt;h2/&gt;
比如上面的例子, 就是文字ABC拥有了两个Class, 类名分别是class和featurea:hover{ color : yellow
}
上面这种连一起的就是两种Selector都要满足: 这样鼠标悬浮在链接上, 链接就变成了黄色有时候, 我们写的CSS可能没有效果, 这是因为可能有些CSS被覆盖掉了. 我们可以在浏览器中的Style中看到CSS的优先级: 如果有CSS的优先级太低, 则他会在Debugger中被划掉.
这个优先级的评判标准是按照它修改了几个ID, Class, Tag表示的. 修改的数量越多, 则它的优先级越高.想在页面中使用CSS, 可以使用link去使用CSS&lt;link rel=stylesheet href="./style.css"&gt;
当我们把Selector选择成html, 则表示我们选择的是网页端根元素 - 这么修改完以后, 所有的元素默认的格式都会是这个rule的body	element.style{ font-size: 24px; font-weight:700; font-family:"字体名"; font-style:italic; text-decoration:underline; text-align: justify; color: blue; }
#alert {color : #a0111f;}
#alert {color : navy;}
如果想给物体加上边框, 则我们需要定义三个属性: 边框粗细, 边框样式, 边框颜色.feature{ border: 5px, solid, #000000; border-radius: 3px;
} .feature{ border-top: 1px, dotted, #000000;
} .feature{ border-left: 1px, dashed, #000000;
} .feature{ border-top-width: 1px; border-top-style: solid; border-top-color: #000000;
} .feature{ border-width: 10px, 0, 10px, 0; //上左下右的边框宽度 }
]]></description><link>cs3550/html.html</link><guid isPermaLink="false">CS3550/HTML.md</guid><pubDate>Mon, 08 Dec 2025 02:05:50 GMT</pubDate></item><item><title><![CDATA[Final Stuffs]]></title><description><![CDATA[module test: def posn_t_class: values(#'Posn, classT(#'Object, [values(#'x, intT()), values(#'y, intT())], [values(#'mdist, methodT(intT(), intT(), plusI(getI(thisI(), #'x), getI(thisI(), #'y)))), values(#'addDist, methodT(objT(#'Posn), intT(), plusI(sendI(thisI(), #'mdist, intI(0)), sendI(argI(), #'mdist, intI(0)))))])) def posn3D_t_class: values(#'Posn3D, classT(#'Posn, [values(#'z, intT())], [values(#'mdist, methodT(intT(), intT(), plusI(getI(thisI(), #'z), superI(#'mdist, argI()))))]))
这段代码是在定义用于测试的类数据结构。它手动构造了两个类的定义：Posn（二维点）和 Posn3D（三维点），并模拟了继承关系。为了让你完全理解，我们需要把这段代码拆解成几个层面：语言层面（values）、类型定义层面（classT） 和 表达式层面（plusI, getI 等）。以下是详细的逐行拆解：
来源：这不是这几个文件里定义的函数，而是 Shplait（以及 Racket）语言自带的基础功能。 作用：它用于创建一个元组（Tuple）或者说一个“对子”。 在这里的意义： 在 typed_class.rhm 的类型检查器设计中，类列表的类型被定义为 Listof(Symbol * ClassT) 1。 这意味着列表里的每一项必须是一个 (类名, 类定义) 的组合。 所以 values(#'Posn, classT(...)) 的意思就是：把符号 #'Posn（名字）和后面那一长串 classT（内容）打包在一起。 这是一个定义二维点 Posn 的结构。代码段values(#'Posn, // 类名 classT(#'Object, // 1. 父类名 (super_name) // 2. 字段列表 (fields) [values(#'x, intT()), values(#'y, intT())], // 3. 方法列表 (methods) [values(#'mdist, ...), values(#'addDist, ...)])) classT2: 来自 typed_class.rhm。它是一个构造函数，用来存储类的三个核心信息： 父类：这里是 #'Object，表示它是顶层类。
字段：这里定义了两个字段 x 和 y。注意 intT() 3 表示它们的类型是整数。
方法：这里定义了两个方法 mdist 和 addDist。 代码段values(#'mdist, methodT(intT(), intT(), // 参数类型 int, 返回类型 int plusI(getI(thisI(), #'x), getI(thisI(), #'y)))) methodT4: 定义方法的签名和体。 arg_type: intT()（虽然这个方法其实不用参数，但为了类型系统统一，通常会占位）。 result_type: intT()（返回整数）。 plusI5: 来自 inherit.rhm，表示加法表达式。 getI(thisI(), #'x)6: thisI()7: 表示当前对象（this）。 getI(..., #'x): 表示访问对象的字段 x（即 this.x）。 整体逻辑：this.x + this.y。 代码段values(#'addDist, methodT(objT(#'Posn), intT(), // 参数是 Posn 对象, 返回 int plusI(sendI(thisI(), #'mdist, intI(0)), sendI(argI(), #'mdist, intI(0))))) 参数类型：objT(#'Posn) 8。这表示这个方法接收一个 Posn 类型的对象作为参数。 sendI 9: 来自 inherit.rhm，表示方法调用。 sendI(thisI(), #'mdist, intI(0)) 意思是：调用自己的 mdist 方法，参数是 0。 argI() 10: 来自 inherit.rhm，表示获取传入的参数。 sendI(argI(), #'mdist, intI(0)) 意思是：调用传入参数（那个 Posn 对象）的 mdist 方法。 整体逻辑：this.mdist(0) + arg.mdist(0)。 这是一个定义三维点 Posn3D 的结构，它继承自 Posn。代码段values(#'Posn3D, classT(#'Posn, // &lt;--- 注意这里！父类是 Posn [values(#'z, intT())], // 新增字段 z [values(#'mdist, ...)])) // 重写方法 mdist 父类：#'Posn。这意味着它自动拥有 x 和 y 字段，以及 Posn 的所有方法（除非重写）。 字段：只定义了 z，因为 x 和 y 是继承来的。 代码段methodT(intT(), intT(), plusI(getI(thisI(), #'z), // this.z superI(#'mdist, argI()))) // super.mdist(arg)
这里展示了最关键的继承特性：
superI11: 来自 inherit.rhm。 它的作用是调用父类的方法。 superI(#'mdist, argI()) 意思是：调用 Posn 类里定义的 mdist 方法（即计算 x+y）。 整体逻辑：this.z + super.mdist()。 代入父类逻辑，结果就是 z + (x + y)，完美实现了三维曼哈顿距离计算。 ]]></description><link>cs3520/final-stuffs.html</link><guid isPermaLink="false">CS3520/Final Stuffs.md</guid><pubDate>Tue, 02 Dec 2025 01:09:52 GMT</pubDate></item><item><title><![CDATA[部署]]></title><description><![CDATA[现在, 我们要从设计网页移动到部署网页了, 好耶!首先, 我们需要了解URL:https://www.google.com/search?q=url
~~~~~ ~~~~~~~~~~~~~~~ ~~~~~~ ~~~~~
Protocol Hostname Path query
URL全称是Universal Resource Locator. Universal表示的是我们可以通过URL找到任意的资源, 如图片, 视频, 或者单纯的二进制格式文件
Locator就是描述你需要在哪得到这个文件
在HTTP协议中, 我们在访问网页的时候, 首先发送Get Request, 这样服务器才知道应该发送资源给我们GET / HTTP/2
Host: xxx.com
User-Agent xxx
Accept: */*
但发送了请求, 互联网还需要知道怎么把这个请求发送到服务器上.
由于我们只知道网页URL的名称, 所以我们需要通过DNS服务从名称映射到IP地址.
有了IP地址, 互联网终于知道应该往哪发送了.traceroute 123.456.789.1
通过上面的命令, 我们可以去查看, 如果从本机出发, 要把数据发送给目标服务器, 需要经过几次中转所以, 我们就需要去注册DNS服务, 让他们知道: 这个名称应该映射到这个IP地址上
我们可以买二级域名, 甚至Root Domain: 如整个.com或者.aws
当我们有了一个域名, 我们就有权利在这个域名上添加DNS Record了: 如这个域名绑定的是什么IPV4和IPV6地址, 和网站的信息, 联系人等在租赁服务器后, 实际上上架会把你分配到一个大服务器上. 这个大服务器的CPU可能是96核的, 当你租赁8核CPU后, 则会占用这个服务器8核的性能亚马逊还有T级服务器: 它是一种非常便宜的服务器, 且适合用来部署网页程序 - 大部分时候开销不大, 但偶尔会有高爆发的性能需求.
在正常情况下, 服务器只会使用10%原本的资源, 只有在需要的时候会把CPU的性能提高(On-Demand模式), 并收取费用
如t3.micro服务器, 如果是On Demand模式, 大约是每小时会消耗0.005美元. 当然, 大企业肯定不可能用这种服务器, 会需要高性能服务器.
对于选择服务器, 我们需要考虑用户的数量, 用户的位置, 和用户的种类. 点餐APP上用户可能每天只有两小时真正在使用程序
金融软件可能整个工作时间都持续有需求
很多时候, 用户都会选择亚马逊的C5种类服务器 - 这种服务器就不像上面那样先只给你10%的性能, 而是直接给你100%的性能, 持续运行.
如c5.xlarge大约每秒能处理600个请求, 每月的开销大约是120$我们可以用Locust来对服务器进行测压: 来模拟用户使用, 然后来测出当前这个服务器每秒能处理多少请求当用户访问频率越来越高, 服务器延迟也会越来越高.
具体可以用下面这个公式算出来: 比如如果服务器每秒可以处理200 requests, 现在每秒有100 requests. 则我们的 得到的Amplification Factor = 1. 则说明我们原本服务器本来有50ms的延迟, 现在就变成了100ms简而言之, 当请求数量越来越接近极限值, 延迟会开始飞速增长. 为了缓解这个, 最简单的方法就是降低RPS, 让他没有那么接近极限值就行. 通常我们把最大占用设置在大约70%左右, 延迟不会有很明显的延迟增加在实际中(如AWS), 我们会租一个服务器集群, 然后把服务器设置在Load Balancer, 这样如果当用户很多的时候, AWS会自动启动新的服务器, 然后Load Balancer会把一部分用户分配到那个服务器上.而且, 在发布的时候, 需要设置比以往更高的服务器额度 - 不然可能导致Congestion Collapse - 因为当延迟足够高, 用户会自动得到Time out error, 然后他们就会重复发送请求, 导致出现更多的请求.]]></description><link>cs3550/部署.html</link><guid isPermaLink="false">CS3550/部署.md</guid><pubDate>Tue, 25 Nov 2025 17:31:31 GMT</pubDate></item><item><title><![CDATA[Pasted image 20251122201213]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251122201213.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251122201213.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251122201213.png</guid><pubDate>Sun, 23 Nov 2025 03:12:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Networking]]></title><description><![CDATA[要想让计算机互相沟通, 每个计算机需要一个地址
在计算机网络中就是IP Address一个计算机有不同的服务, 这是由端口决定的, 如80端口是HTTP服务, 22端口是ssh服务第一代流行的IP协议是IPV4, 一个IP地址是由4byte构成, 每个byte用.来相隔192.168.0.1
255.255.255.1
有些计算机可能拥有多个IP 地址当连接发生时, 会有Client和Server, 如访问网页, 我的浏览器就是Client, 那个网页的服务器就是Server
当访问一个网页时, 默认访问的端口就是80端口, 除非指定其他端口
端口的范围是0~64K目前为止, 大部分的网络协议都是TCP - Transmission Control Protocol
这个协议规避了很多<a data-tooltip-position="top" aria-label="CS4400/Networking > 网络的缺陷" data-href="CS4400/Networking#网络的缺陷" href="cs4400/networking.html#网络的缺陷_0" class="internal-link" target="_self" rel="noopener nofollow">网络的缺陷</a>
这个协议自身没有加密
这个协议是基于IP层来运行
那么它是怎么保证数据传输的可靠性呢?很大一部分是依赖于重传:
如果一个数据本来应该到达, 但并没有收到, Client会请求服务器重新发送.
并且, 如果一直失败, 则可能会直接关闭掉连接UDP - User Datagram Protocol 它几乎就是一个原始的互联网, 服务器发送完包以后, 就直接不管了.所以, 那些数据包可能发出去以后会丢包, 损坏, 或者顺序出错, 不过换来的好处就是更低的延迟Sockets就是最基础的互联网连接的抽象: 它封装了
local IP/port, remote IP/port
一些可以传输和接收数据的API
对于TCP Sockets, 我们就可以把它认为是会传输一段可靠, 连续的Bytes
对于UDP Sockets, 它就是一堆不可靠, 且没有顺序的Packets在UNIX中, 所有东西都是文件, 网络当然也是.<br>
我们会给Socket也分配一个<a data-tooltip-position="top" aria-label="OS > File I/O" data-href="OS#File I/O" href="cs4400/os.html#File I/O" class="internal-link" target="_self" rel="noopener nofollow">descriptor</a>, 是一个int对于TCP的Socket, 我们可以进行Read, write 和 close
还有一些额外的功能如connect, accept等对于一个服务器, 他会有一个循环来处理所有的连接
定义一个Socket
用Socket创建对应的一个TCP Listener - 这个Listener就是个特殊的Socket, 类似餐厅的接待员, 如果有客户端进行连接, 它就会创建一个新的Socket去接待客户
用这个Listener去接受一个新的TCP连接请求, 并且分配一个新的线程去处理这个请求
重复到步骤3 - 一个程序一般只会创建一个Listener
对于每个有连接的线程, 服务器会循环read和writeSocket的descriptor
当有一方想关闭连接, 他们就会写入一个EOF在Listener中, 如果另一方读到了这个EOF, 就会知道这个连接被关闭了下面就是一个TCP连接的例子:<br>
<img alt="Pasted image 20250402123857.png" src="cs4400/attachments/pasted-image-20250402123857.png" target="_self">如果Client 再发送一个message2, 则Server的Buffer就会有一个message2连接在message1之后
因为TCP发送的数据就是连续的一串byte, 所以对于接收方来说, 他们并不知道这两个消息是分两次发出的, 除非里面编码着提前规定的一些特殊符号表示来告诉服务器这是两次发送的消息就像pipe的fd一样, 当读取buffer中的数据以后, 这个数据就会从buffer中消失<br>
<img alt="Pasted image 20250402124501.png" src="cs4400/attachments/pasted-image-20250402124501.png" target="_self"><br>
<img alt="Pasted image 20250402124532.png" src="cs4400/attachments/pasted-image-20250402124532.png" target="_self">但如果服务器尝试读取buffer中没有的那么多的byte, 它会返回最大能读取的Byte的数量
如读取10个bytes, 但只有3bytes, 就会只读取3bytes
但如果读取10bytes, 但buffer中一个byte都没有, 就会阻塞线程在本节课中, 会提供一个rio的类, 它是read和write的封装, 它可以安全地读取到特定的字符如\n#include “csapp.h” void Rio_readinitb(rio_t *rp, int fd); // Example
socket = accept(...); rio_t rio; Rio_readinitb(&amp;rio, socket); void Rio_readinitb(rio_t *rp, int fd);
如读取一行数据#include “csapp.h” ssize_t Rio_readlineb(rio_t *rp, void *buf, size_t maxlen); // Example
Rio_readinitb(&amp;rio, socket); char line[80]; Rio_readlineb(&amp;rio, line, 80);
或者读取特定长度的字符#include “csapp.h” ssize_t Rio_readnb(rio_t *rp, void *buf, size_t n); Rio_readinitb(&amp;rio, socket); size_t val_to_read; Rio_readnb(&amp;rio, &amp;val_to_read, 8);
#include &lt;sys/socket.h&gt; int socket(int domain, int type, int protocol);
<br><img alt="Pasted image 20250402123019.png" src="cs4400/attachments/pasted-image-20250402123019.png" target="_self">有了这个Socket, 我们就需要把它绑定到一个地址和端口#include &lt;sys/socket.h&gt; int bind(int socket, struct sockaddr* addr, socklen_t addr_len); Return value is 0 for success or -1 for error addr contains information about this machine’s address, and which port to open addr_len is needed because addr has variable size Use getaddrinfo to fill in addr
#include &lt;sys/types.h&gt; #include &lt;sys/socket.h&gt; #include &lt;netdb.h&gt; int getaddrinfo(const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **res);
最后的res参数也是一个返回: 它是指针的指针, 执行完这个函数, 这个指针指向的数据(addrinfo)会是一个新的还有一些会用得上的函数:int listen(int socket, int backlog); int accept(int socket, struct sockaddr *addr, socklen_t *addr_len); int connect(int socket, struct sockaddr *addr, socklen_t addr_len);
在CSAPP中, 已经帮我们创建了一些Class来简化这些过程:<br>
<img alt="Pasted image 20250402123556.png" src="cs4400/attachments/pasted-image-20250402123556.png" target="_self">对于写的服务器, 我们需要保证它可以同时服务多个用户:<br>
<img alt="Pasted image 20250402125834.png" src="cs4400/attachments/pasted-image-20250402125834.png" target="_self">但是呢, 这样会导致一些问题: 因为fork是创建一个新的线程, 但线程之间是相互独立的但对于服务器来说, 我们可能想让多个fork出来的线程互相通信, 一种方法是可以用mmap, 把同一块空间映射到一起, 这样fork后就可以互相沟通
虽然这样, 但在效率上仍然不够高.为了解决这个问题, 我们可以用多线程而不是Process.<br>在传输数据的时候, 我们需要加<a data-tooltip-position="top" aria-label="多线程 > Semaphore" data-href="多线程#Semaphore" href="cs4400/多线程.html#Semaphore" class="internal-link" target="_self" rel="noopener nofollow">锁</a>// 对于生产信息的
P(empty); // 等待缓冲区有空位
P(pmut); // 加锁缓冲区（互斥）
buf[nextin] = item; // 写入数据
nextin++; nextin %= BSIZE; // 环形缓冲
V(pmut); // 解锁缓冲区
V(occupied); // 通知消费者：有数据了 //对于接受信息的线程
P(occupied); // 等待缓冲区有数据
P(cmut); // 加锁缓冲区（互斥）
item = buf[nextout]; // 读取数据
nextout++;
nextout %= BSIZE; // 环形缓冲
V(cmut); // 解锁缓冲区
V(empty); // 通知生产者：有空位了
// consume item
每个包都是一小块数据, 通常小于1.5KB
可以把整个互联网认为是一个Packet交换网络, 因为传输数据就是路由器把一堆包从一个机器传输到另一个机器
(CS4480会讨论更多)网络几乎时刻都处于可能失败的状态:
可能会产生丢包
包的数据可能出错
包的顺序可能被打乱
基于网络环境的好坏, 这些事情可能从偶尔发生到一直发生.url的格式通常是scheme://host:port/path?query
Path原本是用来访问服务器里不同的文件夹的, 但实际上怎么解读都是由服务器来决定
Query是一些查询语法如果在里面出现了一些特殊符号如&amp;, 它则我们可以用%26来编码它, 因为&amp;在ASCII中是26当我们尝试连接一个服务器时, 服务器会使用Socket来接受这个连接, 然后用户的浏览器会发送:GET/HTTP/1.1
这样, 服务器才知道客户端使用的是HTTP协议, 然后服务器再发送HTTP/1.1 200 OK + Content
就可以把内容发送给客户端.当然, 首先发送的内容是HTTP Header: 里面包含了我们会发送什么内容, 并且是什么种类的编码:text/htlm; charset=UTF-8
对于客户端, 他们通常由两种操作: GET和POST, 是下载和上传, 前者的数量远远比后者要多HTTPS是更安全的HTTP, 它提供了一个更安全的从客户端到服务器的连接, 只不过服务器的端口变成了443端口.]]></description><link>cs4400/networking.html</link><guid isPermaLink="false">CS4400/Networking.md</guid><pubDate>Tue, 18 Nov 2025 16:13:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251116010811]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251116010811.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251116010811.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251116010811.png</guid><pubDate>Sun, 16 Nov 2025 08:08:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251116010805]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251116010805.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251116010805.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251116010805.png</guid><pubDate>Sun, 16 Nov 2025 08:08:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251116010758]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251116010758.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251116010758.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251116010758.png</guid><pubDate>Sun, 16 Nov 2025 08:07:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251116004211]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251116004211.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251116004211.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251116004211.png</guid><pubDate>Sun, 16 Nov 2025 07:42:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251115235935]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251115235935.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251115235935.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251115235935.png</guid><pubDate>Sun, 16 Nov 2025 06:59:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251115234816]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251115234816.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251115234816.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251115234816.png</guid><pubDate>Sun, 16 Nov 2025 06:48:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251115234536]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251115234536.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251115234536.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251115234536.png</guid><pubDate>Sun, 16 Nov 2025 06:45:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251115222021]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251115222021.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251115222021.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251115222021.png</guid><pubDate>Sun, 16 Nov 2025 05:20:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251115150807]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251115150807.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251115150807.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251115150807.png</guid><pubDate>Sat, 15 Nov 2025 22:08:07 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251115145159]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251115145159.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251115145159.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251115145159.png</guid><pubDate>Sat, 15 Nov 2025 21:51:59 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251111091934]]></title><description><![CDATA[<img src="cs3550/attachments/pasted-image-20251111091934.png" target="_self">]]></description><link>cs3550/attachments/pasted-image-20251111091934.html</link><guid isPermaLink="false">CS3550/attachments/Pasted image 20251111091934.png</guid><pubDate>Tue, 11 Nov 2025 16:19:34 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251111091834]]></title><description><![CDATA[<img src="cs3550/attachments/pasted-image-20251111091834.png" target="_self">]]></description><link>cs3550/attachments/pasted-image-20251111091834.html</link><guid isPermaLink="false">CS3550/attachments/Pasted image 20251111091834.png</guid><pubDate>Tue, 11 Nov 2025 16:18:34 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251109231226]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251109231226.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251109231226.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251109231226.png</guid><pubDate>Mon, 10 Nov 2025 06:12:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251109212244]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251109212244.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251109212244.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251109212244.png</guid><pubDate>Mon, 10 Nov 2025 04:22:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251105231204]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251105231204.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251105231204.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251105231204.png</guid><pubDate>Thu, 06 Nov 2025 06:12:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251101133725]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251101133725.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251101133725.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251101133725.png</guid><pubDate>Sat, 01 Nov 2025 19:37:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251101133541]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251101133541.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251101133541.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251101133541.png</guid><pubDate>Sat, 01 Nov 2025 19:35:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Forms]]></title><description><![CDATA[目前为止, 我们已经能做简单的网页了. 但问题是, 我们只能让用户浏览他们, 他们无法交互网页 - 如提交数据.最经典的就是Form - 用户可以输入数据进来, 当点击提交后, 会把这些数据发送到服务器上.Form有两个重要的属性action和method.
写在action中的通常是个url, 告诉浏览器搜索的网址是哪个
写在method中的可以是GET, 告诉浏览器用户想搜索某个东西, 也可以是POST, 也就是告诉浏览器用户想要修改某个数据
区分GET和POST的简单方法就是GET可以无限制地请求. 而POST每次请求都会带来影响
这点在刷新的时候很重要: 因为当刷新后, POST和GET都会重新发送, 对于POST可能导致问题 enctype则是一种可以上传文件的方法
当然, Form里需要有输入框.&lt;form method = "get" action="/search/"&gt; &lt;label&gt;Color &lt;input name="color" value="default_color" type="text"&gt; &lt;/input&gt; &lt;/label&gt; &lt;button&gt;Search&lt;/button&gt;
&lt;/form&gt;
在input中的name属性就像是变量名一样, 在用户提交表格的时候, 颜色属性就会存在color的变量中.
具体就是当用户点击后, 浏览器就会转跳到https://xxx/search/?color=default_color
具体可以在浏览器的payload中看到如果Form中有多个input的话, 则会在链接中用&amp;把每个属性连接起来<img alt="Pasted image 20251014122238.png" src="cs3550/attachments/pasted-image-20251014122238.png" target="_self"><br><a data-tooltip-position="top" aria-label="https://zhuanlan.zhihu.com/p/19753992717" rel="noopener nofollow" class="external-link is-unresolved" href="https://zhuanlan.zhihu.com/p/19753992717" target="_self">更多关于GET和POST的关系</a>当然, 既然form会请求/search/网页, 那么我们也就需要在Django中的views.py中设置对应的网页. def search(request): if request.method == "GET": age = int(request.GET.get("age")) age_is_min = request.GET.get("agetype", "min") == "min" q = Cat.objects.all() if age_is_min: q = q.filter(age__gte=age) else: q = q.filter(age__lte=age) return render(request, "cats.html", { "cats": q }) return render(request, "search.html", {})
对于Post, 也可以获得里面的数据, 我们就可以拿那些数据用来修改数据库(记得保存)def donate(request): if request.method == "POST": name = request.POST.get("name", "[Unnamed]") weight = float(request.POST.get("weight", "0.0")) spayed_neutered = "sn" in request.POST cat = Cat(name=name, weight_lbs=weight) cat.health = HealthRecord(spayed_neutered=spayed_neutered) cat.health.save() cat.save() #由于刷新后会重新提交, 我们需要让用户转跳到新的页面避免重新提交数据 #这个redirect会转化为一个get请求 return redirect("/cat/" + str(cat.id)) #如果直接return render, 则(可能)修改渲染内容,但仍然停留在当前页面.但如果redirect,则会强制转跳到另外的网址,避免重新提交 return render(request, "donate.html", {})
并且, 我们还可以批量添加数据models.Entry.objects.bulk_create([Entry(…), Entry(…), …]) models.Entry.objects.bulk_update(entries, [“field1”, “field2”, …]) models.Entry.objects.in_bulk([23, 157, 159, 207])[23]
不仅仅我们需要写提交表格的代码, 我们还需要渲染出表格: 这样如果用户输错数据, 我们可以重新展示出来表格让用户输入我们会在view.py中有一个add_form的方法. 会同时处理GET和POST请求. 当用户刚开始填表的时候, 会发送GET请求, add_form方法就会返回一个render的add_form.html来让用户填写
当用户填写完后, 会发送POST请求, add_form同样会去处理这个POST. 如果数据验证成功, 我们就会让浏览器重定向, 这样防止二次提交
如果数据验证失败, 我们就会重新返回这个render的add_form.html, 并且带着错误原因
这样, 我们在view.py中处理用户表格时发现问题后, 就可以重新渲染add_form.html, 并把错误原因作为参数传给html template.当然, 我们需要验证数据.
不仅仅是单纯的检查数据在某个范围, 我们还需要检查数据类型 - 因为用户很容易就可以把输入类型改成其他的, 如把数字改成颜色. 这样的话, 如果我们默认这个数据是数字, 直接转换类型的话, 就会导致报错.try weight = float(weight)
except error.append("type error")
并且, 在创建Field的时候, 可以附加validators参数, 参数是一个list的函数
这样在对象创建后, 我们可以调用这个对象的clean方法去执行validator中的函数去验证数据是否正确. 或者我们可以调用Django的full_clean方法, 如cat.full_clean()- 它会执行所有的clean方法但问题是, 服务器端验证会导致只有在提交表格后, 才能知道表格内容的问题
如果表格非常长, 就会导致用户可能会已经忘记之前填的是什么了. 我们可以在用户填写的时候, 同时在客户端进行验证
永远不能直接相信用户的数据! 最终必须进行服务器验证
我们可以在所有的input的元素中附上以下元素并且, 在CSS中, 我们还可以检索非法输入等input:invalid{border: red}
input:valid{border: green} input:required{}
input:optional{}
]]></description><link>cs3550/forms.html</link><guid isPermaLink="false">CS3550/Forms.md</guid><pubDate>Thu, 30 Oct 2025 23:08:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Identity and Permissions]]></title><description><![CDATA[Authenticate 表示的是去验证用户的身份
Authorize 表示当验证后, 才能授权用户进行操作我们可以把操作改成修改和浏览, 并把每种用户能做的操作都写下来 - 这种叫做Security Policy 所有用户可以浏览作业
学生可以浏览或提交作业
教授可以修改作业或给作业打分
TA可以给作业打分
服务器每秒都可能在处理成千上万个请求, 记住哪个请求是哪个用户也是一种挑战.
并且, 服务器并不能仅靠一些传输过来的数据, 来直接相信客户端的信息.我们可以借鉴证件照的方法: 机构给个人发放证件照, 当机构需要验证个人的身份的时候, 个人会把证件还给机构
在网络中也是一样: 通常服务器会给用户一个个人信息数据 - Cookie.这样, 通过服务器给的Cookie, 用户就进入了一个Session: 用同一个Cookie获取的所有数据都在一个Session中.Session就是一种在服务器上储存用户特定数据的机制. Session数据都存在服务器, 而用户的浏览器上只会存在一个Cookie, 里面有Session id, 这样在访问网页的时候, 服务器就可以从Cookie得到对应的Sessionclass AbstractBaseSession(models.Model): session_key = models.CharField(max_length=40, primary_key=True) session_data = models.TextField() expire_date = models.DateTimeField(db_index=True)
其中的session_key就表示的是Cookie的值&gt;&gt;&gt; SessionStore().decode(s.session_data) {'_auth_user_id': '1', #ID of currently-logged-in user
'_auth_user_backend': ‘django.contrib.auth.backends.ModelBackend', '_auth_user_hash': ‘...’} #Used for changing passwords
当用户登录后, 就会在Django的DB里的django_session表中存储用户的信息, 如Cookie id, 值等authenticate(request, username, password) #会返回一个User对象或者None, 并没有对Session进行影响 login(request, user) #把用户当前的Session记作登录状态, 需要传入User
#当login后, 后面用户的请求函数中的request.user都会有用户信息 logout(request) #把用户退出登录
&lt;form method="post" action="/login"&gt; {%csrf_token%} &lt;label&gt; Username &lt;input name="user"&gt;&lt;/label&gt; &lt;label&gt; Password &lt;input name="password" type="password"&gt;&lt;/label&gt; &lt;button&gt;Login&lt;/button&gt;
&lt;/form&gt;
在原本的提交表单后, 我们会直接转跳页面到主页但在登录的时候, 这样可能会很烦: 因为用户通常登录是为了干某件事情, 而登录后转跳到主页可不好所以, 我们可以在网页转跳到登录页面的时候附上一个参数: /login?next=/donate
这样, 当我们在get登录网页的时候, 我们就会知道用户下一步想回去哪了if request="GET" next = request.GET.get("next","/")
并且, 我们得到这个值后, 需要把它放到表单中, 这样在Post的时候, 用户会把它发送给服务器. 不然光在GET的时候知道是不够的.Django不仅仅提供了Authentication, 还提供了Authorization的服务.我们可以通过request.user.is_anonymous来知道用户是否登录了not_allowed = request.user.is_anonymous #还可以检测是否在某个组里
is_group = request.user.groups.filter("name") if not_allowed: return redirect("/")
elif not is_group: raise PermissionDenied()
或者, 我们可以做出一个函数, 它的参数是user, 会返回一个bool. 并且把这个函数传入@user_passes_test 中. 这个当函数返回false的时候, 会直接返回到login页 (这个login是Django默认的登录页). 就算用户登录了, 但不满足要求, 页会被转跳到登录页.def user_is_staff(user): return request.user.groups.filter("staff") @user_passes_test(user_is_staff)
def donate(request): xxxxxxxxxx
这样做的好处就是, 如果我们在每个网页都写独立的验证, 非常容易出错, 把所有验证聚在一起, 才是最好的选择. 比如创建一些验证的函数如can_view(user), can_edit(user)等, 并把他们放在models.py中或者独立的文件中]]></description><link>cs3550/identity-and-permissions.html</link><guid isPermaLink="false">CS3550/Identity and Permissions.md</guid><pubDate>Thu, 30 Oct 2025 04:41:42 GMT</pubDate></item><item><title><![CDATA[各种各样的攻击]]></title><description><![CDATA[Django帮我们防御了很多网络攻击方法在提交表单的时候, 浏览器只是单纯收集表单中的各种数据, 并转成字典结构传给服务器罢了那么, 要是我们在我们自己的恶意网站上创建一个隐形的表格, 代替用户发送表单, 就构成了攻击: 我们可以替代用户发送给银行一个转账表单, 并且因为请求地址是银行, 所以用户的浏览器会自动附上Cookie 数据.如果银行没有任何保护措施, 它看到的就是正确的Cookie, 正确的数据等. 就直接转账了.这就是为什么在Django中要在每个form中加入{%csrf_token%}了 - 我们可以避免这种问题, 因为我们只会在用户本人登录表单页面时, 才会给一个token, 在用户提交的时候检查确保提交的token和下发的时同一个我们还会遇到有人在表单中上传代码: 比如名字是&lt;!--, 如果直接把这个传入到网页中, 只要有这个名字的网页都会导致网页后面被注释掉. 幸运的是, Django遇到这种输入, 虽然会把它原封不动的传入数据库中, 但在显示的时候, 会把它转义成&amp;lt;!--, 这样就可以正常显示, 并且不会影响到HTML
如果想避免转义, 我们会想在template的后面附上个|safe的连接符, 表示这个数据是安全的, 不需要escaping.这种避免输入的恶意代码执行的操作叫做escapingOpen Redirects通常指的是一系列的钓鱼攻击还记得我们在登录页面做了一个next的参数, 让用户可以在登录后转跳到特定的页面吗? 这个属性是可以被攻击者输入的.这种就是攻击者做出一个假的网站, 让用户以为他们在的是正确的网站, 实际上是在假的网站上填信息. 通常是让用户先在真实网站上填一遍信息, 不过会转跳到钓鱼网站上, 并显示错误的密码 - 这样用户极大可能重新输入一遍正确的密码, 并且不会检查网址. 在输入密码后会再次转跳到正版网页上.
最终就神不知鬼不觉的盗走了用户的用户和密码如果想要解决这种问题, 我们可以检查转跳的目的地, 如果是站外链接, 就直接拒绝]]></description><link>cs3550/各种各样的攻击.html</link><guid isPermaLink="false">CS3550/各种各样的攻击.md</guid><pubDate>Tue, 28 Oct 2025 16:33:28 GMT</pubDate></item><item><title><![CDATA[Machine Learning]]></title><description><![CDATA[监督式学习需要我们提供"Labels", 里面记录了每一个问题对应的答案.大致可以分为两类
Classification 输入一个输入, 会输出一个变化有限(离散的)的类别 Regression 输入一个输入, 会输出一个实数 对于这类学习, 我们只会输入问题, 但不会输入对应的答案大致也可以分为两类:
Clustering
Representation Learning 把一个输入的高维向量压缩成一个很小的向量但仍然可以还原出来, 如<a data-tooltip-position="top" aria-label="Self supervised model > Auto Encoder" data-href="Self supervised model#Auto Encoder" href="ml/self-supervised-model.html" class="internal-link" target="_self" rel="noopener nofollow">Auto Encoder</a> 这类就是我们课上的重点 - 我们有一个Agent和Environment. 我们可以让Agent做出Action, 并根据得到的新State和Reward做出回应线性分类器通过计算输入特征的加权和（称为“激活值”）来进行分类。激活值的计算公式为：
如果激活值大于一个阈值（通常是0），则分为一类（例如+1），否则分为另一类（例如-1）。这个过程可以看作是特征向量和权重向量的点积。感知器学习算法 (Perceptron Learning Algorithm)：
二元分类 (Binary Perceptron)：从零权重开始，对于每个训练样本，用当前的权重进行分类。如果分类正确，权重不变；如果分类错误，则根据错误类型更新权重向量，更新规则为： 其中是真实的标签。
多类分类 (Multiclass Perceptron)：为每个类别都设置一个权重向量。预测时，选择得分（激活值）最高的类别作为预测结果： 如果预测错误，则降低错误类别的分数（权重向量减去特征向量），并提高正确类别的分数（权重向量加上特征向量）： 感知器的问题 (Problems with the Perceptron)：
噪声：如果数据是线性不可分的，权重可能会持续波动，无法收敛。
泛化能力一般：它只能找到一个将数据“勉强”分开的解决方案。
过拟合 (Overtraining/Overfitting)：在训练集上表现越来越好，但在测试集上的准确率先升后降。
为了解决感知器的一些问题，并得到更平滑的、概率性的决策边界，这部分引入了逻辑回归。
S 型函数 (Sigmoid Function)：为了将感知器的得分（一个实数 ）转化为概率（0到1之间的值），可以使用 S 型函数（Sigmoid function）。当得分非常高时，概率趋近于1；当得分非常低时，概率趋近于0。其公式为： Softmax 函数：对于多类分类问题，可以使用 Softmax 函数将多个类别的得分转换成一个概率分布。每个类别的概率正比于其得分的指数，并进行归一化，确保所有概率之和为1。
多类逻辑回归 (Multiclass Logistic Regression)：将多类分类的得分通过 Softmax 函数转化为概率，然后通过最大化对数似然函数（log-likelihood）来学习最优的权重w。目标函数为： 其中，每个样本的概率由Softmax给出： 这部分讲解了如何求解逻辑回归等模型中的最优化问题，即如何找到最好的权重 w。 爬山法 (Hill Climbing)：这是一个通用的优化思想，即从一个随机点开始，不断地向“上坡”的方向移动，直到到达一个局部最高点。在连续空间中，由于邻居有无穷多个，直接使用爬山法很困难。 梯度上升 (Gradient Ascent)：这是一种在连续空间中进行优化的有效方法。 梯度 (Gradient)：梯度是一个向量，指向函数值增长最快的方向。对于一个多元函数，其梯度为： 算法思想：从一个初始点开始，重复地沿着梯度的方向移动一小步，从而不断地接近函数的最大值。每一步的更新公式为：w ← w + α * ∇g(w)，其中 α 是学习率（learning rate），∇g(w) 是梯度。
不同形式： 批量梯度上升 (Batch Gradient Ascent)：每次更新权重时，都计算所有训练样本的梯度之和。
随机梯度上升 (Stochastic Gradient Ascent)：每次更新时，只随机选择一个训练样本来计算梯度。
小批量梯度上升 (Mini-Batch Gradient Ascent)：这是介于两者之间的方法，每次更新时，随机选择一小部分（一个 mini-batch）的训练样本来计算梯度。 回归的目标是学习一个从输入x到连续值输出y的映射 - 不像分类那样只有固定的输出种类
线性回归 (Linear Regression): 预测值是输入特征的线性组合： 损失函数 (Loss Function): 通常使用均方误差(Mean Squared Error)来衡量预测的好坏： 优化 (Optimization): 通过梯度下降 (Gradient Descent) 来找到最小化损失函数的。更新规则为： 核心思想: 深度神经网络不仅使用特征，还能自动从原始数据中学习这些特征。这是通过将多个神经元层堆叠起来实现的。
结构: 一个深度网络由输入层、多个隐藏层和一个输出层构成。
每一层的神经元输出 是前一层所有神经元输出 的加权和，再通过一个非线性激活函数 得到的： 激活函数 (Activation Functions): 常见的非线性激活函数有Sigmoid, Tanh, 和 ReLU (Rectified Linear Unit)。
训练: 训练神经网络与逻辑回归类似，通过梯度上升/下降来优化目标函数。现代框架使用自动微分（也称反向传播）来高效计算庞大参数的梯度。
<br>我们通常在没有明确标注数据的场景下使用强化学习进行训练。这与我们之前学习的<a data-tooltip-position="top" aria-label="MDP > Bellman Equations" data-href="MDP#Bellman Equations" href="cs4300/mdp.html#Bellman Equations" class="internal-link" target="_self" rel="noopener nofollow">MDP</a>形成了鲜明对比。在标准的MDP问题中，我们通常假设自己是全知的，即我们完全了解环境的模型，包括状态转移概率 和奖励函数 。然而，在强化学习的设定中，我们面临一个更加现实和具有挑战性的情况：我们对环境的内部工作机制一无所知。我们不知道采取一个动作会以多大的概率去往哪个状态，也不知道会获得多少奖励。智能体（agent）必须像一个在未知世界中探索的探险家，通过亲身实践来学习。这个过程被称为在线学习（Online Learning），智能体必须在真实世界中执行动作并观察结果，而不是在已知的模型中进行离线规划（Offline Planning）。简单来说，我们不再拥有一个固定的模型来预测环境的变化，我们能依赖的只有通过一次次试验得到的样本（samples），并从这些样本中推断出每个事件发生的概率和对应的奖励。对于处理这类基于样本的学习问题，我们首先能想到的方法就是经典的蒙特卡洛方法。蒙特卡洛评估（在讲义中被称为直接评估）是一种非常直观的策略评估方法。其核心思想是：要评估一个固定策略 的好坏，我们就让智能体严格遵守这个策略从头到尾地完整执行任务，一遍又一遍。每一次完整的执行过程（从开始到结束）被称为一个回合（episode）。在每一个回合中，每当智能体访问到一个状态 s 时，我们就记录下从那个时刻开始，直到回合结束，它所获得的所有折扣奖励的总和。当收集了足够多的回合数据后，我们只需将每个状态 s 记录到的所有总回报值进行简单平均，这个平均值就是我们对该状态期望价值 的估计。虽然蒙特卡洛方法简单易懂，但它存在一些显著的缺点：
浪费信息：它完全忽略了状态之间的内在联系。例如，如果状态B和状态E在策略 下都会转移到状态C，理论上它们的价值应该存在某种关联，但蒙特卡洛方法却将它们完全独立地学习。
学习效率低下：由于每个状态的价值都是分开学习的，该方法需要大量的完整回合样本才能获得较为准确的估计，因此学习过程可能非常漫长。
为了解决这些问题，研究者们提出了时间差分学习。时间差分（TD）学习是一种更为高效的无模型强化学习方法，它的核心思想是从不完整的经验中学习，并且 “边走边学”。与蒙特卡洛方法需要等到整个回合结束后才进行一次“总结汇报”不同，TD学习在智能体每执行一步之后，就会进行一次价值更新。这个方法的巨大优势在于它充分利用了环境的马尔科夫性质。在完成一次转移（从状态 s 采取动作 a，得到奖励 r，到达新状态 s'）后，TD学习会立即使用新状态 s' 的当前价值估计来更新旧状态 s 的价值，这个过程被称为自举（Bootstrapping）。具体的更新过程如下：
首先，我们根据刚发生的转移 计算出一个临时的、更可靠的目标价值，在讲义中称之为 sample。这个值由即时奖励 r 和后继状态的折扣价值估计 组成： 然后，我们并不直接用这个 sample 值覆盖掉旧的价值，而是采用一种指数移动平均（Exponential Moving Average） 的方式，让旧的价值估计 朝着 sample 的方向移动一小步。更新公式为： 这里的 是学习率。这个公式也可以写成另一种形式，以便更清晰地看到其内在逻辑： 其中， 就是TD误差（TD Error），它代表了我们新的、基于单步真实观察的价值估计与旧的价值估计之间的“差异”或“意外”。TD学习的本质就是不断地减小这个TD误差。
TD学习完美地解决了策略评估（Policy Evaluation）的问题。但如果我们想从中学到最优策略，我们就会遇到一个障碍。要找到最优策略，我们需要为每个状态选择能带来最大期望回报的动作。这通常需要计算动作价值函数 Q(s,a)。如果我们只有状态价值函数 V(s)，我们仍然需要借助环境模型 T 和 R 才能计算出 Q(s,a)。然而，我们一开始就假设我们没有这个模型！为了解决这个“最后一公里”的问题，Q-Learning应运而生。<br>Q-Learning是一个巧妙而强大的算法，它将TD学习的思想直接应用到了动作价值函数<a data-tooltip-position="top" aria-label="MDP > MDP" data-href="MDP#MDP" href="cs4300/mdp.html#MDP" class="internal-link" target="_self" rel="noopener nofollow">Q(s,a)</a>上。这样一来，我们就可以在没有模型的情况下，直接学习每个“状态-动作”对的价值，从而轻松地找到最优策略。Q-Learning也被称为无模型、非策略（Model-Free, Off-Policy） 的TD算法。它的更新过程与TD学习非常相似：
当智能体完成一次转移 后。
我们计算Q值的目标 sample。但这次，我们不再关心固定策略下 s' 的价值，而是直接去估计在 s' 下所有可能动作中能得到的最大Q值。这体现了对最优策略的追求。 同样，我们使用移动平均的方式来更新Q值： Q-Learning最神奇的特性之一是它的非策略（Off-Policy） 性质。这意味着，即使智能体在学习过程中遵循的是一个次优的、甚至是随机的勘探策略，只要保证所有“状态-动作”对都被充分访问到，Q-Learning最终仍然能够收敛到最优的动作价值函数 。<br>
<img alt="Pasted image 20251017173822.png" src="cs4300/attachments/pasted-image-20251017173822.png" target="_self">
比如, 我们在这里有四个State, 其中A和D是Terminal State, 我们可以在ABCD上去计算Q值(也就是往左和往右得到的最终期望值).
在刚开始训练的时候, 会先把所有的Q设成0假设, 我们刚开始就在D, 然后往右走, 发现得到一分. 套在Q-Learning的公式中, 就是这里的Sample遵循着上面的公式. 因为D往右就是Terminal State了, 所以只有一个1, 没有后续值
接着, 我们第二次执行是在C往右走, 走到D, 获得0分由于C不是Terminal State了, 所以我们还需要计算sample的第二部分, 也就是到State D后, 可以得到的最大Reward是多少并乘上Discount.
只要跟着这种方法走下去, 并且探索的足够多, 最终一定会找到最优解.
但这就牵扯到另一个问题: 我们如何保证我们探索的方法很好? 最简单的一种方法是: 每次做选择时, 先产生一个概率
在极小的概率下, 我们会随机做出选择
在剩下的概率下, 我们会根据现在的Policy走
我们可以先让很大, 也就是刚开始很随机, 后面慢慢地跟着Policy走
还有一种是Boltzmann (softmax) exploration:
去看每个Action得到的期望值是多少
把所有的聚一起算Softmax
这样就是得分越高, 越有可能执行这个操作
Explore Function:
我们会更加希望探索没有探索过的区域
我们会使用Value Estimate 和访问对应State的次数来返回一个估计
比起之前的Q-update, 我们会套上这个函数:. 其中是指访问对应State的次数
这样, 如果很高, 则如果很小的时候, 说明这个State访问的次数很少, 对应就会算出来比正常要高的预估(类似加个bonus), 就会让AI更有可能探索那个地方
很多时候, 可能有无穷无尽的State, 我们肯定不想让AI把这些都学一遍 - 我们想让他有泛化的能力: 至少看到一个类似的State, 可以知道干什么我们可以用Feature在某种意义上解决这个问题: 比如吃豆人: 我们不会把一个State定义为玩家在哪, 豆子在哪, 鬼在哪. 而是定义: 玩家离豆子有多远, 离鬼有多远...我们可以定义一系列的Feature, 然后把他们加一起. 当然, 单纯加一起还不够, 我们可以给每个Feature加上对应的权重 - 就像机器学习一样!<br>
<img alt="Pasted image 20251017230621.png" src="cs4300/attachments/pasted-image-20251017230621.png" target="_self"><br>
<img alt="Pasted image 20251017230920.png" src="cs4300/attachments/pasted-image-20251017230920.png" target="_self">我们的RL的终极目标还是为了找到一个最优的Policy。
在之前的各种方法, 都是为了找到一个稳定(准确)的Q值, 然后直接一直选择Q值最高的选择就可以得到最优解了。但我们实际上可以直接去学最优的Policy是什么, 而不是去先算Q值再用Q去得到Policy。
Q-Learning的局限: Q-Learning的目标是让Q-values尽可能准确 (Modeling)。但对于选择动作而言, 我们其实只需要保证Q-values的 排序 是正确的 (Prediction)。
策略的直接性: 很多时候, 能赢得游戏的策略 (Policy) 所对应的V值或Q值函数, 反而不是那个最接近真实V/Q值的函数。
解决方案: 我们可以直接学习一个最大化奖励的策略 (Policy), 而不是去学习一个预测奖励的值 (Value)。
我们的策略 (Policy) 是一个带参数 的函数 (例如, 可以是神经网络的权重)。 我们的目标是找到一组参数 , 使其最大化期望回报 (Expected Return)。
Trajectory (轨迹) : 一个轨迹是指一个完整的状态-动作序列: 。 Return (回报) : 一个轨迹的总回报。(为了数学简化, 我们暂时忽略折扣因子, 假设是有限步 T)。
。 Expected Return (期望回报) : 这是我们真正要最大化的目标。
它是在当前策略 下, 运行所有可能的轨迹 , 得到的平均回报。
。 优化方法: 梯度上升 (Gradient Ascent): 我们希望通过调整参数 来最大化 。
更新规则为: 。
核心问题: 如何计算这个梯度 ? 推导过程依赖于几个关键"事实": Fact 1: 轨迹的概率 一个轨迹发生的概率, 是所有决策点概率的乘积。
。
: 初始状态的概率。
: 环境的状态转移概率 (我们不知道)。
: 我们的策略 (我们控制的)。 Fact 2: Log-Probability (对数概率) 取Log可以把连乘 (product) 变成连加 (sum)。
。 Fact 3: Log-Prob 的梯度 我们对 求关于 的梯度。
关键: 初始状态 和环境转移 不依赖于我们的策略参数 。
因此, 它们的梯度为 0 - 不管Actor的策略是什么, 环境(如重力)是不会改变的
这非常重要! 这意味着我们不需要知道环境模型 (Transition Function) 是什么!。
。 Fact 4: Log-Derivative Trick (对数导数技巧) 这是一个微积分技巧, 来自于 。
。 整合推导: (展开期望) (梯度进入求和) (使用 Fact 4) (变回期望) (使用 Fact 3) 这就是 Policy Gradient Theorem, 也常被称为 REINFORCE 算法。 如何计算? 我们无法计算精确的期望 (E)。 我们使用采样 (Sampling) 的方法来估计它。
我们使用当前的策略 在环境中运行 N 次, 收集 N 个轨迹 (rollouts)。
然后计算这 N 个轨迹的平均值 (Sample Mean)。
。 直观理解: 是第 i 个轨迹的总回报。这是一个标量。 是一个向量, 它指向 "使动作 在状态 下更可能被选中" 的参数修改方向。
如果 是正的 (好回报): 我们就沿着这个方向更新 (梯度上升), 增加这条轨迹中所有 (s, a) 对的概率。
如果 是负的 (坏回报): 我们就沿着相反的方向更新 (梯度下降), 降低这条轨迹中所有 (s, a) 对的概率。
这就是一种试错学习 (Trial and Error)。 我们需要策略能做到两件事: 1. 采样动作 2. 计算 。
离散动作 (Discrete Actions): 使用一个神经网络, 输入状态 s, 输出每个动作的 "logits" (未归一化的值)。
通过一个 Softmax 函数, 将其转换为一个概率分布。(这就像一个分类器)。 连续动作 (Continuous Actions): 这是 Policy Gradient 的一大优势。(Q-Learning 无法在连续空间中取 max)。
让神经网络输出一个概率分布的参数, 例如高斯分布 (Gaussian)。
网络会输出一个均值 和一个标准差 。
我们从这个高斯分布 中采样一个动作 来执行。
探索 (Exploration): 探索被内嵌在策略的随机性中 (即标准差 )。 Pros (优点): 直接优化目标: 直接优化我们关心的总回报 。
支持连续动作空间: 可以自然地处理连续动作。
可学习随机策略: 探索是内置的, 策略本身就是随机的。 Cons (缺点): On-Policy (同策略): 这是最大的缺点。用 收集的数据, 只能用来计算这一次的梯度。
当策略更新到 后, 之前的所有采样数据都必须丢弃, 需要重新采样。
样本效率低 (Sample-inefficient)。
(相比之下, Q-Learning 是 Off-Policy, 可以重复使用旧数据 (Replay Buffer), 样本效率高)。 改进: REINFORCE 使用整个轨迹的回报 来评估 每一个 动作。
一个更好的方法是, 评估 时, 只使用它之后的回报 (Reward-to-go): 。 这能减少梯度方差 (variance)。
这个 "未来的回报" 其实就是 的估计。
这就引出了 Actor-Critic 方法: 结合了 Policy Gradient (Actor) 和 Value Function (Critic)。 <br><img alt="Pasted image 20251017181344.png" src="cs4300/attachments/pasted-image-20251017181344.png" target="_self">]]></description><link>cs4300/machine-learning.html</link><guid isPermaLink="false">CS4300/Machine Learning.md</guid><pubDate>Sat, 25 Oct 2025 07:14:36 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MDP]]></title><description><![CDATA[在之前, 我们学的BFS, DFS等都是基于决定性的Action来进行的Search - 也就是我们和对手做出的每个动作都是明确知道结果的对于对手不明确的情况, 我们会使用Expectimax. 然而如果我们连我们做出行为后, 得到的结果是什么都不知道(比如我们尝试往前走, 却实际上做出的行为是往左走), 我们就需要更高级的Search了: Markov Decision Process(MDPs)马尔科夫通常表示的是: 当我们已经知道current state, 则未来事件和过去事件为Conditional Independent除了MDP之外, 还有一些其他的马尔科夫的模型:
<img alt="Pasted image 20250909130609.png" src="cs4300/attachments/pasted-image-20250909130609.png" target="_self">在MDP中, 我们的目标就是找到一个规则, 这个规则告诉我们给定一个State, 我们应该执行什么Action从起点开始, 每走一步可能都会有Cost, 而不同的Cost导致的决策也会不一样:<br>
<img alt="Pasted image 20250909133019.png" src="cs4300/attachments/pasted-image-20250909133019.png" target="_self">并且, 很多时候, 开始的得分会比以后的得分要重要, 所以我们可以引入Discounting, 也就是走完第一步后得到的reward会乘上一个衰减因子, 然后第二步得到的reward乘上以此类推...但如果这个游戏没有Terminal State呢? 可以限制步数, 到第几步就强制结束了
可以用Discounting的方法,因为Discounting得到的Reward是个几何级数, 当几何级数的也就是这里的的时候, 则几何级数就是收敛的
<br><img alt="Pasted image 20250909125119.png" src="cs4300/attachments/pasted-image-20250909125119.png" target="_self"><br><img alt="Pasted image 20250913162152.png" src="cs4300/attachments/pasted-image-20250913162152.png" target="_self">
上图被圈起来的部分就是, 也就是当在状态做出决策的时候, 我们的期望是多少. 然而在这种问题中, 做出决策不代表一定能成功, 所以表示的就是做完决策后实际到达的状态对于我们处在的一个State, 我们可以这么表达期望:
表示的就是从状态 出发，采取最优策略能获得的期望回报（期望总奖励）
“如果我现在在状态，并且之后一直采取最优策略，我能期望得到多少回报？”
表示的是在状态下执行动作 ，得到即时奖励，然后从新状态出发继续遵循最优策略时的期望回报
如果我现在在状态，选择了动作，然后之后一直采取最优策略，我能期望得到多少回报？
我们可以认为, 也就是就是永远选择最终期望最高的action去走如果我们有一个固定的规则, 则我们可以这样表示期望:
表示的就是在当前这个状态, 一直遵循规则得到的最终分数
这里的表示的是随机到每个的概率
表示的是执行了这个action后立刻得到的奖励
表示的是未来的Discount后的Reward (而里又有下下个步骤的Discount Reward, 就像递归一样)在实际运算的时候, 我们也会从只剩0步开始 - 这时所有的Reward都是0, 然后把数带入进去后慢慢算就行<br><img alt="Pasted image 20250913180828.png" src="cs4300/attachments/pasted-image-20250913180828.png" target="_self">
比如在上面这个例子中, 我们就有三个状态, 然后三个状态的第零步都是0 Reward. 接下来我们就需要算每个State得到的最优解是什么. 比如Cool State的第一步, 如果是Slow, 则还是Slow, 但Reward是1. 如果是Fast, 则的概率变成Warm, 但平均后的Reward是2. 我们就会说我们这样计算每个分支的Value的操作就叫Value Iteration有时候, 我们不会遍历所有的可能性, 而是通过"Policy"来告诉我们选择什么Action. 我们把遵循Policy最终得到的Discounted Reward记作 这里的表示的就是Policy选择的Action然而Value Iteration是非常的慢的 - 需要大约的时间. 这不仅仅是因为分支的几何式增长, 还是因为很多运算都是没有太大意义的 - 因为值在最后会收敛, 所以越往后, 算出来的Value基本上就没什么意义了我们或许可以尝试Policy Iteration - 顾名思义, 也就是用Policy代替取max的操作. 首先我们先选出一个任意的Policy, 甚至可以是随机的Policy
计算这个Policy得到的, 也就是每个State遵循Policy能得到多少Reward
当然, 通过Policy得到的Reward并不是最优解, 所以我们需要优化
我们再通过Value Iteration的方法去进行计算, 有没有什么可以改进的地方 如果, 则说明更多的Iteration也带不来改变了, 我们可以结束循环, 否则返回步骤2
看起来有点困惑, 实际上我们之前干的跟这个有点像: 之前的Value Iteration就是当我们彻底遍历完了整个网络, 然后得到每个State的期望, 我们就可以知道往哪里走了. 我们得到的方向就是最终的Policy. 而现在, 我们是先有的Policy - 尽管不是最优解, 但我们可以先算出通过这个Policy, 每个State的期望, 然后再看看有没有什么能改进的地方, 如果有, 我们就得到了新的Policy 然后再用新的Policy来看有没有改进的地方在看有没有改进的地方的时候, 我们就会在每个state上做一个一层的Value iteration, 来查看所有可能性, 如果不遵循当前的Policy而是去其他的state, 是否会得到更高的value.蒙特卡洛(Monte Carlo)算法是用来采样不确定性的事件的一种算法.比如, 我们有两个骰子, 想知道投出7的概率是多少. 一种方法是计算概率. 然而如果骰子的概率不是平均的, 我们就很难计算出来了. 但我们投骰子的操作却很简单 - 所以我们就可以投大量的骰子, 最后数得到7的次数是多少, 除以总数就是投到7的概率. 在程序上, 我们可以这么抽象: 里面的一层就是每一步得到的Reward, 外面的一层Sum是因为我们做出一步的时候, 可能并不会成功, 所以还需要采样多次来平均结果.初始化: π &lt;- 要被计算的Policy V &lt;- 我们想要得到的State - Value Function Returns(s) &lt;- 一个空的list 死循环: 先用Policy π生成一系列的action和经过的State, 还有得到的Reward 计算出从第一个State开始,遵循π Policy后得到的Discounted Reward 把这个Discounted Reward存到list中, 我们的V就是list里所有值的平均
这样做的好处不仅仅是因为我们可能不知道每个State的Action对应的概率, 还可以解决如果State不是离散的问题]]></description><link>cs4300/mdp.html</link><guid isPermaLink="false">CS4300/MDP.md</guid><pubDate>Wed, 22 Oct 2025 00:01:31 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[TODO List]]></title><description><![CDATA[TODO list并不是指平常我们的待办清单, 而是我们现在要把我们的MOE语言重新修改一下, 让他遵循以下规则:
我们会显式地形容我们的执行顺序
如1+2, 我们会先interp 1, 然后再interp 2, 最后再把他们加起来.
这就是先执行interp 1, interp 2 和加法都是我们的待办事项
这样, 我们就需要一个额外的数据类型, 叫Cont, 这个表示的是continuous, 也就是我们下一步需要干什么, 并且还需要一个中转的函数continue, 来让两个步骤连一起def interp :: (Exp, Env)-&gt; Value: fun(a, env, k): match a: | intE(n) : continue(k, intV(n)) //这里的k就是plusSecondK | plusE(l,r) : interp(l, env, plusSecondK(r, env, k))
def continue :: (Cont, Value) -&gt; Value: fun(k, v): match k | doneK(): v | plusSecondK(r, env, next_k): interp(r, env, doPlusK(v, next_k)) | doPlusK(v_l, next_k): continue(next_k, num_plus(v_l, v))
type Cont
| doneK()
| doPlusK(v :: Value, next_step :: Cont)
| plusSecondK(right_side :: Exp, e :: Env)
所以步骤就是先interp 1, 然后会执行continue(plusSecondK('2', env, done()))
continue会interp 2, 并在interp的时候, k就是doPlus(intV(1), done()) - 表示我们已经解析完1了, 还剩右侧的2没有解析, 解析完会加一起, 加一起后就没有步骤了]]></description><link>cs3520/todo-list.html</link><guid isPermaLink="false">CS3520/TODO List.md</guid><pubDate>Mon, 20 Oct 2025 18:18:06 GMT</pubDate></item><item><title><![CDATA[Pasted image 20251017230920]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251017230920.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251017230920.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251017230920.png</guid><pubDate>Sat, 18 Oct 2025 05:09:20 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251017230621]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251017230621.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251017230621.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251017230621.png</guid><pubDate>Sat, 18 Oct 2025 05:06:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251017181344]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251017181344.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251017181344.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251017181344.png</guid><pubDate>Sat, 18 Oct 2025 00:13:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251017173822]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20251017173822.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20251017173822.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20251017173822.png</guid><pubDate>Fri, 17 Oct 2025 23:38:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251014122238]]></title><description><![CDATA[<img src="cs3550/attachments/pasted-image-20251014122238.png" target="_self">]]></description><link>cs3550/attachments/pasted-image-20251014122238.html</link><guid isPermaLink="false">CS3550/attachments/Pasted image 20251014122238.png</guid><pubDate>Tue, 14 Oct 2025 18:22:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Object Oriented Programming]]></title><description><![CDATA[Shplait中虽然没有直接提供OOP的办法, 但我们仍然可以用函数来表达他们:假设我们现在所有的对象Shape只有一种操作 - 求出这个物体的面积
我们就可以定义这个面积为一个函数, 当调用就会返回一个整数type Shape = () -&gt; Int fun rectangle(w, h) :: Shape: fun(): w * h fun square(s) :: Shape: fun(): s * s def r = rectangle(10, 15)
r() =&gt; 150 def circle = (fun(): 2 * 2 * 3)
circle()
这里我们就可以认为是创建了两个不同的对象, 他们都有Shape方法, 我们可以调用他们各自的方法就像之前我们写的Env, 我们曾经就是直接把它当做是一个数据类型, 也就是Listof(Binding), 但现在可以认为他是一个对象, 它有且只有一个方法: 输入一个Symbol, 返回一个值.type Env = Symbol -&gt; Value def mt_env: fun (n): error(xxx) fun extend_env(b :: Binding, env :: Env): fun (n): cond | n == bind.name(b): bind.val(b) | ~else: env(n) fun lookup(n::Symbol, env::Env)::Value: env(n)
但像上面这种, 我们只能让对象有一个方法, 如果我们想让他有多个方法, 就需要进行额外操作: 我们可以传进去一个参数, 表示我们需要进行什么种类的方法, 比如上面的Shape, 我们就可以传入#'area或者#'perimeter表示我们想调用面积还是周长方法但上面这种方法无法解决返回多种类型的需求. 我们可以把Shape这个'对象' 定义成一个List的元组, 每个元组里村上这个方法的名字, 和这个方法所对应的函数
<img alt="Pasted image 20251012000409.png" src="cs3520/attachments/pasted-image-20251012000409.png" target="_self" style="width: 400px; max-width: 100%;">甚至我们可以这么写: 用嵌套的元组和数组实现同时存有属性和方法<br>
<img alt="Pasted image 20251012102249.png" src="cs3520/attachments/pasted-image-20251012102249.png" target="_self">
这样就需要在方法中使用this.x表示这个变量需要到自身属性中去查找]]></description><link>cs3520/object-oriented-programming.html</link><guid isPermaLink="false">CS3520/Object Oriented Programming.md</guid><pubDate>Sun, 12 Oct 2025 16:23:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251012102249]]></title><description><![CDATA[<img src="cs3520/attachments/pasted-image-20251012102249.png" target="_self">]]></description><link>cs3520/attachments/pasted-image-20251012102249.html</link><guid isPermaLink="false">CS3520/attachments/Pasted image 20251012102249.png</guid><pubDate>Sun, 12 Oct 2025 16:22:49 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20251012000409]]></title><description><![CDATA[<img src="cs3520/attachments/pasted-image-20251012000409.png" target="_self">]]></description><link>cs3520/attachments/pasted-image-20251012000409.html</link><guid isPermaLink="false">CS3520/attachments/Pasted image 20251012000409.png</guid><pubDate>Sun, 12 Oct 2025 06:04:09 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Queries]]></title><description><![CDATA[既然都有数据库了, 那么我们就需要写查询数据库的指令如果想要debug, 我们可以输入python manage.py shell
打开控制台, 然后输入from &lt;app_name&gt;.models import *
这样就能导入所有的数据库物体进来, 我们就可以输入语句查询了.<a data-tooltip-position="top" aria-label="https://docs.djangoproject.com/en/5.2/ref/models/querysets/" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.djangoproject.com/en/5.2/ref/models/querysets/" target="_self">Django Query DOC</a>p = Person(name="Sam", shirt_size="L")
p.save() #或者用下面这种写法 p = Person.create(name="Sam", shirt_size="L")
记住一定要save, 或者用create来直接存到数据库中当物体保存在数据库后, 就会有id了, 在保存前这个物体的id是不存在的Person.objects.get(id=123)
所有的Query都需要先标注类型是什么Person.objects.filter(shirt_size="L").exclude(&lt;field&gt;__contains="Sam")
~~~~~~~~~~~~~~ -&gt; 查询语句的开头, 决定返回什么 ~~~~~~~~ -&gt;通过某个属性筛选 Recipe.object.filter(title__startswith="Herb")
这样会返回一个Query Set类型, 就算是一个结果也会
但如果我们直接用.get(), 会直接返回对应对象的类型, 或者在查询结尾跟上一个first()变成单个物体可以发现, 在查询的时候, 我们有些写了两个下划线. 这些表示的是Condition查询 - 除了上面的例子, 还有__ge = 2 (greater or equal than 2), __lt = 1 (less than 1)等filter也可以输入object来作为查询条件: .filter(&lt;field&gt; = object), 当然, 我们也可以把两个表格Join在一起, 这需要用到双下划线Recipes.objects.filter(tags__name="comfort").count()
像上面这样, 我们只在Recipe中关联了Tag物体, 没办法直接访问tags的名字, 我们可以join两个表格来查询到tag name需要注意的是, 如果我们不写distinct, 则可能查询到多个相同的recipe物体: 因为一个recipe物体能有多个tag, 但他们都可能包含字母aRecipes.objects.filter(tags__name__contains="a").distinct.count()
#查询所有写过标题包含Potato的用户
User.objects.filter(recipe__title__contains="Potato") #查询用到糖的菜谱
Recipes.objects.filter(steps__ingredients__name__contains="sugar")
在Django中, 它只会执行必须使用到的Query.
这用到了Lazy Query的规则q = Person.objects
q_old = q.filter(age__ge=60) #真正开始执行的地方
for p in q_old: 除此之外, 下面的都会让Query被执行q.count()
q.first()
q[0]
list(query)
...
除了Lazy Query, 还会有Lazy Loaded - 在查询到物体以后, 只会读取这个物体里的所有普通数据. 但它不会加载Related Object - 比如Foreign Key, 因为它可能关联着非常多的物体
只有在真正用到了这个Foreign Key的时候, 才会再查询一次这就导致了1+N问题:for r in Recipe.object.filter.all(): r.filter(author__contains=...)
这样就会导致for循环里每次执行都会查询一次.为了解决这个问题, 我们可以让查询额外查询这个Foreign key:for r in Recipe.object.filter.all().selected_related("author"): r.filter(author__contains=...) recipes = Recipe.objects.prefetch_related("tags")
for r in recipes: print([t.name for t in r.tags.all()]) select_related("author")：一次 JOIN，适合外键字段（author）。
prefetch_related("tags")：两次 SQL，再内存中拼，适合多对多或一对多（tags）
并且, 我们并不希望让数据库传输过多的信息, 或者查询很多条语句. 我们可以让数据库干更多的东西, 而不是传输到我们这再通过python来干. Recipe.objects.all().aggregate(Sum("field"))
Recipe.objects.all().aggregate(Count("field", distinct=True))
Recipe.objects.all().aggregate(Max("steps__ingredients__amounts"))
]]></description><link>cs3550/queries.html</link><guid isPermaLink="false">CS3550/Queries.md</guid><pubDate>Thu, 02 Oct 2025 04:23:53 GMT</pubDate></item><item><title><![CDATA[Probability]]></title><description><![CDATA[很多时候, 我们都会用期望来进行衡量事件的好坏. 然而很多时候, 期望并不是准确的.比如对于人拥有的财富来说, 拥有越来越多的钱, 和快乐的增长不是线性的, 当拥有一定数量后, 快乐的增长会开始递减.
或者是抽奖, 如果是0.5的概率获得1000元, 或者什么都没有, 很多人会把这个抽奖和100%获得400元看作是等值的. 然而这和期望是相反的. 下面是一些回顾概率相关的公式:Conditional Probability:也就是知道事件已经发生了, 发生事件的概率就是可以用上面的公式算出来 - 同时发生的概率除以发生的概率同样的, 我们也可以从上面那个式子得到:
Product Rule
并且可以套娃:
通常, 有很多各种各样的条件, 但我们可以把那些我们不关心的条件合并, 只保留我们关心的条件, 然后用贝叶斯去计算.
<img alt="Pasted image 20250909225355.png" src="cs4300/attachments/pasted-image-20250909225355.png" target="_self">
比如上图, 我们只关心温度是冷的天气情况, 所以可以只保留的部分, 然后再把他们归一化(的和为1)并且, 很多时候每得到一个新的信息, 就能更新我们的概率:通常来说, 对于这种问题, 我们有:同样的, 我们可以用上面的Normalize的理念, 只保留我们关心(或者说观测到的事件), 其他的不考虑.<br>
<img alt="Pasted image 20250909230504.png" src="cs4300/attachments/pasted-image-20250909230504.png" target="_self">
比如上面这个表格, 如果我们想要求 - 也就是已知是冬天, 各种天气的概率.
我们就可以先划掉上面的四行, 因为我们只考虑冬天, 并且由于我们没有观测到温度, 所以我们会把的每种温度加一起, 再把的每种温度加一起, 得到在冬天下, 晴天和雨天的概率都是, 归一化后就是一半一半而如果我们要求, 则答案已经在表格上了, 我们只需要归一化就行通过上面的公式经过变换, 我们就可以得到贝叶斯定理
这个定理的好处就是, 现实中的很多问题都是反过来有很多数据, 我们就可以用这种来推算出我们想要的答案:如我们已经知道得新冠后发烧的概率, 我们就可以通过贝叶斯定理去算出发烧后确诊新冠的概率同样的, 贝叶斯定理也可以和Inference一起用:<br>
<img alt="Pasted image 20250909232825.png" src="cs4300/attachments/pasted-image-20250909232825.png" target="_self">
比如在这里, 我们就想要知道当脖子僵硬的时候, 患有脑膜炎的概率
所以我们可以用贝叶斯展开. 然而他的下半部分我们并不知道, 所以可以用Inference得到脖子僵硬的概率:
因为我们已经知道已知患脑膜炎和不患脑膜炎时脖子僵硬的概率, 只需用Product Rule就能得到脖子僵硬并且患脑膜炎的概率, 和脖子僵硬不患脑膜炎的概率, 相加就能得到脖子僵硬的概率Conditional Independence 表示的是, 当给定一个事件, 我们会知道另外两个事件是独立的, 如我们知道在下雨, 马路堵车和人们带伞的概率是互相独立的或者, 医生检查牙齿会拿钩子去钩牙上的小洞, 但这些小洞是蛀牙导致的, 而蛀牙也同样导致牙痛. 我们并不能说钩子勾住蛀牙的概率很依赖于我们知不知道牙痛.
所以, 下面这个概率中, 就算去掉我们知不知道牙痛, 对勾住蛀牙的概率都没有太大影响, 因为当我们知道有蛀牙的时候, 牙痛和勾住牙洞属于是两个相互独立的事件
虽然世界上大多数事情都是互相关联的, 但是有些时候我们已知了一个事情, 我们就可以说和是互相独立的 或者<br><img alt="Pasted image 20250909124218.png" src="cs4300/attachments/pasted-image-20250909124218.png" target="_self">]]></description><link>cs4300/probability.html</link><guid isPermaLink="false">CS4300/Probability.md</guid><pubDate>Wed, 01 Oct 2025 04:56:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MVC架构]]></title><description><![CDATA[大多数网页都分为前端和后端.前端(Client)可以是用户, 电脑, 也可以是下载到本地的网页. 用户可以自由的修改自己本地的网页, 或者给服务器发送请求. 而服务器的任务就是回复Client发送的各种Requests对于服务器来说, 请求只是一段数据. 比如像之前, 我们通过地址能访问到服务器的各个文件. 而这些文件的请求都是可以改变的. 或者说, HTML中的图片也会转换为文件请求, 比如HTML中的是a.png 而我们可以在后端中写: 如果请求的是a.png, 我们会返回b.png然而, 如果我们用Python来输出网页, 那太蛋疼了 - 我们可以用Python读取HTML后再发给Clients. 不过这样就会导致HTML还是静态的了.
我们可以用Template HTML来解决这个问题: 在HTML中放一些特殊格式的文字, 然后用Python读取后, 我们会替换那些文字成我们想展示的数据. 虽然这样处理网页可以让网页变成动态的了, 但耦合性太高了 - 我们需要在Python中写超多的处理的IF条件并检索那些替换的文字.
我们可以用MVC架构来让这个变简洁很多 - 用多个Python文件来处理不同的工作: 如
Router只负责读取用户请求, 并决定是否直接读取文件, 还是让其他Python代码来去替换HTML的内容后再发给Clients
Model 只负责读取存储在电脑上的数据, 如SQL数据
View 只负责读取Template HTML
Controller 会读取Models的数据和View的HTML, 然后把数据替换进HTML中, 并发给Router.
在Django中, urls.py 就是Router, 而view.py是Controller, model.py是Model, 而/template文件夹中存放的是所有的Template HTML, 也就是View.如果想用Django框架, 我们可以遵循下面的步骤
创建项目和程序
定义Model
定义View
定义Template 定义Router
对于Numerical Field, Django:
IntegerField
FloatField
DecimalField - 专门用来存储金钱等数字
对于Text Field, 有
CharField - 就像SQL的varchar一样, 需要传入一个max_length
TextField - 用来存储长文字的
EmailField - 储存邮件
URLField - 储存链接
对于用户上传的文件, 有
ImageField - 用户上传的图片
FileField - 除了图片外的所有文件
DateField
DateTimeField
Field可以定义Default, null = true或者blank = true
null = true表示可以允许无数据
blank = true表示可以允许用户输入空字符串
我们可以同时使用blank和null属性在model.py文件中, 定义一个model object只需要定义一个类就行from django.db import models class Question(models.Model): #定义model objects的属性 question_text = models.CharField(max_length=200, null = true, blank = true) pub_date = models.DateTimeField()
在创建完以后, 我们可以用下面这些方法增删改q = Question(question_text="123", pubdate=xxx)
q.save()
Questions.object.get(id=1).question_text q2 = Questions.object.get(id=1)
q2.question_text = xxxx
q2.save()
Questions.object.get(id=1).question_text
当然, 数据库里的各个文件可能互相关联, 如问题和答案SQL中有One to One, Many to Many, One to Many关系
<a data-href="ER Model#Cardinality" href="cs5530/er-model.html#Cardinality" class="internal-link" target="_self" rel="noopener nofollow">ER Model &gt; Cardinality</a>
OneToOneField -一对一关系
ManyToManyField - 多对多关系
ForeginKey - 一对多关系
from django.db import models class Cat(models.Model): health = models.OneToOneField('HealthRecord', on_delete=moedls.RESTRICT) class HealthRecord(models.Model): spayed_neutered = moedls.BooleanField() class Vaccination(models.Model): patient = moelds.ForeignKey('Cat', on_delete=moedls.CASCADE) class Illness(models.Model): patient = moedls.ForeignKey('Cat', on_delete=moedls.CASCADE) #一个猫可能有多个疾病, 我们需要在一对多的多的class中写Foreign Key type models = models.CharField(max_length=200) 在创建关系后, 可以互相查找. 比如#这里一个主人可以有多个宠物, 一个宠物可以是多个种类
class Pet(models.Model): health_info = models.OneToOneField(HealthRecord) owner = models.ForeignKey(User) species = moedls.ManyToManyField(Animal)
这种结构, 我们在查询的时候会根据结构关系返回单个物品或者Setpet.health_info -&gt; &lt;HealthRecord: ...&gt;
pet.owner -&gt; &lt;User: User object(12)&gt;
pet.species -&gt; &lt;QuerySet [&lt;Animal&gt;, ...]&gt; user.pet_set -&gt; &lt;QuerySet [&lt;Pet&gt;, ...]
species.pet_set -&gt; &lt;QuerySet [&lt;Pet&gt;, ...]
healthrecord.pet -&gt; &lt;Pet: ...&gt;
请注意, 上面的例子就可以很好的看出, 虽然可以互相查找, 但创建的位置也很重要: 比如我在Pet中创建了owner变量, 我就可以直接使用pet.owner. 但如果想反向查询, 就需要写user.pet_set. 这个pet_set是Django帮我们创建的. 唯一的例外就是OneToOne有些时候, 某些东西可以refer它自己:models.ManyToManyField('self', symmetry = false)
这里的对称默认是true的, 但很多时候我们需要是false, 比如我们关注了一个人, 另外一个人不会直接关注我.
但有些程序是对称的, 如情侣关系我们在修改我们的数据库的时候, 不能单纯的删除掉原本的数据, 我们需要把数据迁移到新的数据库上. 这就需要用到Migrations当我们执行了manage.py makemigrations后, 会产生一个migration files, 它里面包含了所有的数据
然后我们会需要执行manage.py migrate就能让这些数据移动到新的数据库上Django中的Controller就是view.py
他会把HTML经过修改输出出来最重要的就是render函数assignments = model.Assignment.objects.order_by("due")
return render(request, "index.html", {"assignments": assignments}) 使用的模板&gt;~~~~~~~~~~ ~~~~~~~~~~~~~&gt;模板的变量
大多数只读网页都是这样的 - 只有一个或多个Query去查询数据, 然后把数据渲染出来然后在HTML网页中, 我们就可以用下面的格式读取这个变量了&lt;h1&gt;Hi, there are {{assignments.count}} number of homeworks&lt;/h1&gt; {% for assignment in assignments%} &lt;!--For循环需要这么写--&gt; { % if assignment.name % } &lt;li&gt;{{assignment.name}}&lt;/li&gt; {% else %} &lt;li&gt;an unnamed assignment&lt;/li&gt; { %endif% }
{% endfor%} 我们想获取变量的属性的时候, 可以直接用var.attrib的写法.
因为传递进来的是List, 所以我们可以用上面的遍历方法, 或者使用assignment.0.name来获得第一个物体的名字除此之外, 我们还可以用filter, 如cat.name|default:"unnamed cat", 这样就是如果没有属性, 则这个猫的名字就是unnamed cat虽然可以进行一些简单的filter运算, 但是Template Language通常不建议写很复杂的运算. 但我们可以把运算的代码放进model.py的对象中, 作为对象的方法. 然后直接在template中使用cat.method来进行方法调用并且在传递这些变量的时候, 这些变量其实就是一个数据结构(List), 所以我们可以自己构建数据结构然后传递进去
这里就是自己构建了一个Listcats = [] for xxx in xxxs cats.append(xxx) return render(request, "index.html", {"cats": cats})
或者我们也可以构建一个字典等传递进去{%for k in dictionary.key%}
{%for v in dictionary.values%}
{%for k,v in dictionary.items%}
在for循环中, 还有几个内置变量, 我们可以直接使用{% if not forloop.first %}
forloop.last 返回true如果是最后一个元素
forloop.counter 从1开始的计数器
forloop.counter0 从0开始的计数器
我们还可以在template中导入其他的template并传入参数{%include "header.html" with title="xxx"%}
在Django中, View就是urls.py在里面我们可以规定每个路径转跳到哪个Controller的方法. 并且还可以读取Url中的文字, 转换成查询的变量path("", views.index),
path("profile/&lt;str:username&gt;", views.profile),
path("recipe/&lt;int:recipe_id&gt;", views.recipe),
]]></description><link>cs3550/mvc架构.html</link><guid isPermaLink="false">CS3550/MVC架构.md</guid><pubDate>Thu, 25 Sep 2025 16:25:13 GMT</pubDate></item><item><title><![CDATA[Lambda Calculus (Encoding)]]></title><description><![CDATA[我们会发现, 我们之前写的let, 可以被转换成函数的形式let x = 5: 6 + x (fun (x): 6 + x)(5)
可以进一步抽象, 说x右侧的值就是函数的变量, 而let的body就是函数体let name = rhs: body (fun (name): body)(rhs)
所以, 我们甚至可以直接删除掉letE, 直接用appE来代替
我们会把这种用已有的功能去实现新功能的操作为语法糖
而我们如果新建一个类型和函数如letE去处理这种新功能, 就是Extend Library. 不管是语法糖还是Extend Library都是一种扩展语言的方式, 我们可以称这种操作为encoding
除此之外, Shplait还支持用macro来简化操作, 如我们之前使用的reslet
当然, 如果想用encoding来扩充我们的语言, 我们很大程度都需要依赖核心语言的功能.像之前, 我们的moe语言只支持一个参数的函数, 我们可以通过两种方法来Extend, 前者是作业中使用的方法(Extend Library), 后者则是curryinglet f = (fun (x,y): body): f(1,2) let f = (fun (x): fun(y): body): f(1)(2) //或者是
let f = (fun (x): fun(y): body): f(1)(2)
如果我们想Encode if, 并且还要实现不到对应的分支就不执行里面的内容的功能, 我们可以把两个分支分别放入一个函数中去if_proc(tst, fun (dummy): then, fun (dummy): else) (0)
对应的, 我们可以把true和false也变成函数(实际上就是一个输入两个参数的函数, 只不过这里以currying方式写出来了):true = fun(x) : fun(y) : x
false = fun(x) : fun(y) : y
其中true输入两个值, 返回第一个, false输入两个值, 返回第二个
实际上在使用true和false的时候, 实际上就是在以函数的形式来使用bool:tst(fun(dummy):then)(fun(dummy):else)(0)
这里的tst可以是true也可以是false. 虽然他们是函数, 但只要我们一直把他们这么使用, 我们就可以认为它是bool如果要Encode list, 我们实际上就是想把这个list变成一个函数, 我们可以通过一些手段获得第一个元素和剩余的元素
这里我们就先不考虑list, 而是考虑pair, 也就是一个只有两个元素的结构//一个函数, 他可以用某种方式选择第一个或者第二个元素
fun (selector) : selector(f)(s) pair = fun(x): fun(y): fun(selector): selector(x)(y) //实际上, 我们正好可以用true和false来当做Selector!
fst = fun(p) : p(true)
snd = fun(p) : p(false)
fst(pair(1)(0)) ⇒ fst (fun (sel): sel(1)(0)) ⇒ ( fun (sel): sel(1)(0))(true) ⇒ true (1)(0) = ( fun (x): fun (y): x)(1)(0) ⇒ ( fun (y): 1)(0) ⇒ 1
我们可以发现, 上面的种种简化竟然可以甚至把if和list都简化成函数, 所以我们可以把我们的moe语言简化成只有三个部分	&lt;Exp&gt; ::= &lt;Symbol&gt; //用来分辨函数的符号 | &lt;Exp&gt;(&lt;Exp&gt;) //调用函数 | fun (&lt;Symbol&gt;): &lt;Exp&gt; //定义函数, 或者写作λ(&lt;Symbol&gt;): &lt;Exp&gt;
这种就叫做λ-Calculus比如我们想些add1, 就是把一个数加一
因为我们现在是在自己设计primitive operation, 所以我们并不能使用+add1 = λ(n): λ(f): λ(x): f(n(f)(x)) //我们需要让f对x操作n+1遍 你可能会比较疑惑, 为什么n(f)(x)就是把f对x操作n遍了?
这就引入了Church numerals了
zreo(f)(x)可以被展开成这样(λ(f): λ(x): x)而在λ演算中, 自然数n就被表示为输入一个函数f和一个参数x, 会把f作用在x上n次. 这就是为什么我们对n(f)(x)再应用一遍f, 就能得到x+1 - 可以认为就是那么定义的, 或者说我们就是在计数对x操作了多少次如果我们需要add2, 就可以写add2 = λ(n): add1(add1(n)), add3以此类推那要是add呢? 我们要是想把任意两个数相加该怎么办?
别忘了有Church numerals这个东西 - 既然我们都有第二个参数m了, 我们可以直接用λ Calculus的特性, 把add1 作用在n上m遍add = λ(n): λ(m): m(add1)(n)
那要是乘法呢? 我们可以认为n乘m就是把n加起来, 一共加m遍mult = λ(n): λ(m): m(add(n))(zero)
要是我们想检测一个值是不是0呢?
在这里, 我们要用到另外一个概念, 就是zero会忽略掉第一个参数(因为没有意义)iszero = λ(n) : n(λ(x): false)(true)
这样, 如果我们输入0的时候, 我们会把λ(x): false这个函数作用在true上0遍, 也就是直接返回true.
但如果不是0, 就会把true作为参数输入到λ(x): false中, 也就永远会得到false但需要注意的是, 当我们把数"+1"了以后, 我们并不可以撤销, 也就是说, 我们需要稍微多做点功课来做到减法:
虽然我们没办法撤销, 但我们知道原本的值是怎么得来的啊: 比如10就是对0做了10次f函数操作
那么我们只需要执行9次后停下来不就行了?所以我们就用上了pair: 记录一组数, 表示`(n-1, n)
然后再定义一个跟加法很像的东西: shift = λ(p): pair(snd(p))(add1(snd(p))) //这里的snd就是取pair的第二个数
可以看到, shift可以把pair的第二个数复制到第一个位置, 然后把第二个数加一这样, 我们就能得到一个数-1是多少了:
比如我们需要知道10-1的值, 我们可以对0执行10次shift, 然后pair的第一个值就是9了sub1 = λ(n): fst( n(shift)(pair(zero)(zero)) )
我们现在来Encode一下递归block: def fac: fun (n): if n == 0 | 1 | n * fac(n - 1) fac(10)
上面的代码就是Shplait中的递归函数(阶乘). 这里的def让我们可以在函数体中调用函数自身, 还可以把函数赋值给fac我们会尝试自己创建一个新类letrec, 它也可以让我们在函数体中调用自身letrec fac = (fun (n): if n == 0 | 1 | n * fac(n - 1)): fac(10)
然而, 我们目前还无法用现有的let做到, 因为let只允许body部分调用let定义的东西我们可以做的就是用Encode来实现一个letrec, 然后我们会通过某些方法能把rhs部分提取出来放进每个调用的地方. 最终, 我们就能在parse中调用这个方法更简单来说, 我们希望做出一个函数, 它: mk_rec(f) = f(mk_rec(f))目前, 我们直接用let是不行的, 因为我们在body中并没有定义fac函数let fac = (fun (n): if n == 0 | 1 | n * fac(n - 1)): fac(10)
但, 在调用fac(10)的时候, 我们确实是定义了fac函数的 - 所以我们可以把fac函数的定义作为参数传进去, 这样就是没有问题的了let facX = (fun (facX, n): if n == 0 | 1 | n * facX(facX, n - 1)): facX(facX, 10)
不过这么写有点太不雅观了, 我们希望直接能调用这个函数, 就像其他编程语言一样. 所以我们可以在外层包一下:let fac = (fun (n): let facX = (fun (facX, n): if n == 0 | 1 | n * facX(facX, n - 1)): facX(facX, n)): fac(10)
现在, 我们已经Encode了递归, 我们现在就可以尝试怎么在自己的语言上实现这个功能了.
然而我们会发现, 在moe语言中, 每个函数只能输入一个参数.
当然, 这很简单, 直接用currying就行了let fac = (fun (n): let facX = (fun (facX): fun(n): if n == 0 | 1 | n * facX(facX) (n - 1)): facX(facX) (n)): fac(10)
然后我们又发现, 我们输入进去的参数就是一个数字, 然后里面的faxX的第一个参数已经定死了, 后面的也是我们需要输入的数字, 所以可以把刚加上的外层fun给去掉:let fac = (let facX = (fun (facX): fun(n): if n == 0 | 1 | n * facX(facX) (n - 1)): facX(facX)): fac(10)
这里简单总结一下, 就是让fac赋值成两行代码
第一行是定义了facX - 输入自己和一个数字
第二行就是调用facX, 并且已经输入好了自身, 所以外层函数没了但里层仍然是个函数, 所以就会返回一个定义好且可以递归的函数给fac
这样, 里面的那部分已经非常像letrec的语法了. 唯一不一样的就是没有(facX)
我们可以在外面多加一层let, 创建一个变量叫fac, 来替换掉facX(facX) (只是为了好看)然而这样会导致死循环, 这是应为如果我们把facX(facX)移到外面去, 它就不会被delay了 - 不像在if里面会延迟执行. 这个很好解决, 我们只需要再给这个facX(facX)套在函数里就行了let fac = (let facX = (fun (facX): let fac = (fun (x): facX(facX)(x)): fun(n): if n == 0 | 1 | n * fac(n - 1)): facX(facX)): fac(10)
这样, 里面的部分就和letrec完全一致了, 我们现在可以重命名一下来更加的通用:let fac = (let fX = (fun (fX): let f = (fun (x): fX(fX)(x)): (fun (fac): fun(n): if n == 0 | 1 | n * fac(n - 1))(f)): fX(fX)): fac(10)
最终, 我们可以把这个函数分成两个部分, mk_rec和递归函数
<img alt="Pasted image 20250923234353.png" src="cs3520/attachments/pasted-image-20250923234353.png" target="_self" style="width: 500px; max-width: 100%;">]]></description><link>cs3520/lambda-calculus-(encoding).html</link><guid isPermaLink="false">CS3520/Lambda Calculus (Encoding).md</guid><pubDate>Wed, 24 Sep 2025 05:44:00 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250923234353]]></title><description><![CDATA[<img src="cs3520/attachments/pasted-image-20250923234353.png" target="_self">]]></description><link>cs3520/attachments/pasted-image-20250923234353.html</link><guid isPermaLink="false">CS3520/attachments/Pasted image 20250923234353.png</guid><pubDate>Wed, 24 Sep 2025 05:43:53 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[MT1 Examples]]></title><description><![CDATA[&gt; interp(parse( 'box(box(1 + 2))'), mt_env, mt_store)
- Result
res(boxV(2), [cell(2, boxV(1)), cell(1, intV(3))])
&gt; interp(parse( 'let b = box(1 + 2): begin: set_box(b, 4) box(5)'), mt_env, mt_store)
- Result
res(boxV(2), [cell(2, intV(5)), cell(1, intV(4)), cell(1, intV(3))])
&gt; interp(parse( 'let f = (fun (x): box(x)): set_box(f(0), f(1))', mt_env, mt_store))
- Result
res(boxV(2), [cell(1, boxV(2)), cell(2, intV(1)), cell(1, intV(0))]) &gt; interp(parse('let f = (fun (x): box(x)): let b = f(10): set_box(b, b)'), mt_env, mt_store)
- Result
res(boxV(1), [cell(1, boxV(1)), cell(1, intV(10))])
let会修改env, 而box会修改store
在函数被调用的时候, 也会把参数加入到env当中, 执行函数body的时候就能直接查询到值
let的env只会向下影响, 而box的store数据会向上传递&gt; trace interp: interp(parse('2 * 1'), mt_env) - Value
=&gt; interp(multE(intE(2), intE(1)), []) //这里所有的变化全是parse
==&gt; interp(intE(2), []) //接下来去运算mult的两侧
&lt;== intV(2)
==&gt; interp(intE(1), [])
&lt;== intV(1)
&lt;= intV(2)
intV(2)
<img alt="Pasted image 20250922203216.png" src="cs3520/attachments/pasted-image-20250922203216.png" target="_self">&gt; trace interp: interp(parse('fun(x): 5'), mt_env) - Value
=&gt; interp(funE(#'x, intE(5)), [])
&lt;= closV(#'x, intE(5), [])
closV(#'x, intE(5), [])
<br><img alt="Pasted image 20250922203035.png" src="cs3520/attachments/pasted-image-20250922203035.png" target="_self">&gt; trace interp: interp(parse('let f = (fun (x): x + 1): f(10)'), mt_env) - Value
=&gt; interp( letE(#'f, funE(#'x, plusE(idE(#'x), intE(1))), appE(idE(#'f), intE(10))), [] )
==&gt; interp(funE(#'x, plusE(idE(#'x), intE(1))), [])
&lt;== closV(#'x, plusE(idE(#'x), intE(1)), [])
=&gt; interp( appE(idE(#'f), intE(10)), [bind(#'f, closV(#'x, plusE(idE(#'x), intE(1)), []))] )
==&gt; interp(idE(#'f), [bind(#'f, closV(#'x, plusE(idE(#'x), intE(1)), []))])
&lt;== closV(#'x, plusE(idE(#'x), intE(1)), [])
==&gt; interp(intE(10), [bind(#'f, closV(#'x, plusE(idE(#'x), intE(1)), []))])
&lt;== intV(10)
=&gt; interp(plusE(idE(#'x), intE(1)), [bind(#'x, intV(10))])
==&gt; interp(idE(#'x), [bind(#'x, intV(10))])
&lt;== intV(10)
==&gt; interp(intE(1), [bind(#'x, intV(10))])
&lt;== intV(1)
&lt;= intV(11)
intV(11)
]]></description><link>cs3520/mt1-examples.html</link><guid isPermaLink="false">CS3520/MT1 Examples.md</guid><pubDate>Tue, 23 Sep 2025 02:40:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250922203216]]></title><description><![CDATA[<img src="cs3520/attachments/pasted-image-20250922203216.png" target="_self">]]></description><link>cs3520/attachments/pasted-image-20250922203216.html</link><guid isPermaLink="false">CS3520/attachments/Pasted image 20250922203216.png</guid><pubDate>Tue, 23 Sep 2025 02:32:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250922203035]]></title><description><![CDATA[<img src="cs3520/attachments/pasted-image-20250922203035.png" target="_self">]]></description><link>cs3520/attachments/pasted-image-20250922203035.html</link><guid isPermaLink="false">CS3520/attachments/Pasted image 20250922203035.png</guid><pubDate>Tue, 23 Sep 2025 02:30:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Mutable Box & Variables]]></title><description><![CDATA[但似乎到现在, 我们从来没有用过赋值, 因为当我们定义了一个物体, 就永远是这个值了, 除非重新定义一遍. 不能像其他语言那样重新赋值. 这就是为什么我们到现在都没有在这个语言中用for循环 而是用递归代替.也许我们要考虑一下如何在Moe语言中实现这个功能一种方法是用Shplait中的Box, 我们可以把任何东西放入这个Box中, 然后我们可以通过一系列函数来修改这个盒子里的内容class Box&lt;T&gt;{ T v; Box(T v){ this.v = v; }
} Box b = new Box(0);
b.v = 10;
return b.v;
对应在Shplait中就是let b = box(0): begin: set_box(b,10) unbox(b)
如果要把这个功能搬到Moe中, 对应的, 我们就需要在Shplait加上这三个Expression和一个格式了| boxE(arg :: Exp)
| unboxE(arg :: Exp)
| set_boxE(arg :: Exp)
| beginE: (l :: Exp, r :: Exp)
像之前我们把函数当成Value后, 就需要在Value里创建ClosV表示函数, 现在我们也得创建一个BoxV表示一个单独的BoxE表达式被解析出来的值// 注意, 这里的box, unbox, setbox都是Shplait自带的box函数! fun interp(a :: Exp, env :: Env) :: Value: match a | ... | boxE(a): boxV(box(interp(a, env))) | unboxE(a): match interp(a, env) //先解析这个Exp是不是Box, 是的话就查看内容, 不是则报错 | boxV(b): unbox(b) | ~else: error(#'interp, "not a box") | setboxE(bx, val): match interp(bx, env) | boxV(b): let v = interp(val, env): block: set_box(b, v) v | ~else: error(#'interp, "not a box") | beginE(l, r): block: interp(l, env) interp(r, env)
如果我们想自己实现这些box类型和函数, 则需要先知道原理:
说白了我们就需要知道内存里的数据. 为了做到这个, 我们可以像存Env那样, 额外存一个内存, 就叫Store. 并且由于Interp中"内存"是可以实时变化的 - 因为Box的数值可能发生改动, 所以我们需要时刻记录这个Store.
Interp不仅现在要返回Value, 还需要返回Store. 所以我们把这两个东西合并在一起, 叫做Resulttype Result
| res(v :: Value, s :: Store)
但问题又来了: 像之前的num_plus在Interp的时候, 我们可以直接递归地写下去| num_plus(l, r): interp(l, env) + interp(r, env)
然而, 现在的num_plus中的interp不仅仅会返回值, 还会修改"内存". 这个内存前半段修改完了, 后半段需要立刻知道这个被修改了. match interp(l,env,store)
| res(v_l, store_l) //interp会返回得到的value和被修改后的store match interp(r, env, store_l) //接下来, 我们再使用修改过后的store去interp 右侧部分 | res(v_r, store_r): //最后, 右侧的计算完就能把加法两侧的值传递给num_plus了 res(num_plus(v_l, v_r), store_r)
至于Store, 我们可以用下面这个方法表示:type Location = Int
type Storage //可以认为是在某个内存地址存一个值
| cell(location :: Location, val :: Value) type Store = Listof(Storage)
def mt_store = empty
def override_store = cons //就是cons改了个名
//因为Store本质就是一个List, 所以我们可以用cons把一个个cell用overrid (或者说就是cons)连接起来 注意, 从这就有个转变了 - Box里存的不再是我们直接能用的值, 而是Storage中的一个地址, 在得到Box后, 我们得到地址后, 再从Storage中得到地址中的值
在上面, 我们的Moe语言只能用Box来存储Value, 并且用set_box, unbox来读取. 我们在Shplait语言中, 还可以用Variable来进行变量操作:let x = 1: begin: x :=2 x
同样的, Box能做到的操作, Variable也能做到:let x = box(5): let f = (fun (y): unbox(x) + y): begin: set_box(x, 6) f(1) let x = 5: let f = (fun (y): x + y): begin: x := 6 f(1)
至于为什么我们不想再用Box的原因就是因为Box实际上让我们更加的麻烦了: 所有的东西都需要放在Box里. 现在不明显是因为我们只把我们想要改变的东西放入Box中.
但是真正的编程语言应该是什么都是可以改变的 - 就像上面代码中的y和f. 这样我们在使用每个变量(Box)的时候都需要做unbox的操作.为了做到这点, 我们就需要Binding - 跟Storage是一个东西type Binding
| bind(name :: Symbol, location :: Location)
比如, 当我们写let x = 5 : x, 现在就变成了创建一个Binding, 对应的Storage中也需要有一个这个数据check: interp(parse('let x = 5: x'), mt_env, mt_store) ~is res(intV(5), override_store(cell(1, intV(5)), mt_store))
所以, 现在的ieE(s)不能再返回一个Symbol了, 而是需要在Storage中查找数据| idE(s): res(lookup(s, env), sto)
HW4 内容, 此处略]]></description><link>cs3520/mutable-box-&amp;-variables.html</link><guid isPermaLink="false">CS3520/Mutable Box &amp; Variables.md</guid><pubDate>Tue, 23 Sep 2025 00:29:56 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250913180828]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250913180828.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250913180828.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250913180828.png</guid><pubDate>Sun, 14 Sep 2025 00:08:28 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250913162152]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250913162152.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250913162152.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250913162152.png</guid><pubDate>Sat, 13 Sep 2025 22:21:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Layout]]></title><description><![CDATA[然而到现在, HTML的内容都是从上到下的, 不像商业的那种网页这么花哨. 这是因为HTML原本就不是用来面向网页程序的在古早的HTML, 有Frames, Tables, 和Float来进行排版, 然而不尽人意在现在出现了Flexible Box, 它可以:
像Frames可以nest元素
像Tables可以自适应元素大小
像Float可以把所有的元素横向排列
在原本的HTML中, 大部分元素的Display模式是block, 这就是为什么每个元素都是从上到下堆叠. 如果改成inline的话, 就会和下面的元素在同一行.
除此之外, Display的模式还有none和flex当一个元素的Display模式变成flex后, 他就变成了一个flex container, 里面的所有子元素都变成了flex item.
比如把一个Unordered list改成flex模式, 则里面的元素都会横向排列在同一行.上面讲的都是Flex-box的Box, 而它还有一个特殊的地方是Flex: 会自适应窗口大小.
这里讲的自适应大小, 通常是用来处理剩下来的空白空间在处理这种问题的时候, 我们首先需要知道固定的元素需要多少的位置, 然后再去看空白怎么处理. 处理空白的时候, 我们经常会用到justify-content属性一般来说, 我们在深度定制排版的时候, 都会先重置默认的布局
* {margin : 0, padding : 0, box-sizing: border-box}
这样会删掉原来自带的所有空行margin的增加会让在当前元素边框的外侧围上一圈空白
padding的增加会让当前元素边框的内侧围上一圈空白对于这些Flex items的排列方向是可以定义的, 在css的flex-direction可以修改. 默认是row, 修改成column就变成了从上到下排列.我们可以认为默认的那些元素(Display: block)都是flex-direction: column我们可以修改每个item的width和height属性.
这两个属性会输入一个长度值, 长度值可以是
123 px 表示以像素为单位
rem 表示原本的文本高度, 由root element的font大小定义
vw和vh表示的是相对于视窗的大小, 100 vh表示的是完整的视窗高度
em 表示的是父级的大小
%
空白分为padding和gap. 这两个属性都是加在container上的
gap是写在父元素上的, 会让这个元素里面所有的item (子元素)之间有空白间隙.并且, gap会被&lt;div&gt;影响: 如果我们把三个flex-item用一个&lt;div&gt;包起来, 则这三个item就不会有空隙了我们可以通过justify-content来修改剩余的空白 - 这里的空白指的是去除元素, gap, padding等剩下没用的空间. 并且不考虑子元素的子元素的空白.
这个属性的变量可以填:
start 把空白都放在最后, 和left一样. end 把空白放到开始(因为这个属性表示的是文字, 所以当文字在结尾, 空白自然就在开头)
center 把原本全都在最右边的空白切成两半, 然后平均分给两边
space-between 把空白分配到元素中间, 空白还会和原本的Gap叠加
space-around 跟上面的不一样的是, 第一个元素的左边和最后元素的右边也会有空白. 但这两个空白是元素之间的空白的一半(如果不考虑gap的话)
space-evenly 和上面不同的是, 两头的空白和元素之间的空白长度是一样的(如果不考虑Gap)
我们可以通过 align-items 来修改物品在交叉轴上的排布方式：
flex-start：靠交叉轴起点对齐
flex-end：靠交叉轴终点对齐
center：在交叉轴上居中 stretch：如果项目没有固定高度/宽度，就会被拉伸填满交叉轴 注意：align-items 控制的是 交叉轴，而不是主轴。 如果 flex-direction: row，交叉轴是竖直方向 → flex-start = 顶部，flex-end = 底部 如果 flex-direction: column，交叉轴是水平方向 → flex-start = 左边，flex-end = 右边 我们不仅仅可以控制空白的分布样式, 我们还可以控制内容是如何自适应的. 就是通过flex-grow.flex-grow: 1 表示的就是会随着窗口增长而增长. 并且grow的优先级会比空白的优先级高. 一般用上grow了, 就没有空白了flex-grow的值可以是大于等于0的任何数, 比如2, 增长速度就是1的两倍, 如果设置成0就是不增长
有时候, 人们会把元素的默认宽度改成0, 然后让他们按照比例增长, 这样就可以按照比例自适应增长.
如果要这么写, 需要使用flex-basis来设置起始长度为0
相反的, 我们可以用flex-shrink来让元素缩小. 默认的值就是1, 也就是允许缩小. 如果我们设置成0, 就表示这个元素永远都是那么大. 我们还可以用max-width和min-width来限制这些元素的生长/缩小的大小. 如果缩小到很小了, 但还是不够显示, 我们可以用flex-warp: warp属性来让同一行的元素换行到下一行. 如果我们写flex: 0 1 auto, 表示的就是这个元素不grow, 但shrink, 并且flex-basis是auto
这个是元素的默认值, 我们可以修改这三个值来调整grow, shrink, flex-basis<img alt="Pasted image 20250904115825.png" src="cs3550/attachments/pasted-image-20250904115825.png" target="_self">如果想从一张图片来复刻网页, 我们可以遵循下面的步骤:
这个容器是Row 还是 Column? (flex-direction)
标记出来元素和之间的空白, 确保Gap是统一的 如果Gap不是统一的, 则说明很可能我们分割元素分割错了, 尝试合并或分割某些元素(或者用grow来解决) 修改Main-axis中的元素排列, 考虑grow/shrink
修改Main-axis中的空白排列, 考虑Justify-content
考虑Other-axis中元素的排列
Flex 排版不会让元素自然重叠，如果需要让一个元素覆盖在 container 上（比如页面中的弹窗或遮罩层），通常使用 定位：
给覆盖元素设置 position（如 absolute 或 fixed）
再配合 top、left、right、bottom 来决定它相对于定位参考点的偏移位置
如果要控制层级关系，可以使用 z-index
我们的网页层级可以告诉用户这个软件是怎么用的: 通常一个层级能控制自己的子元素, 而子元素无法修改父元素. 比如最顶层的Tool bar, 不管内容怎么变, Tool bar都不会变的.响应式的CSS可以通过@media来实现:@media (max-width: 800px){/*只会在小于等于800px的时候触发*/ /*CSS Rules*/
}
我们还可以用calc()去混合计算各种长度, 如calc(100%-3rem)/4或者用clamp去限制值的最大值和最小值:
font-size: calc(clamp(1.5rem, 3vh, 3rem)) 这里的3vh是期望值, 但会随着窗口高度调整缩放, 并且不会小于1.5rem或大于3rem总的来说@media是用来做"breakpoint"的, 也就是在某个关键点, 修改整个网页的布局
而calc是用来在固定好的布局上来调整各个元素的大小]]></description><link>cs3550/layout.html</link><guid isPermaLink="false">CS3550/Layout.md</guid><pubDate>Thu, 11 Sep 2025 16:28:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250909232825]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250909232825.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250909232825.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250909232825.png</guid><pubDate>Wed, 10 Sep 2025 05:28:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250909230504]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250909230504.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250909230504.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250909230504.png</guid><pubDate>Wed, 10 Sep 2025 05:05:04 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250909225355]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250909225355.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250909225355.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250909225355.png</guid><pubDate>Wed, 10 Sep 2025 04:53:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250909133019]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250909133019.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250909133019.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250909133019.png</guid><pubDate>Tue, 09 Sep 2025 19:30:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250909130609]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250909130609.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250909130609.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250909130609.png</guid><pubDate>Tue, 09 Sep 2025 19:06:09 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250909125119]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250909125119.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250909125119.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250909125119.png</guid><pubDate>Tue, 09 Sep 2025 18:51:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250909124218]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250909124218.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250909124218.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250909124218.png</guid><pubDate>Tue, 09 Sep 2025 18:42:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Lambda]]></title><description><![CDATA[在moe中, 单个的function不能算一个值, 但在Shplait中, 单个的function也可以当做一个Value传入, 这个值的类型就是一个#&lt;function:xxx&gt;或者, 在Shplait中, 定义一个函数实际上不用名字 - 就跟其他语言中的Lambda一样fun (x): x + x可以把函数当成值(参数)传递的好处就是我们可以让其他函数调用这个函数, 如map
或者我们甚至可以用let定义函数let double = (fun(x): x + x): double(10)
或者可以:(fun(x):x + 6)(10) -&gt;16
可以认为我们现场创建了一个函数并直接调用这样创建函数神奇的是, 他可以接收到外部的变量:fun add_to_all(n): map(fun(x): x + n, [1, 2, 3]) add_to_all(10)
-&gt;[11, 12, 13]
甚至, 我们可以写一个创建函数的函数:fun make_adder(n): fun(x): x + n make_adder(5)
-&gt; Int-&gt;Int
#&lt;function&gt; make_adder(5)(10)
-&gt;15
<img alt="Pasted image 20250908120334.png" src="cs3520/attachments/pasted-image-20250908120334.png" target="_self">所以, 我们现在可以去掉以前的函数表达, 可以认为函数也都是一个值(Exp), 值的类型得到的就是func.
上面的最后一个表示的就是第一个Exp会运算出function, 然后第二个括号是这个function的参数然而上面的新版parse就会接受这种格式1(2), 但这个明显不是一个合法的Expression, 所以我们需要注意interp处理这种问题所以我们也可以彻底抛弃之前的fundef类型了, 转而都统一到Exp中type Exp
... | funE(n :: Symbol, body :: Exp) | appE(fn :: Exp, arg :: Exp)
由于现在函数也是一个值, 属性上来说, 跟int是一个类型的, 所以我们需要把他们归在同一个type下:type Value
| intV(n :: Int)
| closV(arg :: Symbol, body :: Exp, env :: Env) //这个是表示一些环境变量 type Binding
| bind(name :: Symbol, val :: Value) type Env = Listof(Binding) check: interp( let y = 10: fun (x): y + x, mt_env) ~is closV(#'x, y + x, extend_env(bind(#'y, intV(10)), mt_env)) ]]></description><link>cs3520/lambda.html</link><guid isPermaLink="false">CS3520/Lambda.md</guid><pubDate>Mon, 08 Sep 2025 23:03:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250908120334]]></title><description><![CDATA[<img src="cs3520/attachments/pasted-image-20250908120334.png" target="_self">]]></description><link>cs3520/attachments/pasted-image-20250908120334.html</link><guid isPermaLink="false">CS3520/attachments/Pasted image 20250908120334.png</guid><pubDate>Mon, 08 Sep 2025 18:03:34 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250904115825]]></title><description><![CDATA[<img src="cs3550/attachments/pasted-image-20250904115825.png" target="_self">]]></description><link>cs3550/attachments/pasted-image-20250904115825.html</link><guid isPermaLink="false">CS3550/attachments/Pasted image 20250904115825.png</guid><pubDate>Thu, 04 Sep 2025 17:58:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Binding and Enviroments]]></title><description><![CDATA[从现在, 我们重新定一下在MOE怎么表示一个表达式:从这种:
// An EXP is either // - 'NUMBER' // - 'SYMBOL' // - 'EXP + EXP' // - 'EXP * EXP' // - 'SYMBOL(EXP)' 变成这种:
&lt;Exp&gt; ::= &lt;Int&gt; | &lt;Symbol&gt; | &lt;Exp&gt; + &lt;Exp&gt; | &lt;Exp&gt; *&lt;Exp&gt; | &lt;Symbol&gt;(&lt;Exp&gt;) 对应在Shplait中就是
type Exp
| intE(n :: Int)
| idE(s :: Symbol)
| plusE(l :: Exp, r :: Exp)
| multE(l :: Exp, r :: Exp)
| appE(s :: Symbol, arg :: Exp) 第二种叫BNF格式(Backus Naur Form)在现在, 我们需要在MOE也加入变量的功能| let &lt;Symbol&gt; = &lt;Exp&gt;: &lt;Exp&gt; 在MOE中写出来可能就是
let x = 1 + 2: x + x
会返回6 (let x = 1 + 2: x + x) + (let x = 4 + -3: x + x)
会得到8 let x = 1 + 2: let x = 4 + -3: x + x
会返回2 let x = 1 + 2: let y = 4 + -3: x + x
会返回6 let x = 1 + 2: let x = x + -4: x + x
会返回-2, 因为在第二行的x在运算的时候是取的上面的值, 也就是3
对应的, 我们就需要修改Shplait中的Parser和Expression了:match s |'let $id = $rhs: $body': letE(syntax_to_symbol(id), parse(rhs), parse(body))
并且, 为了做到这种赋值操作, 我们就需要subst操作, 就像在执行函数时传递参数一样
因为我们要确保下面这种操作, 所以我们在替换的时候, 不能把被赋值的x替换:let x = 1 + 2: let x = 4 + -3: x + x
会返回2 //如果要把x替换成10, 在let x = y : x中, 返回的应该还是let x = y : x
//但如果是在let y = 17 : x 中, 则返回的应该是let y = 17 : 10 fun subst(what :: Exp, for :: Symbol, in :: Exp): match in | .... | letE(n, rhs, body): letE(n, subst(what, for, rhs), if n == for | body | subst(what, for, body))
但如果按照上面这么写的话, 每一个变量都需要独自遍历一遍所有的Sub Expression, 这就导致如果有个变量的话, 就需要的时间但如果我们不主动去替换那些变量, 而是把他们都存在一个List中, 这样就会快很多: 每次需要这个变量的值的时候, 直接在那个List中找就好了interp :: (Exp, Env, Listof(FunDef)) -&gt; Int //相关的函数
mt_env :: Env extend_env :: (Binding, Env) -&gt; Env bind :: (Symbol, Int) -&gt; Binding lookup :: (Symbol, Env) -&gt; Int
对于interp函数的实现, 我们可以这么写:| letE(n, rhs, body): interp(body, extend_env(bind(n, interp(rhs, env, defs)), env, defs)
意思就是读取到let后, 会先interp赋值给这个变量的Expression的值, 得到值以后, bind到当前环境中. 最后在进行解析body的部分对于| appE的部分, 我们并不需要提供变量环境, 这是因为如果提供了, 环境中的变量可能替换掉函数中的错误的变量(如这个函数有一个没有定义的变量, 本来应该报错, 但被替换成值了.)在MOE语言中, 我们可以认为变量有三种操作: binding, bound和free
分别是: 给变量绑定一个值(或者是指这个变量会被定义一个值), 把变量替换成绑定的值(如函数传参 - 会真正的赋予值并计算), 和没有绑定值的变量]]></description><link>cs3520/binding-and-enviroments.html</link><guid isPermaLink="false">CS3520/Binding and Enviroments.md</guid><pubDate>Wed, 03 Sep 2025 18:19:30 GMT</pubDate></item><item><title><![CDATA[Planning]]></title><description><![CDATA[Reflex Agent就是基于当前的感知做出决策. 它可能有内存或者模型去构建当前的世界状态.
但是它并不会考虑当前的决策会对未来产生什么影响. 上面的AI疑似有点弱智了: 它就类似贪心算法, 也许连AI都称不上.
而Planning Agent, 可以基于当前的情况, 考虑接下的一系列动作和结果.
想要做出这种AI, 通常都需要Formulate Goal - 也就是定下一个目标, 告诉AI什么是好的结果. 这种Agent的目标就是返回一系列的操作, 这个操作的Cost是最小的 - Optimal Planning若想要观测世界, 首先得需要有世界: World State - 包含了整个环境里的所有细节.而当我们解决问题的时候, 我们并不需要所有的信息: 比如在吃豆人游戏里寻路, 我们只需要知道墙壁和玩家的信息就可以了. 这种信息叫做Search State当问题变得更加复杂的时候, 我们也就需要更多的信息: 比如问题变成了吃豆人需要吃到所有的豆子.
现在我们的State就需要包含墙壁的信息, 和所有豆子的信息.State Space Graph就是以图的方式来记录所有的可能性. 并且用边来表示这些可能之间的状态转移. 然而实际上并不太可能列出完整的图, 因为可能性太多了. 但我们可以用这种思想去思考如何去解决问题.有了上面的这种构建图的方法, 我们就可以遍历一个图了:
对于一个初始节点, 找出所有连接它的节点. 对于所有连接的节点, 我们称他们为"Fringe", 这个"Fringe"可以认为是如何抵达这个节点的路线. 我们会先查看这个"Fringe"的节点对有没有包含我们的目标节点
如果没有包含, 则对这个"Fringe"再找出所有连接他们的节点, 然后更新这些"Fringe"
如此往复, 直到找到目标节点, 对应的Fringe就是如何到这个节点的路线.
稍微把上面的方法修饰一下, 就是DFS和BSF了, 比如DFS就是沿着一个Fringe一直找下去. 而BFS就是每个Fringe都更新一个Node, 然后就转到下一个Fringe了那么, 现在如果我们的路径都有cost了呢? 我们有没有什么更好的解法? 其实我们还是可以用BFS. 但不过在Expand Fringe的时候, 可以优先Expand最低Cost的Fringe的节点. 这里的最低Cost表示的是从起点到这目前节点所用的Cost最低
这种做法就叫做UCS - Uniform Cost Search. 我们这里说Uniform并不是说Cost都是相等的, 而是指我们选出Expand哪个Fringe的规则是统一的 - 永远选最低cost的这种算法如果在Cost都相等的时候, 就跟BFS一样 - 他们或多或少都有问题: 他们并不知道方向, 比如会均匀地探索整个图. Heuristics表示的就是一个函数, 告诉程序当前这个State距离目标有多远.比如最简单的一个Heuristics的方法就是Greedy Search: 说白了就是一直往目标方向走. 问题是Greedy永远只会前往看似最优解的方向, 这就可能导致明明往回走是最短的路, 结果Greedy绕了很久的路才到.那么如果UCS - Uniform Cost Search 很稳定但很慢, 但Greedy很快但不稳定, 我们能不能两个结合一下呢?在BFS中, 我们可以按照当前节点累计Cost去选择展开哪个节点. 而Greedy会选择哪个节点离目标最近来展开节点. 所以当我们把这两种Cost相加, 就得到了A* Search并且, A*并不会像之前的搜索那样, 找到目标立刻返回, 而是一样把目标节点一样加入到Queue中, 直到Pop出才会返回.但A*很依赖于Heuristics Cost, 如果时 - 也就是预测值永远小于真实的Cost - Admissibility, 则A*算法总是能找到最优解. 虽然我们可以把所有的预测值设置成0来保证这个, 但这样就会让A*和BFS一样了.除此之外, 我们还需要保证短距离的Heuristics cost也要小于等于真实的cost
<img alt="Pasted image 20250826134110.png" src="cs4300/attachments/pasted-image-20250826134110.png" target="_self">
否则就会发生上面的事情 - Consistency of Heuristics<br><img alt="Pasted image 20250826132205.png" src="cs4300/attachments/pasted-image-20250826132205.png" target="_self">
比较A和B的话, A的Cost会比B小<br>
<img alt="Pasted image 20250826132325.png" src="cs4300/attachments/pasted-image-20250826132325.png" target="_self"><br><img alt="Pasted image 20250826132413.png" src="cs4300/attachments/pasted-image-20250826132413.png" target="_self">首先, 我们需要先了解游戏是什么种类的游戏:
游戏有没有随机性
玩家有多少?
零和游戏? (输赢加在一起总数是0) 有没有战争迷雾?
总的来说, 我们可以把游戏所有的信息归类成:
起始状态
玩家
玩家做出的行为 ...
最终玩家就是一个复杂的规则, 是输入一个状态 返回一个行为
对于不同的游戏种类, Agent做出的行为可能也不一样: 如零和游戏就是尽可能地降低对手的胜率在Adversarial Search中的特殊的点是: 我们可以让Agent来预测对手的行为, 来做出更优解在之前, 我们可以把吃豆人的玩家和豆子做成一个树: 每个分支都是每个Step玩家能做出的选择, 然后选择哪个分支得分最高来做出最优解.而现在, 我们可以在这个树中加入幽灵的节点: 一层是表示玩家做出的所有行为, 一层表示幽灵所有可能的行为. 然后我们会在这个树中寻找哪个节点的得分最大, 来做出最优解.
因为通常在游戏中, 对手会想尽办法让玩家的分数变少, 所以我们可以在对手的那一层通过寻找哪个节点分数最低, 来预测对手的行为所以, 通过上面的抽象, 就出来了Minmax Search, 也就是在Search的时候, 我们会在树的玩家那一层, 选择得分最大的分支, 在对手那一层,会选择得分最小的分支, 如此往复, 直到找到得分最大的结局.
但是, 有时候选择得分最大的分支, 有可能会让对手有机会选择掉分更多的分支, 这时候我们也就需要退回去查看其他的分支: 虽然可能得分不是最多的, 但是对手让我们掉分也不是很多 - 因为我们是希望让最终的得分最多. def value(state): 如果是最终回合: 返回当前分数 如果是玩家回合(需要让分数最大): 返回max_value(state) 如果是敌人回合(需要让分数最少): 返回min_value(state) def max_value(state): 初始化分数为负无限 对于每个子节点: v = max(value(子节点), v) return v def min_value(state): 初始化分数为无限 对于每个子节点 v = min(value(子节点), v) return v
但问题是, 这样搜索太慢了: 这样搜索简直是无穷无尽, 和暴力DFS的复杂度差不多. 我们需要一个更快的算法.一种方法是限制查询的深度, 也许未来5步的预测就返回值. 还有一种方法是剪枝: 既然对手永远会选择最低的分数的分支, 那么我们就可以把一些分数高于最低分支给删掉, 因为对手一定不会让我们选那个高分的分支// α就是目前为止Max玩家所探索到的最佳选择
// β就是目前为止Min玩家所探索到的最佳选择
// 在根节点第一次调用value时, α=-∞ β=∞ def value(state, α, β): 如果是最终回合: 返回当前分数 如果是玩家回合(需要让分数最大): 返回max_value(state, α, β) 如果是敌人回合(需要让分数最少): 返回min_value(state, α, β) def max_value(state, α, β): 初始化分数v为负无限 对于每个子节点: v = max(value(子节点, α, β), v) 如果 v ≥ β, 则直接返回v --因为如果值大于这个, Min也知道这件事, 不会让你选 α = max(α, v) return v def min_value(state, α, β): 初始化分数v为无限 对于每个子节点: v = min(value(子节点, α, β), v) 如果 v ≤ α, 则直接返回v β = min(β, v) return v
但万一对手不是很聪明, 它有时候并不会阻止我们选更优的选择, 我们如果仍然用MinMax Search的话, 就可能错过更优的解对于这种, 我们可以把对手的决策抽象成一种概率, 然后去计算Expectation (期望), 但我们的选择仍然是Max决策def value(state): 如果是最终节点, 则返回节点值 如果是Max Agent(玩家), 则执行max-value(state) 如果是Exp Agent(对手), 则执行exp-value(state) def exp-value(state): 期望值v = 0 对于每个分支, 把概率*期望 求所有概率*期望的和并返回 fef max-value(state): 初始化分数为负无限 对于每个子节点: v = max(value(子节点), v) return v
但如果现在, 如果是多个玩家, 不再是零和游戏, 我们应该怎么运算? 因为在这种情况下, 某个玩家的目标可能不再是Minimize你的Score了, 他可能是帮助你的玩家, 或者是三个玩家都想让自己的分数最高]]></description><link>cs4300/planning.html</link><guid isPermaLink="false">CS4300/Planning.md</guid><pubDate>Tue, 02 Sep 2025 19:27:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250826134110]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250826134110.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250826134110.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250826134110.png</guid><pubDate>Tue, 26 Aug 2025 19:41:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250826132413]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250826132413.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250826132413.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250826132413.png</guid><pubDate>Tue, 26 Aug 2025 19:24:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250826132325]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250826132325.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250826132325.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250826132325.png</guid><pubDate>Tue, 26 Aug 2025 19:23:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250826132205]]></title><description><![CDATA[<img src="cs4300/attachments/pasted-image-20250826132205.png" target="_self">]]></description><link>cs4300/attachments/pasted-image-20250826132205.html</link><guid isPermaLink="false">CS4300/attachments/Pasted image 20250826132205.png</guid><pubDate>Tue, 26 Aug 2025 19:22:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Interpreter]]></title><description><![CDATA[解释器就是一个程序, 他会输入一个程序, 然后输出一个值. (说白了就是运行这个程序)
而在这里, 我们会用Shplait来写这个解释器, 而输入的程序会以Moe的格式/语言输入进去目前为止, 我们可以先创建一个简单的Moe语言, 这个Moe语言只支持Int的加或乘, 我们可以输入一个加或乘的数学式子, 然后得到一个值. 这些数学式子可以被称为 "程序": 比如1+1就是一个程序. 而程序的值就是2. 或者, 我们可以直接输入一个数字. 这个数字本身也算是一个 "程序"如果我们想要用Shplait来读取这个Moe表示的程序, 首先我们至少需要知道怎么能用Shplait中表示Moe的程序.比如2是个程序, 2+1也是个程序, 而2 + (1 * 3)也是个程序(两个程序嵌套). 这就像我们之前写的<a data-tooltip-position="top" aria-label="如何设计一个程序 > Example 5 GUI" data-href="如何设计一个程序#Example 5 GUI" href="cs3520/如何设计一个程序.html#Example 5 GUI" class="internal-link" target="_self" rel="noopener nofollow">嵌套代码</a>一样type Exp | intE(n :: Int) //E表示这个int是Expression
| plusE(l :: Exp, r :: Exp) | multE(l :: Exp, r :: Exp) plusE(intE(1), intE(1))
plusE(intE(3), multE(intE(2), intE(5)))
然后我们写这个解释器也跟原来的套路一样: 当类型有套娃, 则处理它的函数也需要递归调用fun interp(a :: Exp) :: Int: match a | intE(n): n | plusE(l, r): interp(l) + interp(r) | multE(l, r): interp(l) * interp(r)
那么, 我们该如何把Moe语言中的1+1转换成Shplait语言中的plusE(intE(1), intE(1))呢?<br>
所以, 我们就需要用Shplait写一个神奇的函数, 它能输入'1+1'(在Shplait里是<a data-tooltip-position="top" aria-label="Shplait 入门 > Syntax" data-href="Shplait 入门#Syntax" href="cs3520/shplait-入门.html#Syntax" class="internal-link" target="_self" rel="noopener nofollow">Syntax</a>), 然后输出plusE(intE(1), intE(1))而这里, 我们就可以用到Syntax中的几个特殊的变体: 可以利用match来把Syntax切成两半fun parse(s :: Syntax) :: Exp: .... match s | .... | '$left * $right': .... parse(left) .... .... parse(right) .... | .... ....
但是, 也有特殊情况: 是单个数字, 这样我们需要先检查输入的Syntax是个单个数字, 还是一个式子.并且, 由于乘法和加法有优先级, 我们会希望先做乘法, 然后再做加法.
由于是递归运算, 所以我们需要反过来: 先Parse加法, 然后得到left + right, 然后left或right再做处理. 如right最终会parse成乘法, 这样的结果就是先乘后加有意思的是, 这种运算也是支持括号的:match '(1 + 3) * 4' | '$left + $right': [] | '$left * $right': [left, right] ⇒ ['(1 + 3)', '4']
比如这个例子, 就算我们是先Parse的加法, 然而实际结果会是Parse成left * right, 这是因为当试图Parse成加法的时候, 两边都不是一个正确的Syntax了, 所以就忽略并选择Parse成乘法了如果一个编程语言只有数学运算的话, 是不是有点太无聊了?我们需要让我们的Moe语言也拥有函数调用的能力 - 虽然在表达式中定义函数是不被允许的, 但我们可以在表达式中去调用函数, 如1 + double(4)得到的结果就是9当然, 因为有了函数, 那也要有变量, 所以用户可能输入double(x). 那么现在我们就需要定义新的Expression Type了:type Exp
| intE(n :: Int)
| idE(s :: Symbol)
| plusE(l :: Exp, r :: Exp)
| multE(l :: Exp, r :: Exp)
| appE(s :: Symbol, arg :: Exp)
用这样的类型, x + 2 就会被解释成plusE(idE(#'x), intE(2))然后我们可以创建一个新的类型, 专门用来表示函数定义:type FunDef
|fd(name :: Symbol, arg :: Symbol, body :: Exp)
这样, 如果我们用Moe语言输入fun plus_two(x): x + 2
就会被解释成fd(#'plus_two, #'x, plusE(idE(#'x), intE(2)))
当我们在moe语言中调用plus_two的时候, 则会使用Exp的appE变体:appE(#'plus_two, intE(9))
在真正的Moe语言中, 并不会单纯的只有一个函数定义或者函数调用, 他们是结合起来的:fun double(x): x + x fun quadruple(x): double(double(x)) quadruple(2)
在Shplait中应该被解读成一系列的fd和Expression[fd(#'double, #'x, plusE(idE(#'x), idE(#'x))), fd(#'quadruple, #'x, appE(#'double, appE(#'double, idE(#'x))))] appE(#'quadruple, intE(2))
为了执行和解析输入进来的函数, 我们需要下面这些东西interp :: (Exp, Listof(FunDef)) -&gt; Int //通过函数定义去求Expression的值
get_fundef :: (Symbol, Listof(FunDef)) -&gt; FunDef //从一系列的函数定义中找出需要的那个
subst :: (Exp, Symbol, Exp) -&gt; Exp //由于输入进来的函数定义通常是变量表示的, 我们需要在运算的时候把这些变量替换成真实的数值. //如把函数中的x都替换成3, 就是subst(parse('3'), #'x, parse('x'))
首先我们需要把输入进来的函数解析成函数定义fun parse_fundef(s :: Syntax) :: FunDef: match s | 'fun $name($arg): $body': fd(syntax_to_symbol(name), syntax_to_symbol(arg), parse(body)) | ~else: error(#'parse, "invalid input: " +&amp; s)
我们再完成get_fundef, 来帮助我们在一系列的函数定义中找到需要的那个函数定义get_fundef :: (s :: Symbol, defs :: Listof(FunDef)) :: FunDef: match defs | [] : error(#'get_fundefs,"undefined function: " +&amp; s) | cons(df, rst_defs): if fd.name(df) == s | df | get_fundef(s, rst_defs)
然后我们完成subst的部分fun subst(what :: Exp, for :: Symbol, in :: Exp): match in | intE(n): in | idE(s) : if s == for //如果输入的是个id, 则去跟要替换的目标做对比 | what | in | plusE(l, r): plusE(subst(what, for, l), subst(what, for, r)) | multE(l, r): multE(subst(what, for, l), subst(what, for, r)) | appE(s, arg): //如果输入是个fun, 则把fun里面的Expression替换 appE(s, subst(what, for, arg))
然后是完整的parsefun parse(s :: Syntax) :: Exp: cond | syntax_is_integer(s): intE(syntax_to_integer(s)) | syntax_is_symbol(s): idE(syntax_to_symbol(s)) | ~else: match s | '$left + $right': plusE(parse(left), parse(right)) | '$left * $right': multE(parse(left), parse(right)) | '$sym($arg)': appE(syntax_to_symbol(sym), parse(arg)) | '($e)': parse(e) | ~else: error(#'parse, "invalid input: " +&amp; s)
最后, 我们终于可以升级之前写的interp了: 现在他可以不仅仅接受Expression, 还可以接受一系列函数了:fun interp(a :: Exp, defs :: Listof(FunDef)) :: Int: match a | intE(n): n | idE(s): error(#'interp, "free variable: " +&amp; s) | plusE(l, r): interp(l, defs) + interp(r, defs) | multE(l, r): interp(l, defs) * interp(r, defs) | appE(s, arg): block: def a_def = get_fundef(s, defs) interp(subst(intE(interp(arg, defs)), fd.arg(a_def), fd.body(a_def)), defs) //先运算出函数里面的Expression的值, 再从int转回Exp, 然后再通过subst再次把这个值(exp)替换到外层函数中后再interp一次
最终的流程就是:
用户的Moe有定义了函数, 并且执行的程序中有函数的func call
定义的这些函数被parse_fundef解析成了一个个的函数定义, 最终组成Listof(FunDef)
输入进来的Expression被parse递归式地解析成了一系列的Exp类型的嵌套
这个Exp类型的嵌套被输入进了interp函数中, 然后被进行match和计算
如果这个Exp被match到了appE, 表示他会被执行函数调用. 则会先用get_fundef找到对应的函数, 然后对这个函数的arg执行interp操作, 确保这个函数的参数已经是一个数值而不是Exp
接着再用intE把函数的参数Exp的结果从int转换回Exp, 然后用subst把所有函数的变量替换成我们输入进去的参数并再次进行interp
]]></description><link>cs3520/interpreter.html</link><guid isPermaLink="false">CS3520/Interpreter.md</guid><pubDate>Tue, 26 Aug 2025 05:47:07 GMT</pubDate></item><item><title><![CDATA[如何设计一个程序]]></title><description><![CDATA[
思考数据需要用什么数据结构来保存 是否需要用到type? 写下一些预期结果 使用check 创建一个模板 如用到type的话, 就可能需要用match
需不需要提取对象的变量?
有没有递归调用, 数据引用等? - 因为通常如果数据结构是递归的形式, 则函数就有可能用到递归的调用(如List) 写出完整的代码
比如我们需要写一个程序去追踪曲奇饼干的数量. 第一步的答案显而易见: 输入一个Int, 返回一个Int 第二步则是写下预期的结果:check: eat_cookie(10) ~is 9
check: eat_cookie(0) ~is 0
第三步就需要设计模板了:fun eat_cookie(n::Int): ... n ...
最后就是写出完整的函数:fun eat_cookie(n :: Int): max(n-1,0)
因为是二维的平面, 所以需要xy坐标:type Posn
| posn(x::Int, y::Int) flip :: Posn-&gt;Posn
接下来是期望结果check: flip(posn(1, 17)) ~is posn(17, 1)
因为用到了type, 我们就需要用稍微繁琐一点的步骤去获取变量: fun flip(p :: Posn): ... posn.x(p) ... ... posn.y(p) ... fun flip(p :: Posn): match p | posn(x, y) : ... x ... y ...
接下来就是完成函数:fun flip(p :: Posn): match p | posn(x, y) : posn(y, x)
现在, 我们想去追踪一个蚂蚁, 追踪它的重量和位置type Ant
| ant(location :: Posn weight :: Int) is_ant_home :: Ant -&gt; Boolean check: is_ant_home(ant(posn(0,0),1)) ~is #true
由于Ant中有个其他的type, 也许在检查蚂蚁是否在原点的时候, 单独写一个Posn的函数是更好的方法:fun is_ant_home(a :: Ant): match a | ant(loc, wgt): ... is_home(loc) ... fun is_home(p: Posn): match p |posn(x,y): ...x ... y
fun is_ant_home(a :: Ant): match a | ant(loc, wgt): is_home(loc) fun is_home(p: Posn): match p |posn(x,y): x == 0 &amp;&amp; y == 0
假设我们有一群鱼, 每个有重量, 我们想定义一个喂鱼的函数, 让所有重量加一因为鱼群, 所以就需要List存储. 我们可以认为List也是一个自带的类型:type Listof(Int)
|[]
|cons(n::Int, Listof(Int))
我们会发现, 这个定义里面就包含了他自身 - 这个就表明在处理这样的数据的时候, 我们可以用递归的方法去处理, 分别处理数据的两种情况fun feed_fish(lst :: Listof(Int)): match lst |[]:[] |cons(fst, rst): cons(fst+1, feed_fish(rst))
现在逐渐变得有趣起来了: 我们想开发GUI:type GUI
| label(text :: String)
| button(text :: String, is_enabled :: Boolean)
| choice(items :: Listof(String), selected :: Int) //读取GUI的类然后获取里面的文字
fun read_screen(g :: GUI) :: Listof(String): match g | label(t): [t] | button(t, e): [t] | choice(i, s): i //一些测试
check: read_screen(label("Hi")) ~is ["Hi"]
check: read_screen(button("Ok", #true)) ~is ["Ok"]
check: read_screen(choice(["Apple", "Banana"],0)) ~is ["Apple", "Banana"]
当然, 现在有了这些组件, 我们还需要规定怎么把他们组合起来//现在新版的GUI支持表示结构了
type GUI
| label(text :: String)
| button(text :: String, is_enabled :: Boolean)
| choice(items :: Listof(String), selected :: Int)
| vertical(top :: GUI, bottom :: GUI)
| horizontal(left :: GUI, right :: GUI)
这就导致了: 现在这个GUI里有一些变体会引用自己, 所以read_screen也需要递归地去调用自己去处理这种变体fun read_screen(g :: GUI) :: Listof(String): match g | label(t): [t] | button(t, e): [t] | choice(i, s): i | vertical(t, b): append(read_screen(t), read_screen(b)) | horizontal(l, r): append(read_screen(l), read_screen(r))
现在, 我们想设计一个按按钮的功能, 也就是输入一个按钮和一个名字, 让他的boolean值变成truecheck: enable_button(button("OK", #true), "OK") ~is button("OK", #true)
check: enable_button(button("OK", #false), "OK") ~is button("OK", #true)
check: enable_button(button("OK", #false), "Cancel") ~is button("OK", #false)
check: enable_button(choice(["Apple", "Banana"], 0), "OK") ~is choice(["Apple", "Banana"], 0)
check: enable_button(horizontal(button("OK", #false), button("Cancle", #false)), "OK") ~is choice(horizontal(button("OK", #true), button("Cancle", #false)), "OK")
fun enable_button(g :: GUI, name :: String) :: GUI: match g | label(t): g | button(t, e): button(t, e || t == name) | choice(i, s): g | vertical(t, b): vertical(enable_button(t, name), enable_button(b, name)) | horizontal(l, r): horizontal(enable_button(l, name), enable_button(r, name))
但现在, 由于GUI太过复杂, 我们想要知道某个组件到底是在第几层, 所以创建了一个函数, 把gui传进去后就会让所有GUI的文字前面加个数字, 表示这个GUI组件的深度. fun show_depth(g :: GUI) :: GUI: match g | label(t): .... t .... | button(t, e): .... t .... e .... | choice(i, s): .... i .... s .... | vertical(t, b): .... show_depth(t) .... show_depth(b) .... | horizontal(l, r): .... show_depth(l) .... show_depth(r) ....
如果我们这么写模板的话, 就会发现, 似乎这样并不能做到显示深度: 我们不知道递归调用了几次, 所以就需要一个计数器:fun show_depth_at(g :: GUI, n :: Int) :: GUI: match g | label(t): label(n +&amp; " " +&amp; t) | button(t, e): button(n +&amp; " " +&amp; t, e) | choice(i, s): g | vertical(t, b): vertical(show_depth_at(t, n + 1), show_depth_at(b, n + 1)) | horizontal(l, r): horizontal(show_depth_at(l, n + 1), show_depth_at(r, n + 1))
在设计程序的时候, 就遵循上面的步骤就行
可以从模板中看出需要match什么, 用不用调用递归等
如果调用递归的话, 思考用不用计数器
复用函数, 或者写helper Functions
]]></description><link>cs3520/如何设计一个程序.html</link><guid isPermaLink="false">CS3520/如何设计一个程序.md</guid><pubDate>Mon, 25 Aug 2025 17:52:26 GMT</pubDate></item><item><title><![CDATA[Shplait 入门]]></title><description><![CDATA[Shplait是一个空格敏感语言: 不像C++那样换行无所谓, 在这里面换行可能会导致报错. 如果必须要写成两行, 则第二行需要加一个缩进(10000 + 2000)
在这个语言中, 有bool: #true
string: "apple"
symbol: #'apple
syntax: 'apple'
list: [1,2,3,2+2]
这里的Symbol并不是变量, 仅仅是符号本身. 他们在比较的时候, 会很高效, 并且他们比字符串轻syntax通常是用来储存源代码的: 比如我们在里面输入'0001+ 1', 则syntax会自动把这个内容转化成1 + 1
可以看到, 它自动删掉了一些没有必要的元素, 并让排版更整齐了对于 Syntax来说, 他有个match的变体:match '1+2'
| '$n + $m' : [n,m]
通过这种方法, 我们可以获取到Syntax中的数字不过这样获取到的List中的元素仍然会是Syntax种类. 所以我们需要使用syntax_to_integer(n)来把syntax变成int. 或者转换成symbol也可以match '1+2'
| '$n + $m' : [syntax_to_integer(n) + 100, syntax_to_integer(m)] match 'apple + banana'
| '$n + $m' : [syntax_to_symbol(n), syntax_to_symbol(m)] match 'apple + "banana"'
| '$n + $m' : [syntax_is_symbol(n), syntax_is_string(m)]
对于List, 有两个基础操作: append() 和cons()
append是输入两个List, 然后把第二个List衔接在第一个List的后面.
cons是输入一个元素和一个List, 然后把这个元素放在List的第一个first(&lt;list&gt;)会返回List的第一个元素, 而rest(&lt;list&gt;)会返回除了第一个所有的元素在Shplait中, 条件语句和其他编程语言略有不同:if "apple" == "banana" | #'yes | #'no if "apple" == "banana" | #'yes | #'no
在这里, |表示的就是可以新起一行, 并且新起的一行必须跟上面的代码缩进一致用cond可以返回第一个满足要求的条件cond
|1&lt;2 :#'less
|1&gt;2 :#'more
|2==2 :#'equal cond
|1&lt;2 : #'less
|1&gt;2 : #'more
|2==2 : #'equal cond
|1&lt;2 : #'less
|1&gt;2 : #'more
| ~else : #'equal
可以定义常量或者函数:def pi = 1 + 2 fun circle_area(r): pi * r * r def pi ::Int 1 + 2 fun circle_area(r :: Int) :: Int: pi * r * r
并且由于pi是个int, 所以Shplait会自动把计算面积的函数当做一个输入和输出都是int的函数有些时候, 我们想让定义不是全局的, 只在某个范围起效, 我们可以:fun circle_area(r): block: def pi = 1 + 2 pi * r * r
我们可以用type关键词来定义自己的类:type Groceries = Listof(String)
def shopping_list :: Groceries = ["Milk", "Cookies"]
当然仅仅这样似乎没啥用, 只是把List换了个名字而已. 我们可以更复杂一些 - 创建出一个类type Animal
| tiger(color :: Symbol, stripe_count :: Int)
| snake(color :: Symbol, weight :: Int, food :: String)
这样, 我们就建立了一个动物类, 和它的两个变体: 分别是两个函数&gt; tiger(#'orange, 1+2)
- Animal
tiger(#'orange, 3)
如果要获取动物的颜色的话, 就需要用cond先分辨出它是什么类型, 然后再用对应变体的名字取获得颜色(变量)fun animal_color(a :: Animal) :: Symbol : cond | a is_a tiger: tiger.color(a) | a is_a snake: snake.color(a)
还有一种更简单的方法, 就是match, 他可以获得这个变体的每个变量, 然后在里面使用它们fun animal_color(a :: Animal) :: Symbol : match a |tiger(c, sc): c |snake(c, w, f): c
当然, 不仅仅他可以match变体, 也可以match不同的情况:fun has_tiger(lst :: Listof(Animal)): match lst |[]: #false |cons(a, lst_rest): a is_a tiger || has_tiger(lst_rest)
因为对于一个List来说, 要不他就是空的, 要不他就是由第一个和剩下的元素用cons函数组成的. 所以只需要检查第一个元素, 再递归地把剩下的元素调用检查函数就行需要打开Language -&gt; Choose Language -&gt; Detail -&gt; Syntactic test suite coverage
在打开之后, 如果我们点击运行按钮, 就可能看到很多变量是黑色的 - 这表示这些变量没有被读取过并且, 我们可以搭配check 使用check: has_tiger([]) ~is #false
由于需要在函数声明后再调用, 所以通常check是写在最后面. 但是如果想让check写在最开头, 我们可以把test放在module test中. Rocket会在点击运行后自动运行test module.module test: check: has_tiger([]) ~is #false check: has_tiger([tiger(#'orange,3)]) ~is #true ]]></description><link>cs3520/shplait-入门.html</link><guid isPermaLink="false">CS3520/Shplait 入门.md</guid><pubDate>Wed, 20 Aug 2025 02:19:09 GMT</pubDate></item><item><title><![CDATA[Programming Languages]]></title><description><![CDATA[ 这节课主要注重的是编程语言的理念, 并且尤其注重于函数式编程的概念Interpreter: 可以认为是一个函数, 可以输入一个问题, 得到一个答案, 如1+1=2如果我们想要自己设计一个Interpreter, 这节课会使用Shplait, 是Racket的一种变种. 而Racket是从Lisp演变而来.在这个课程中, 递归是非常常见的: 如一个数据类型中会包含自己, 或者运算的时候会调用自己.]]></description><link>cs3520/programming-languages.html</link><guid isPermaLink="false">CS3520/Programming Languages.md</guid><pubDate>Mon, 18 Aug 2025 22:16:01 GMT</pubDate></item><item><title><![CDATA[Final]]></title><description><![CDATA[
c) Turing machines have unrestricted memory access.
c) It can have infinitely many states.
b) decidable
b) decidable.
b) M accepts w by looping.
c) An ordinary PDA (with one stack).
d) If a language is Turing-recognizable, then its complement must also be Turing-recognizable.
e) none of the above.
c) is the only one that’s not decidable.
a) Yes.
c) A̅ is not Turing-recognizable.
c) The set of all problems that can be solved by a nondeterministic algorithm in polynomial time.
d) It is possible that some NP problems cannot be solved in exponential time.
b) Halting problem
b) No
Implementation-Level Description for On input :
Scan the string to check if the string is in the form of , if not, reject
Scan from the left and find the first unmarked a. If there is no unmarked a, go to step 4.
Otherwise, mark this a (for example, by changing it to X). Move right until finding the first unmarked b. If there is no unmarked b, reject (number of as and bs do not match).
Otherwise, mark this b (for example, by changing it to Y). Return to the beginning of the tape and repeat from step 1.
Once all as have been marked: Scan the tape to check if there are any unmarked bs left. If there are, reject.
If all symbols are marked (only Xs and Ys remain), accept. decidable languages is closed under set differenceSuppose and are both decidable languages.
We want to show that is also decidable.Since and are decidable, there exist Turing machines and that decide and , respectively.
That is: always halts and accepts if the input is in , and halts and rejects otherwise. always halts and accepts if the input is in , and halts and rejects otherwise.
We can construct a new Turing machine that decides as follows:
On input string :
Run on input . If rejects, then reject. Otherwise (if accepts), run on input . If accepts, then reject.
If rejects, then accept. Emptiness Problem
<img alt="Pasted image 20250428144419.png" src="cs3100/cheatsheet/attachments/pasted-image-20250428144419.png" target="_self">\Undecidable Problem<br>
<img alt="Pasted image 20250428144506.png" src="cs3100/cheatsheet/attachments/pasted-image-20250428144506.png" target="_self">
Thus, a contradiction. is undecidable
On input :
Construct a new Turing machine that behaves as follows: On input : If , accept immediately.
If , simulate . If accepts , then accept.
If rejects or loops forever, then reject or loop accordingly. Intuitively, accepts all strings except possibly : If accepts , then accepts everything (i.e., ).
If does not accept , then misses , and . Run on input : If accepts (i.e., ), then accept .
If rejects (i.e., ), then reject . Three PartitionGiven a guessed partition of into three subsets , , and :
We can check that , , and are disjoint and their union is .
We can compute the total sum of each subset.
We can verify that the sums are equal.
All these steps take polynomial time in the size of .
Therefore, the 3-way Partition problem is in NP. (b) The problem is NP-Hard
We reduce the known NP-Complete Partition problem to the 3-way Partition problem.Given an instance of Partition:
Compute the total sum of all elements in .
Construct a new set .
Key idea:
If can be partitioned into two subsets with equal sum ,
then in , we can: Take the two subsets from ,
And assign the new element as the third subset. Each subset will have total sum .Thus: is partitionable is 3-way partitionable.
Since the reduction is polynomial time, and Partition is NP-Complete, the 3-way Partition problem is NP-Hard.]]></description><link>cs3100/cheatsheet/final.html</link><guid isPermaLink="false">CS3100/CheatSheet/Final.md</guid><pubDate>Mon, 28 Apr 2025 21:35:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Computability]]></title><description><![CDATA[Computability Theory包含了:
Capacity - 可以解决的问题(也就是<a data-tooltip-position="top" aria-label="Turing Machine > Turing Machine Recognizers and Deciders" data-href="Turing Machine#Turing Machine Recognizers and Deciders" href="cs3100/turing-machine/turing-machine.html#Turing Machine Recognizers and Deciders" class="internal-link" target="_self" rel="noopener nofollow">Decidable</a>)
Limitation - 无法解决的问题, 也就是Undecidability
Complexity Theory是对于上面说的可解决的问题来说:
问题的解是可行的 - 用多项式的时间内就可以解出来
问题的解决是不行的 - 需要次幂级的时间解出来
一个例子就是给定一个多项式 (如), 我们已知它的解一定是整数, 我们是否可以设计出一个Decider图灵机来计算出结果?实际上, 在1970年, 已经有数学家证明出, 这个问题不是Decidable - 也就是设计出来的图灵机可能会无限运行下去, 我们不知道它什么时候会得到结果
但如果这个多项式中, 只有一个变量, 则我们确实是可以设计出一个Decider图灵机, 因为它会有一个upper bound, 我们只要让图灵机循环到这个upper bound, 就一定能得到答案.还有一个问题就是, 我们能不能设计一种算法, 来检测我们写的代码最终会不会输出Hello World? 实际上, 这是不可能的, 因为我们是不可能在那一直等待程序运行, 直到结束看有没有输出: 万一程序里是在尝试解决上面的多项式问题, 如果解出来就输出Hello World呢?所以说, 这是不可能设计出来的算法.再进一步说, 我们同样也不能知道给定的一个程序, 它最终会不会终止, 因为程序里面可能会存在一些可能永远都解决不出来的问题.实际上, DFA, 甚至图灵机其实是可以被encoding成二进制文字的.现在我们会想: 会不会存在一个Decidable 语言, 并且它需要输入一个字符串, 里面包含了一个另外的DFA , 和一个输入, 如果这个被接受, 则这整个输入都在的语言中
这个证明非常简单, 如果我们想证明是Decidable, 我们只需要设计一个图灵机来判断, 如果这个图灵机是Decider, 则这个语言就是Decidable.<br>
<img alt="Pasted image 20250317141816.png" src="cs3100/computability/attachments/pasted-image-20250317141816.png" target="_self">
因为我们在里面运行的是DFA, 所以它没有陷入死循环的概率, 这图灵机自然也就是Decider相似的, 我们如果想证明有没有一个Decidable , 它能判断一个NFA会不会接受输入:<br>
想证明的话, 可以直接先通过之前学的方法, <a data-tooltip-position="top" aria-label="Finite Automata Theory > NFA -> DFA" data-href="Finite Automata Theory#NFA -> DFA" href="cs3100/automata/finite-automata-theory.html#NFA -> DFA" class="internal-link" target="_self" rel="noopener nofollow">把NFA转换成DFA</a>, 然后再通过上面的方法去检测就行了
虽然 NFA 到 DFA 可能导致状态数指数级增加, 但由于状态仍然是有限的, 这不会影响判定问题的可判定性
把NFA 转换成等价的DFA 运行一个图灵机对于输入.
如果接受, 则接受; 否则拒绝.
<br><img alt="Pasted image 20250317142846.png" src="cs3100/computability/attachments/pasted-image-20250317142846.png" target="_self">如果把我们现在要看CFG呢, 语言仍然会是Decidable吗?
因为CFG (对应的机器是PDA), 我们并不能保证它最终一定会停下 - 有些PDA不是Decider, 我们也就无法像之前的那种方法先把PDA转换成DFA.<br>这时候, 就可以用<a data-tooltip-position="top" aria-label="Context Free Languages > Chomosky Normal Form(CNF)" data-href="Context Free Languages#Chomosky Normal Form(CNF)" href="cs3100/automata/context-free-languages.html#Chomosky Normal Form(CNF)" class="internal-link" target="_self" rel="noopener nofollow">CNF</a>了: 由于CNF有个公式是对于长度的字符串, 必须要步, 这下就知道了我们最终目标只需要检查那么多步就可以了
我们可以构造一个广度优先搜索的机器, 遍历完步中所有的可能性, 就能知道这个字符串有没有在这个CFG中.<br>
<img alt="Pasted image 20250319135158.png" src="cs3100/computability/attachments/pasted-image-20250319135158.png" target="_self">现在, 我们有一个语言, 是由所有满足 接受 的图灵机-输入对 组成的集合
在之前, 我们都是用一个图灵机去检测其他Machine是不是Decider, 但现在我们想测试的是图灵机它自己.
实际上, 它和 Halting Problem 有密切联系, 并且也 不可判定（Undecidable）<br>
<img alt="Pasted image 20250319143916.png" src="cs3100/computability/attachments/pasted-image-20250319143916.png" target="_self">不过呢, 这个是个Turing-recognizable - 因为图灵机自身就是Turing-recognizor, 所以我们直接去用一个模拟器模拟这个去看它接不接受字符串 运行 在输入 上
如果 接受 ，那么 也接受.
但如果 拒绝 或不终止，那么 无法保证一定终止.
这里有意思的就来了: 我们是在用一个图灵机去模拟另一个图灵机, 这真的可以吗?
实际上, 图灵机它是可以做到的: 这就有了 Stored program computer的概念 - 也就是现在电脑的基石
因为对于以前, 每个电脑都是用来做专门的事情, 但有了这个概念, 我们可以用同一个计算机根据不同的规则来进行不同的事情, 而不是想那些DFA只能干设置好的一件事情如果把取反, 得到的新语言, 甚至不是Turing Recognizable为了证明这点, 我们需要用一个新语言, 这个语言只有在和都是Recognizable的时候才会是Decidable<br>
<img alt="Pasted image 20250319144523.png" src="cs3100/computability/attachments/pasted-image-20250319144523.png" target="_self"><br>至此, 我们就证明了, DFA, NFA, CFG都是decider - 注意, PDA它自己不是Decider, 但我们可以把一个PDA<a data-tooltip-position="top" aria-label="Context Free Languages > CFG == PDA" data-href="Context Free Languages#CFG == PDA" href="cs3100/automata/context-free-languages.html#CFG == PDA" class="internal-link" target="_self" rel="noopener nofollow">转换成</a> 等价的CFG.这里我们的目标是为了证明是否存在一个Decidable语言, 它是包含了所有不接受任何string的DFA<br>
<img alt="Pasted image 20250317143252.png" src="cs3100/computability/attachments/pasted-image-20250317143252.png" target="_self">那这个呢? 如果我们想知道一个CFG能不能生成字符该怎么办?如果我们直接从起始变量往下查看, 看有没有Terminals, 很显然这就不是Decidable - 执行到天荒地老说不定也走不出循环. 但我们可以反着来: 从Terminal反向查找Variables, 并把所有能变成它的Variables标记. 如此往复, 直到没有新的Variable被被标记就停下.
这时候, 如果起始变量被标记了, 则说明这个起始变量是可以变成字符串的. 标记所有在G中的Terminals
标记所有能变成被标记的Variables / Terminals 的 Variables. 如, 如果被标记, 也同样标记A. 直到所有的变量已被标记
如果起始的变量也被标记了, 则接受.
这里的目标是为了证明是否存在一个Decidable语言, 它里面的值都是一对, 这一对是表示两个不同的DFA, 但他们会辨识同样的语言<br><img alt="Pasted image 20250317144241.png" src="cs3100/computability/attachments/pasted-image-20250317144241.png" target="_self">实际上, 这个不是一个Decidable语言. 我们想证明的是可被图灵识别的, 并且如果这个语言会接受两个CFG会接受不同的语言
所以我们就可以构建一个图灵机去做以下事情: 让作为的所有Terminals
对于每个字符串, 以string order排序 运行对于输入
运行对于输入
如果接受了其中一个拒绝了另一个, 则接受 String Order: 比如
这里用的是我们之前学的来去决断一个CFG接不接受特定的String<br><img alt="Pasted image 20250326135846.png" src="cs3100/computability/attachments/pasted-image-20250326135846.png" target="_self"><br>
<img alt="Pasted image 20250326135921.png" src="cs3100/computability/attachments/pasted-image-20250326135921.png" target="_self">
这里实际上是另外一种并行计算字符串的方法: 让我们可以在无限数量的字符串上并行: 也就是在长度的字符串上运行一步, 然后再长度的的字符串上运行两步, 以此类推Reduction就是去把一个问题A转换成一个问题B, 这样就可以用任意的一个Solver(如Decider或Recognizer)去解决B, 同样这些Solver也就可以去识别问题A.
当遇到上面这种情况, 我们可以说:
A reduces to B
A can be reduced to B
A is reducible to B
如果问题A可以被简化成B, 我们就可以说: 问题A没有比B难这个比较抽象, 来举一些实际的例子:因为知道登录密码并不是登录电脑的唯一解 - 你也可以直接黑入账户.<br>
之前已经证明过, 我们可以把<a data-tooltip-position="top" aria-label="Finite Automata Theory > NFA -> DFA" data-href="Finite Automata Theory#NFA -> DFA" href="cs3100/automata/finite-automata-theory.html#NFA -> DFA" class="internal-link" target="_self" rel="noopener nofollow">NFA转换成DFA</a>
通过归约法, 我们可以通过已知的问题证明未知的东西, 如我们已知是不能决断的问题, 我们可以把他简化成问题, 得到的问题自然也是不能决断的问题上面的思想可以说是: 假装自己有了一个牛逼的黑盒，然后看它是否能偷偷地解决世界难题 , 如果可以，那说明你肯定在做梦 - 所以那个黑盒压根就不可能存在现在我们可以用上面的归约法来证明不是决断的:
因为Undecidable的问题是, 所以我们可以试图把问题A ()简化成问题B ()所以就可以用Proof By Contradiction
假设存在判定机 , 它可以决断停机问题
那么同样的, 我们也可以构造一个 使其判定 : 运行对于
如果拒绝, 则拒绝
如果接受, 则运行M去检测直到停机 - 因为已经告诉我们了一定会停机
如果接受, 则接受, 如果拒绝, 则拒绝
这样, 我们之前明明证明过不是决断问题, 但这里却又可以决断了, 说明出现了悖论: 所以不是个决断问题我们仍然想证明不是决断的:
同样可以用Proof By Contradiction:
假设一个图灵机, 它可以决
那么同样的, 我们也可以用这个来做出一个图灵机, 来决断: 基于和, 我们构建一个新的图灵机:
构造 一个新图灵机 ： 只接受一个特定输入 。
如果输入 ，则立即拒绝。
如果输入 ，则模拟 的运行，并按照 的接受/拒绝来决定 的行为。
这样， 的语言 为空当且仅当 不接受 。 运行去检测, 也就是去测试
如果接受(), 则拒绝, 如果拒绝(), 则接 受
这样, 如果我们可以决断的话, 我们也会同样可以决断, 导致悖论假设有一个判定器 ，它可以决定某个图灵机的语言是否是正则的，即：我们可以用此来证明是Undecidable的:
构造一个新图灵机 ，使得： 输入一个字符串 如果 形如 ，就接受
否则，模拟 运行在输入 上，如果 接受 ，也接受 这里的和跟没有半毛钱关系, 只要接受, 任何都会被接受!
否则，拒绝
或者说 观察 的行为： 如果 不接受 , 那么 只接受 ，这是一个非正规语言
如果 接受 , 那么 就接受所有输入（因为模拟分支总是接受），所以 ，是个正规语言 现在我们把 输入到图灵机 ，来判断 是否正规： 如果 接受，说明语言是正规语言 → 所以 接受 如果 拒绝，说明语言不是正规语言 → 所以 不接受 因为我们把原来的问题经过一层包装, 让他变成, 只要接受, 就输出正则语言, 否则输出非正则语言. 所以通过黑盒, 我们就能神奇的知道这个最终有没有接受这个字符串 - 当然是不可能的 - 因为这个判定器就是假设出来的证明 decides 如果 , 那么就会接受, 导致, 也就是个正则语言, 所以, 会接受
如果 , 那么, 也就不是个正则语言, 会拒绝 是所有“语言相同”的图灵机对的集合。
换句话说，我们想知道：两个图灵机接受的语言是否完全一样
现在我们需要证明也不是决断的:对于此, 我们可以先假设他是决断的, 因为有一个黑盒, 它decides 那既然你这么喜欢比较, 那我直接让你帮我解决问题:
构造一个永远拒绝所有输入的图灵机, 也就是他的语言永远是
然后我们直接把我们把这个和一起丢给黑盒让他判断
如果接受, 就接受, 反之亦然
这样, 我们就能用黑盒决断我们已经证明无法决断的问题了 - 引出悖论本小节没有涵盖在课堂内容中我们会说A is mapping-reducible to B: 如果有一个函数f, <br>
<img alt="Pasted image 20250324174606.png" src="cs3100/computability/attachments/pasted-image-20250324174606.png" target="_self">一个例子就是: <br>
在<a data-tooltip-position="top" aria-label="Computability > $E_{TM}$ is undecidable" data-href="Computability#$E_{TM}$ is undecidable" href="cs3100/computability/computability.html#$E_{TM}$_is_undecidable_0" class="internal-link" target="_self" rel="noopener nofollow">上面</a>, 我们为了证明不是可决断的, 我们创建了一个新的图灵机.
在这里, 我们的这个函数就是换句话讲, 就是: 只有在的语言不是空集的时候, 才会接受现在有一个理论: 如果, 并且是可决断的, 那么A也会是可决断的
证明: 如果我们有一个图灵机, 它decides , 我们会试图写一个图灵机它decides 计算
运行, 去检测是否在中
如果停机, 则输出跟相同的结果
我们可以把这个Mapping Reducibility当成上面说的Reducibility的特殊一种: is reducible to 但不可以是Mapping reducible to , 如, 因为之前说过, 的补集连Recognizable都不是, 但根据上面的Mapping的定义导致了悖论
现在, 我们可以用两种方法来证明一些语言不是Turing-Recognizable
相同的套路用归约法去证明
用以下的理论: 如果一个语言是Decidable, 那么和都必须是T-recognizable
这个很好证明: 因为我们可以用定理: 如果一个语言是Decidable, 那么和都必须是T-recognizable<br>因为它自身已经被证明<a data-tooltip-position="top" aria-label="Computability > $E_{TM}$ is undecidable" data-href="Computability#$E_{TM}$ is undecidable" href="cs3100/computability/computability.html#$E_{TM}$_is_undecidable_0" class="internal-link" target="_self" rel="noopener nofollow">是Undecidable</a>的, 并且我们也证明了是<a data-tooltip-position="top" aria-label="Computability > $ overline{E_{TM}}$ is Turing-Recognizable" data-href="Computability#$ overline{E_{TM}}$ is Turing-Recognizable" href="cs3100/computability/computability.html#$ overline{E_{TM}}$ is Turing-Recognizable" class="internal-link" target="_self" rel="noopener nofollow">Turing-Recognizable</a>的, 所以, 一定不是Turing-recognizable的, 不然也同样会是Decidable语言, 导致悖论或者, 我们也可以用归约法来证明:
我们先假设有一个图灵机, 它recognize , 我们现在尝试把它变成关于的问题: 创建一个新的图灵机: 如果, 拒绝
运行, 去检测, 如果接受则接受
这样, 这个图灵机只可能接受一种语言, 也就是, 否则就是空集 通过就可以知道的结果到底是不是空集, 如果接受了, 那么说明
如果接受的话, 就说明没有接受这个字符串, 反之亦然
证明 recoginizes 如果不接受和的话 (也就是接受), 那么就不会是个空集, 反应到上, 他就会拒绝
如果接受和的话, (拒绝), 那么会是个空集, 反映到上, 它就会接受
这样, 我们就会用去解决无法被辨识的问题, 导致悖论
<br>这个套路跟之前证明<a data-tooltip-position="top" aria-label="Computability > $EQ_{TM}$ is undecidable" data-href="Computability#$EQ_{TM}$ is undecidable" href="cs3100/computability/computability.html#$EQ_{TM}$_is_undecidable_0" class="internal-link" target="_self" rel="noopener nofollow">undecidable</a>是一样的:如果有一个图灵机真的可以识别, 那么我们可以构建一个新的图灵机去解决的问题: 构建两个图灵机
会拒绝任何字符串
会去运行去检测, 如果接受了, 就接受任何字符串, 否则拒绝任何字符串
运行去检测
如果接受了, 那么就说明拒绝了, 导致两个图灵机器输出的都是, 所以我们就接受, 反之亦然
]]></description><link>cs3100/computability/computability.html</link><guid isPermaLink="false">CS3100/Computability/Computability.md</guid><pubDate>Mon, 28 Apr 2025 21:10:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250428144506]]></title><description><![CDATA[<img src="cs3100/cheatsheet/attachments/pasted-image-20250428144506.png" target="_self">]]></description><link>cs3100/cheatsheet/attachments/pasted-image-20250428144506.html</link><guid isPermaLink="false">CS3100/CheatSheet/attachments/Pasted image 20250428144506.png</guid><pubDate>Mon, 28 Apr 2025 20:45:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250428144419]]></title><description><![CDATA[<img src="cs3100/cheatsheet/attachments/pasted-image-20250428144419.png" target="_self">]]></description><link>cs3100/cheatsheet/attachments/pasted-image-20250428144419.html</link><guid isPermaLink="false">CS3100/CheatSheet/attachments/Pasted image 20250428144419.png</guid><pubDate>Mon, 28 Apr 2025 20:44:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Linking]]></title><description><![CDATA[在编译文件时，编译器干了下面几件事情：
Preprocessor – Handles # directives (#include, #define, ...) Compiler – Translates C into assembly
Assembler – Translates assembly into machine code
Linker – Finds external code (libraries, etc).
Executable – 生成可执行文件
这里主要讲的是 Linkers：文件之间如何进行合作。我们发现，很多时候会先编译 .o 文件而不是直接编译成可执行文件。这是因为早期计算机内存有限，把项目拆分成小块可以让编译器逐个处理，提高效率。.o 文件是中间产物，在链接阶段合并成最终程序。记录当前文件中有哪些函数或变量的声明（declares）和定义（defines）。
declares: sum 表示这个 .o 文件使用了名为 sum 的函数或变量，但并没有在本文件中定义。链接器需要从别的 .o 文件中找到它。
defines: main 表示该文件定义了函数 main，机器码也包含在此。 符号表用于链接阶段，链接器会根据这些信息将多个 .o 文件拼接成一个可执行程序。 编译器已经生成的、可以直接运行的指令序列。
例如：0x55 48 89 e5 ... 表示 main 函数的机器指令。当涉及变量或函数在多个文件中定义/声明时，链接器需要决定用哪一个。 这里说的函数/变量都是在文件作用域下, 也就是说这些东西不是在Scope中, 而是直接写在函数外面, 如main函数外面, 只有在文件作用域下, 编译器才会认为这个变量是有可能会进行外部链接的, 所以会把他放入Global Symbol Table中. 而Linker会决定用不用他.C 编译器区分弱符号（Weak Symbol）与强符号（Strong Symbol）。如果我们把某个变量设置成static, 则这个变量会是在这个文件的Global中存放, 跟其他的Symbol一样, 但不同的地方是static会让这个变量无法在文件之间进行共享还有一种特殊的修饰词: extern, 他的作用是让我们能跨文件访问某个变量:文件1:int count = 42; // 真正定义（强符号），分配内存
文件2:#include &lt;stdio.h&gt;
extern int count; // 只是告诉编译器：count 在别处定义
int main() { printf("%d\n", count); // 使用引用 return 0;
}
上面这种操作, 我们在文件2中可以跨文件引用文件1的东西, 只要变量名相同, 加上extern, 并且我们不声明它, 编译器就会知道这是个其他地方定义的变量, Linker会把这两个连接到一起.
出现在变量没有初始化时，例如：
int arr[];
int arr[5];
float arr; extern 声明不会产生内存分配，因此不会成为 weak symbol。
weak symbol 可能会变成一个实际的内存分配，也可能不会，取决于链接时是否有更强的定义。 出现在变量被初始化时，例如：
int x = 5;
void foo(){} 非 static 的函数/变量会被导出为 symbol，即对其他 .o 文件可见。
static 修饰的变量不会导出 symbol，仅在当前文件内部可见。
使用 .h 头文件可以统一声明，避免符号不一致。 Linker 会扫描你传给它的 .o 文件。
从中提取变量、函数等符号。
将它们整合成一个可执行文件。
并在过程中将声明与定义进行匹配。
最终得到的结果是一个可以由 CPU 直接执行的程序。
链接器需要将函数和变量的地址进行重定位。
符号表中记录了哪些位置需要修改地址。
无论是变量还是函数，都会在链接阶段被替换为最终地址。 C 标准库由 .h 文件 + 预编译的 object 文件组成。 只需要包含声明，源码不是必须。
例如：&lt;stdio.h&gt;、&lt;math.h&gt;
编译时默认会链接 libc.so，等价于 -lc
<img alt="Pasted image 20250416124520.png" src="cs4400/attachments/pasted-image-20250416124520.png" target="_self">
假设我们想编译Minecraft和Photoshop我们在编译的时候, 可以每次都引入那些.c文件, 但会导致一些问题
如果每次都重新编译 .c 文件，效率较低。
可以先编译为 .o 文件，随后链接使用：
gcc photoshop.c motion.o blur.o emboss.o 更进一步，还可以把多个 .o 文件打包成 .so 文件：
gcc -fPIC -shared -o libimage.so blur.o motion.o emboss.o
gcc photoshop.c -limage -L. 但这样仍然很麻烦, 不是吗?这时候, 就可以用动态链接库:
类似 Windows 的 .dll，不会复制代码，只是引用。
所有运行的程序都能共享同一份 .so 文件，节省内存。
执行时才加载，称为延迟加载（lazy loading）。
但又会导致一些问题:
因为共享库会被多个程序加载，每个程序可能把它加载到不同的内存地址。
所以 .so 文件里的代码不能写死地址，而必须写“相对地址”或“可重定位地址”。
这就是 PIC 的用武之地。
为了解决上面的问题, 我们可以用相对地址表示我们的代码
共享库放置位置不固定，因此代码需要使用相对地址。
编译选项 -fPIC 可生成 Position Independent Code。
使用程序计数器（%rip）偏移来访问全局变量：
mov 0x30(%rip), %rax
mov (%rax), %eax .got 存储全局变量的地址。
代码中是“指向 .got 的指针” =&gt; 二次跳转。
每个进程有自己的 .got，但共享 .text 区域。
设想一个函数要读取外部变量 float x，编译器生成的 PIC 代码如下：extern float x; float foo() { return x; }
生成的汇编可能是：mov 0x30(%rip), %rax ; 读取 .got 表中 x 的地址 mov (%rax), %eax ; 读取 x 的值
而 .got 表大概长这样：.got: 0x10: 0x600a00 ; x 的实际地址 编译时用 -L 指定库路径，用 -lxxx 链接：
gcc main.c -L/path/to/lib -lmine 运行时，系统默认只查找 /lib, /usr/lib, /lib64。
可设置环境变量 LD_LIBRARY_PATH 指定查找路径：
export LD_LIBRARY_PATH=/my/custom/path:$LD_LIBRARY_PATH 注意：设置路径后仅对当前终端 session 有效。 可执行文件采用 ELF（Executable and Linkable Format）格式。
包含多个 section： .text：代码段（machine code）
.bss：未初始化全局变量
.got：全局偏移表
还有 .data, .rodata 等等 ]]></description><link>cs4400/linking.html</link><guid isPermaLink="false">CS4400/Linking.md</guid><pubDate>Fri, 25 Apr 2025 03:29:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[多线程]]></title><description><![CDATA[对于一个程序, 如果是多线程, 这两个线程会共享一个Heap, 但stack是独立的. 而不同的Process, Heap也是独立的.<img alt="Pasted image 20250402130349.png" src="cs4400/attachments/pasted-image-20250402130349.png" target="_self">由于多线程是后期才加入UNIX中的, 所以有些C的库可能不支持多线程
并且, 多线程非常容易出错:int count = 0; main(){ pthread_create(..., increment, ...); //Race Condition count++; } increment(...) { count++; }
创建了多线程后, 跟fork有相似之处也有不同之处: fork是直接相当于创建了一个新的程序, 同步运行, 但多线程之间是共享虚拟内存的 - 他们每个线程之间有不同的Stack, 但他们的Stack都存在于同一个空间中
还有一点不同是父进程销毁后, 子进程不会销毁, 但对于线程来说, 父线程退出后, 所有它创建的子线程都会一并销毁.当创建一个线程的时候, 需要调用下面这个函数:#include &lt;pthread.h&gt; int pthread_create(pthread_t* thread, const pthread_attr_t* attr, void* (*start_function)(void*), void* start_arg);
调用完后, thread变量(指针)会修改里面的值, 分配一个新的线程ID
attr默认是NULL, 但如果想的话, 也可以在这里分配stack的大小
后面两个就是我们要执行的函数和这个函数的参数跟进程很像, 这个也需要reap 线程:pthread_join // 等待线程结束再reap pthread_detach // 不需要等待, 只要线程结束后线程会把自己reap
int pthread_detach(pthread_t thread);
但跟进程不一样的是, 只有父进程才可以等待子进程, 但是不管什么线程都可以等待任何其他的线程:#include &lt;pthread.h&gt; int pthread_join(pthread_t thread, void** result_p);
如果我们调用Exit, 会直接杀死整个进程, 而pthread_exit会杀死单个线程这些多线程代码是很容易出错的:for(i = 0; i &lt; 50; i++){ int id = i; pthread_create(..., &amp;id); } void* print_id(void* args) { int my_id = *(int*)args; } 上面的代码看起来很正常, 但实际上完全错的: 虽然每次 pthread_create 我们传入了当前的 id 地址（&amp;id），但实际上 id 是在主线程的栈上定义的同一个变量。所有线程都共享这个地址，而不是值本身。因此，如果线程在运行时 id 的值已经被主线程改为下一轮的值，所有线程读到的可能是相同的（甚至是最终的）值。这会导致每个线程打印出的 ID 可能一样或错误。基本上, 进程有的东西, 线程都有对应的功能:在x86-64中lock可以允许某个指令独享Cache line一段时间
这种是解决Race Condition的一种办法:
Avoid Sharing - 最后再合并每个线程的结果 有些算法不支持
速度快, 并且不容易出错 <br><a data-href="Transactions" href="cs5530/transactions.html" class="internal-link" target="_self" rel="noopener nofollow">Transactions</a> 一般用于数据库 Locks 容易出错 一个基本的在x86-64中的锁是lock cmpxchg[x] source, dest
这个指令的效果是:
如果%eax==dest, 则把dest设置成source, 并更新ZF
否则清空ZF
如下面一个Spin Lock的例子:lock: mov $0, %eax // if locked == 0 {locked = 1} lock cmpxchg $1, (m) jz done //If success, done jmp lock // else, try again //也许有sleep done: unlock: mov $1, %eax lock cmpxchg $0, (m) //不需要检查结果, 但需要我们先前创建一个锁
上面叫做Spin Lock因为它就是一个循环, 它会一直让CPU核心处于运算中, 直到Lock结束, 这种Lock是极度简化的结果.当然, Lock同样也有Tradeoff: 有些锁支持一个线程锁多次, 有些不支持, 并且哪个线程创建的锁就得那个线程自己去解锁在C中, 有两种Lock:
Mutex Semaphore
为了避免Datarace, GCC和Clang也提供了一直检查方法 - Thread Sanitizer
使用这个Flag编译后通常会慢5~15倍pthread_mutex_t mutex; // 声明一个互斥锁变量
pthread_mutex_init(&amp;mutex, NULL); // 初始化
pthread_mutex_lock(&amp;mutex); // 请求锁（进临界区）
pthread_mutex_unlock(&amp;mutex); // 释放锁（出临界区）
pthread_mutex_destroy(&amp;mutex); // （可选）销毁
static pthread_mutex_t m; main() { pthread_mutex_init(&amp;m, NULL); pthread_mutex_lock(&amp;m); // critical section where we access // shared data pthread_mutex_unlock(&amp;m); }
这种本质上就是一个Thread-Safe Counter
我们有两种方法去修改这个Counter:
P - 拿走一个Counter的 "ticket", 如果没有任何的ticket, 则阻塞线程, 直到ticket的数量大于0
V - 增加一个ticket
我们用下面这种方法可以模拟出Mutex的功能:static sem_t m; main(){ Sem_init(&amp;m, 0, 1); P(&amp;m); // critical section V(&amp;m); }
当然, 我们如果只想用Mutex的功能的话, 完全没有必要用这种LockSemaphore这种Lock更适合做这种工作:
一个或多个线程产生工作, 如客户端发送数据给客户端
一个或多个线程处理工作
必须这里://产生信息的线程
while(…){ lock_mutex(&amp;q); enqueue(message); unlock_mutex(&amp;q); } //处理信息的线程
while(1){ lock_mutex(&amp;q); message = remove(); unlock_mutex(&amp;q); if(message) apply(message); //开始处理信息 }
上面的有点怪, 因为我们把处理信息的函数放在一个循环中, 也就是说CPU会一直在判断有没有Message. 这样很消耗资源, 但如果用Semaphore就可以解决这个问题:while(…){ lock_mutex(&amp;q); enqueue(message); unlock_mutex(&amp;q); V(&amp;ready); //产生消息后就增加一个Ticket
} while(1){ P(&amp;ready); //只要Ticket增加, 就会开始处理, 否则这个线程是堵塞状态 lock_mutex(&amp;q); message = remove(); unlock_mutex(&amp;q); apply(message); }
并且这样还有一个好处: 我们可以让发送Message的线程一直写入信息, 因为Ticket可以一直累加.<br>
或者我们可以把他想象成一个带有计数器的<a data-tooltip-position="top" aria-label="OS > Signals" data-href="OS#Signals" href="cs4400/os.html#Signals" class="internal-link" target="_self" rel="noopener nofollow">Signal</a>不过不管是哪种方法都需要
•pthread_mutex_destroy(&amp;mutex); •Sem_destroy(&amp;sem);]]></description><link>cs4400/多线程.html</link><guid isPermaLink="false">CS4400/多线程.md</guid><pubDate>Thu, 24 Apr 2025 03:59:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Finite Automata Theory]]></title><description><![CDATA[有限元自动机是一个对于有限内存的机器的很好的模拟很多东西都是可以用状态机去表示的, 如一个开灯的开关, 如果在关灯状态, 则按开灯灯就打开, 按关灯按钮, 状态不变. 如果在开灯状态, 按关灯按钮会转跳到关灯状态, 按开灯按钮状态不变.状态机通常会有一个特殊的状态是Accept状态, 如果最终指令执行完, 停在了这个状态, 则最终输出Accept, 否则输出reject.
并且, 状态机是可以被语言表示的, 比如我们可以设计出一种状态机, 它只会接受以下这种语言
我们就可以说M recognizes 这个语言.
每种状态机只会认识一种语言, 我们记作L(M) 如果这个状态机不接受任何字符串, 则这个L(M)是个空集.我们可以把这个L(M)完全当作一个Language, 所以可以说反过来, 如果一个语言可以被状态机所recognized, 则这个语言可以说是regular language
如:
是一种regular language, 而不是个regular language, 之后会证明它为什么不是需要注意的是, 每个状态机只会识别一个Language, 如果一个状态机识别集合A, 但有个集合B, 它是A的子集, 我们仍然不能说状态机识别B, 只能说它接受B. 因为如果需要识别, 则这个集合需要包含这个机器M所接受的所有字符串对于有限元自动机, 他的功能就是去解决关于regular language的问题, 但限制就是无法解决关于不是regular language的问题.k-tuple - a sequence of k elements, k≥1
对于一个有限元自动机M, 它有五个元组:<img alt="有限状态机.png" src="cs3100/automata/attachments/有限状态机.png" target="_self">如果一个状态机的F是空集, 那么它是没有终点, 也就是说它不会接受任何字符串, 所以它识别的语言也是空集 设计状态机的过程就像算法一样, 没有固定的公式, 更多的是靠自己的感觉比如
这个状态机就可以有两个状态, 然后互相用1转跳, 如果转跳奇数次, 都会转跳到目标, 而转跳到偶数次, 都会转跳回原位.<br>
<img alt="Pasted image 20250108140021.png" src="cs3100/automata/attachments/pasted-image-20250108140021.png" target="_self">这个问题可以认为, 只要出现连续的001, 就可以直接结束了, 所以, 我们需要只要是1, 就回到原点, 而连续的两个0就会进入一个状态: 它只会管有没有1出现, 因为不管后面出现多少个0, 都没有违反规则, 而只要出现了1, 就满足要求了.<br>
<img alt="Pasted image 20250108140133.png" src="cs3100/automata/attachments/pasted-image-20250108140133.png" target="_self"><br>需要注意的是, 虽然上面说过<a data-tooltip-position="top" aria-label="Finite Automata Theory > ^ece8f6" data-href="Finite Automata Theory#^ece8f6" href="cs3100/automata/finite-automata-theory.html#^ece8f6" class="internal-link" target="_self" rel="noopener nofollow">如何让语言变成空集</a>, 但我们仍然需要让状态机加上状态转移方程(也就是箭头), 不然这个状态机就没有任何alphabet. 除非题目明确规定alphabet也是空, 并且, alphabet里有的元素, 必须在每个状态机上都有箭头来应对新出现的字符如果一个状态机添加了一个新的元素在alphabet中, 如果他的language没有改变, 则可以说这个状态机也没有改变, 就像在一个算法中添加了一条注释一样, 这个算法没有受到影响, 那么它就是本来的算法.这是一种对于language的操作:Union:
Concatenation:
Star:
并且, 空字符串也会在这个合集里面, 因为k可以是0前面两个都比较好理解, 最后一个就是把A合集里任意多的元素以任意顺序和任意数量组合而成.
比如{0011},{},{0100111}都是{0,1}^*并且, Concatenation也是有点注意的地方的: 如果合集B是个空集, 则A◦B也会是空集, 因为无法从B中选择任何元素, 所以也组成不了任何东西这种操作也遵循闭包性质, 就像int+int永远会等于int的一样, 但int / int不一定会得到int一样
如果两个language是regular language, 则这两个语言的union, 也会是regular language
如果两个language是regular language, 则这两个语言的Concatenation, 也会是regular language
如果某个language是regular language, 则这个语言的Star, 也会是regular language
Proof:Union
假设存在M1,M2两个机器, 分别认识两个语言A,B, 我们需要证明, 存在一个机器, 它认识A U B, 换句话说, 给一个String, 这个新机器M只有在M1或M2接受它的时候才会接受.其实, 想找到这个新机器M, 是蛮容易的: 可以把M1和M2里所有的节点都组合起来, 成为一个一个的节点对. 然后把M1和M2所有的转移方程搬到M机器里面, 就可以得到一个新机器, 只接受M1或M2的String<br>
<img alt="Pasted image 20250422010350.png" src="cs3100/automata/attachments/pasted-image-20250422010350.png" target="_self"><br>因为在<a data-href="Finite Automata Theory#NFA -> DFA" href="cs3100/automata/finite-automata-theory.html#NFA_->_DFA_0" class="internal-link" target="_self" rel="noopener nofollow">Finite Automata Theory &gt; NFA -&gt; DFA</a>中说过, 因为NFA可以转换成DFA, 所以用NFA证明会更加简单. 有了NFA, 我们就不用把所有的可能性组合起来了, 我们可以有并行这个操作了: 也就是写一个起始点, 这个起始点用ε转移方程同时连接M1和M2的起始点. 所以根据NFA的特性, 他会同时走两条路, 只要有一条到accept state, 就可以说这个NFA认识这个语言.Intersection注意, 这个不是Concatenation
这个只要理解Union后就很好理解, 只要Accept State变成两个Machine里都有的Final State就行Concatenation
我们的目标是给一个M1和M2, 能找到一个新机器, 这个机器只能接受M1和M2中分别选一个String连接到一起产生的新String. 想做出这样的机器, 我们可以让M1的Accept State连接到M2的Start State. 也就是说只要前半段一旦被接受, 那么立刻转跳到M2的Start State.
这样看起来是正确的, 但实际上这个方法无法知道哪段是M1的, 哪段是M2的, 可能我们太早转跳到M2, 导致多出来的那段字符让M2不接受.<br>所以我们需要一个新的工具来解决这种事情 - <a data-tooltip-position="top" aria-label="Finite Automata Theory > Nondeterministic Finite Automata" data-href="Finite Automata Theory#Nondeterministic Finite Automata" href="cs3100/automata/finite-automata-theory.html#Nondeterministic_Finite_Automata_0" class="internal-link" target="_self" rel="noopener nofollow">NFA</a>有了NFA, 我们在M1的accept state的时候, 可以用NFA的特性 - 做个分支, 一条去M2起点, 一条继续走走M1的正常变换. 最后, 只要有一个分支到accept state, 就算这个M接受, 并且这个string同时被M1和M2接受.Star
这个听起来更加复杂一些:
也就是说M中任意多个string串起来, 得到的string都需要被这个新M识别.
其实, 我们可以认为这是一个Concatenation的问题: 也就是每次到accept state后, 都会有个分支: 一个是继续M原本的分支, 另外一个是ε转移方程, 这个方程会返回到起点.
通过NFA, 我们就可以自动把这个一大长串的string 拆成一个个的被原本的M所识别的string.
需要注意的是, 由于k可以等于0, 所以对于空字符串也需要被识别, 所以起点也需要变成accept state.<br><img alt="Pasted image 20250113140920.png" src="cs3100/automata/attachments/pasted-image-20250113140920.png" target="_self">
上面学的状态机是DFA跟这里的NFA的区别是:
NFA不必需要对一个状态设计所有的状态
NFA有ε-transition, 也就是说它可以不读取任何字符, 直接过去
NFA有多种路径, 比如上面的q1可以有两条路走, 只要有一条路到Accept State就算接受
q1q10q1q2q31q1q30no where to goq1q21q3q4q4q1q2q31q4
对于一个NFA, 它有五个元组:由于NFA的节点转移时不会包含所有的字符, 所以在画表格来表示的时候, 需要在没有转移的时候写一个空集符号来表示这个字符在这个节点不会转移(或者说在这读到这个字符就会结束)比如我们想设计一个NFA, 它只接受一个string, 它的倒数第三个字符是1:q1q2q3q10,110,10,1每一个NFA, 都是可以变成DFA的. 也就是, 永远存在一种DFA, 它会识别和NFA同样的语言.
推论: 如果一个语言想要是regular language, 则它一定又一个识别它的NFA, 至于为什么不用DFA了, 是因为NFA通常比DFA更加简洁假设: 如果有一个NFA - M认识语言A, 则存在一个DFA - M'认识A证明: 首先假设M没有ε转移, 对于有ε转移的情况之后会讨论. 而剩下的NFA的特性就是: 一个节点不用有所有字符的转移方程, 一个节点可能有两个或以上的状态方程.
对于没有字符的转移方程, 可以设计一个dummy state, 让状态进去就永远出不来了
对于两个或以上的状态方程, 可以把所有的subset给写出来, 然后让这个subset包含了所有可能去的地方:
q1q2q3011q1q2q1q301x0101NFADFA0q1q2001
像这里, 在q2可以去往1, 也可以去往3, 所以就创建一个节点同时代表q1和q3, 它包含了q1和q3可能去的地方, 如果q3还可以再回到q1, 则还需要创建一个节点, 说明状态可能同时再q1和q2现在需要解决带有ε转移方程的NFA了:
其实这个在理解上面的方法以后也比较好解决了:
比如从q2可以通过ε转移到q3, 也就是说q2可以直接到q3不需要任何字符. 那么就直接加一个节点叫q2,q3, 如果从q1转移到q2的时候就直接转移到这个节点就行, 也就表示它既可以到q2, 也可以到q3
q1q2q30,ε11q1q2q1q2q31x0NFADFAq20101在数学中, 我们用运算符来表达出算式, 同样的, 我们可以用正则表达式来表示一个语言:
如果R是其中一下之一, 那么这个R就是regular expression:<br>
<img alt="Pasted image 20250115143937.png" src="cs3100/automata/attachments/pasted-image-20250115143937.png" target="_self">
运算符也是有先后顺序的:
对于1, a是对于{a}的简写, 也就是一个只包含a字符的语言.
对于◦, 这个也有简写: 可以把它省略掉, 直接写R1R2, 就表示两个语言的连接例子:理论: 如果一个语言是regular的, 则一定有一个正则表达式可以表达它Lamma1:
如果存在一个正则表达式, 则我们可以把它画成一个NFA (可以表明它是regular的)想证明这个是可以做到的: 可以把上面的Regular expression的组成的6个基础部分都化成NFA, 那么不管正则表达式有多复杂, 总有NFA可以表达出来.6个组成部分分为两个部分: R is atomic: 语言构成非常简单, 要不就是一个字符, 或者空集
R is composite: 这个语言是由两个其他的正则表达式通过合集, 连接, star组合而成
<br>Atomic很简单, NFA可以轻易画出来, Composite也很简单 - 可以用<a data-tooltip-position="top" aria-label="Conecpts > Closure properties" data-href="Conecpts#Closure properties" href="cs3100/automata/conecpts.html#Closure_properties_0" class="internal-link" target="_self" rel="noopener nofollow">closure constructions</a>来证明Lamma2:
如果存在一个正则语言, 则一定存在一个正则表达式表达出来它.这个证明比较复杂, 我们需要一个GNFA来证明. 这个跟NFA不同的是, 它的每条路线(状态转移方程)是可以由正则表达式来表达的. 然后, 还需要多个个Special form假设:
存在一个GNFA, 它跟上面设计的GNFA是一样的, 但它只有一个accept state, 且不在起始点. 这个可以做到, 只要把所有的accept state用一个接受空字符的转移方程连到一个新的accept state就行了.
任何其他state不能转移到start state. 所以我们可以创建一个新的start state, 然后用空字符串的转移方程连接到原本的start state
accept state 只能被其他state指向, 不能指向任何其他的state
通过上面的三条操作, 就可以把一个GNFA来转化成一个special form的GNFA. 然后我们的目标就是把它变成一个正则表达式.这可以用数学归纳法来归纳含有k个state的GNFA图G.
Basis: k = 2
这时候, 只有两个state, 起始点不是accept state, 然后用一个Regex (r)连接一个accept state. 答案很明显, 我们想找的正则表达式R就是状态转移方程rIncudtion step: k &gt; 2
我们会假设k-1个state都是可以转化成正则表达式的(数学归纳法原理), 然后需要证明有k个state也可以转换成Regex.
对于一个k state的Machine, 我们可以去掉一个非起始非结束的state, 变成一个k-1 state的 Machine. 但由于我们删掉一个点, 这个Machine就已经不等同于之前的Machine了, 所以我们需要把这个新Machine进行修改, 这样它又变成了以前的Machine, 唯一的区别就是少了一个state.
我们可以这么修复: 假设从o-&gt;p-&gt;q, 他们的转移方程分别是r1和r2, 我们删掉了p state. 我们可以直接把o state 连接q state, 然后用一个正则表达式r1r2(两个表达式连接起来)连接o和q. 这样, 就可以保证这个machine 和原来的machine认识的语言是一样的. 如果被删掉的p state还会指向自己, 则可以在r1r2表达式中间加上个r*, 表示中间夹多少个这个转移方程都没关系.
通过重复这样的操作, 我们需要把所有指向p state的state都用正则表达式连接到新的state.Induction Conclusion: 因为Base case和 Induction Step都证明过, 所以这个假设成立GNFA -&gt; Regex:
上面已经证明了一个GNFA可以转化成表达式, 那么来实际操作一下:
实际操作就是一直在重复Induction Step里的东西: 一直去删除图中的某个State, 然后把删掉一个State的GNFA修改成跟原来相同的GNFA. 重复到只有start state 和Accept state. 现在, 对于一个语言A, 我们可以用NFA, DFA或者Regex来判断它到底不是regular
但我们仍然无法设计出任何机器来识别下面的语言:
这就涉及到 None Regular Language了.如果一个语言没有NFA或DFA去识别A语言, 则这个A语言就是None Regular Language. 通常, 这个是比寻找一个能识别某个语言的DFA要困难的, 因为我们需要去证明这个语言为什么不能被NFA / DFA识别.
比如这个语言, 因为NFA / DFA没有记忆去记住能有多少个0和1出现, 所以就没办法识别这个假设说的是对于每一个regular language, 一定有一个数字p(pumping length)
如果一个字符串属于这个语言中, 并且字符串的长度≥p, 则这个字符串合约被分成三个部分xyz. 这个xyz三个部分需要满足下面三个条件
比如一个regular 语言A={x, y, z, w}, 这四个string的长度均没超过100, 那么我们直接说p=101, 那么这个语言直接满足Pumping Lamma
从此可以看出来, 如果想要使用这个Pumping Lamma, 就需要这个语言的字符长度至少是无限的.Proof:使一个DFA M 认识A语言, 然后把它的state number记作p, 然后我们选择一个长度≥p的字符串. 这个长度的字符串会让某个节点一定访问两次或以上所以, 可以简化成这样一个表格:
qjyzx
这个访问两次或以上的节点记作qj, 然后把它自循环当作上面的y. 它可以无限次循环, 都满足第一个规则
第三个规则可以这么满足: 我们把第一个循环的出现当作qj, 这样, x没有任何循环, y就算有循环, 一边走完剩下的节点也不会超过p, 所以|xy|的长度就一定是小于等于p的, 后面的部分算在z头上.实践:
接下来就来看怎么证明这个语言不是regular的, 通过proof by contradiction
也就是说, 我们需要证明不管哪个p, 都会找出不满足规则的某个字符串.首先假设它是正则的, 所以会存在一个p这样, 这个字符串s一定可以被分为三个部分xyz, 由于规则规定一定要有y, 所以我们把00001111中的一段0当作y.
虽然前两个规则可以满足, 但只要我们根据规则, 来增加y的数量, 那么这个新的字符串就不会满足规则, 因为0000 0 1111就有不相等数量的0,1了. 中间隔开的0就是第二个y
这样, 不管什么p, 都满足不了上面的要求实践2:
上面的表示有两段字符串, 字符内容怎么排列, 怎么重复都可以. 但这两段字符串需要相等
这种情况, 我们连怎么分割都不知道.仍然是Proof By Contradiction
可能第一想到的是用上面的测试: 然而实际上是不行的, 因为如果把y当作两个0, 就可以让字符串永远是双数.其实, 我们可以写成这样:原理跟上面差不多其实, 这个s字符串是000...01 000...01 这样, 如果我们把y看作0, 也就是第一个重复的地方, 那么如果我们把y重复, 则后半段的字符串就不会跟前面的相等. 实践3:
我们可以说这个pumping lamma是:
由于规则2, 3, y必须是一个或多个0, 但这样的话, 如果根据规则1, 把y删掉, 则这个s则不再满足有0比1多的特点了. 因为y一定含有个0, 所以(p+1)-1=p实践4 - 用闭包性质来证明:
首先, 我们可以构建出0*1*的NFA, 就是两个节点能做到的事
根据闭包性质, 两个Regular Language做操作还会得到一个Regular Language, 也就是说A=D∩0*1*会得到一个regular的语言A, 但得到的结果是
而这个A已经被证明过不是regular的实践5:
然后, 我们可以用下面的这个方式来永远找到一个xyz来符合pumping lamma:<br>
<img alt="Pasted image 20250127144651.png" src="cs3100/automata/attachments/pasted-image-20250127144651.png" target="_self">但需要注意的是, 虽然不满足pumping lamma的永远不是regular language, 但满足这个的, 不一定是regular language]]></description><link>cs3100/automata/finite-automata-theory.html</link><guid isPermaLink="false">CS3100/Automata/Finite Automata Theory.md</guid><pubDate>Tue, 22 Apr 2025 07:03:51 GMT</pubDate><enclosure url="cs3100/automata/attachments/有限状态机.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;cs3100/automata/attachments/有限状态机.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250422010350]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250422010350.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250422010350.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250422010350.png</guid><pubDate>Tue, 22 Apr 2025 07:03:50 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Intro]]></title><description><![CDATA[这节课的内容是让我们知道计算机能干什么和不能干什么. 这节课有
Automata Theory
<a data-tooltip-position="top" aria-label="Finite Automata Theory" data-href="Finite Automata Theory" href="cs3100/automata/finite-automata-theory.html" class="internal-link" target="_self" rel="noopener nofollow">Finite automata</a> 有限元自动机, 通过字符驱动切换状态, 如正则表达式 <br><a data-tooltip-position="top" aria-label="Context Free Languages" data-href="Context Free Languages" href="cs3100/automata/context-free-languages.html" class="internal-link" target="_self" rel="noopener nofollow">Pushed down automata</a>, 相比有限元自动机多了一个无限空间的栈, 可以处理上下文无关的语言, 可以用于构建编译器
由于是栈, 所以在某些方面还是有限制
Computability Theory <br><a data-href="Turing Machine" href="cs3100/turing-machine/turing-machine.html" class="internal-link" target="_self" rel="noopener nofollow">Turing Machine</a> 图灵机 <br><a data-tooltip-position="top" aria-label="Computability" data-href="Computability" href="cs3100/computability/computability.html" class="internal-link" target="_self" rel="noopener nofollow">Decidabiliy / Undecidability</a> 计算机解决不了的问题
Halting Problems<br>
<a data-href="Complexity Theory" href="cs3100/complexity-theory/complexity-theory.html" class="internal-link" target="_self" rel="noopener nofollow">Complexity Theory</a> P, NP, NP-Complete, NP-Hard
<br>Cheet Sheet:<a data-href="MT1.psd" href="cs3100/cheatsheet/mt1.html" class="internal-link" target="_self" rel="noopener nofollow">MT1.psd</a> <a data-href="final.psd" href="cs3100/cheatsheet/final.html" class="internal-link" target="_self" rel="noopener nofollow">final.psd</a>]]></description><link>cs3100/intro.html</link><guid isPermaLink="false">CS3100/Intro.md</guid><pubDate>Tue, 22 Apr 2025 06:46:08 GMT</pubDate></item><item><title><![CDATA[Complexity Theory]]></title><description><![CDATA[Big O表示的就是对于大小的输入, 算法所需要的时间是多少常见的BigO有: 越往下, 算法所需的时间越多, 不管常数是多少, 但只要足够大, 所需的时间排序就是这样的我们称那些需要多项式时间的算法, 如, , 甚至, 为easy Problem
但如果在次幂的时间的算法如, 我们称为Hard Problem如果一个decision问题, 它可以在多项式时间复杂度内解决出来, 则它就是P问题
更正式的说法：存在一个确定性图灵机（Deterministic Turing Machine）在多项式时间内给出问题解答，则该问题属于 P.
如果一个decision问题, 它可以在多项式时间验证结果, 则它是NP问题
等价定义：存在一个非确定性图灵机（Nondeterministic Turing Machine） 可以在多项式时间内接受（accept）这个问题。也就是说，非确定性机可以“猜”出一个可能的解，并在多项式时间内检查这个解是否正确。
如果 P=NP的话, 我们就会知道如果能在多项式时间内验证正确性, 那我们也可以在多项式时间内解决出来这个问题 - 当然, P=?NP这个问题至今无人能回答
P问题是包含在NP问题中的.
回想我们的NFA的路径: 一个路径会产生多个可能, 这多个可能又会产生新的可能 ... 我们计算复杂度的时候, 所看的就是它的的最长的路径 - 这就是NP问题的另一种说法: solvable in non-deterministic polynomial time给定一组数, 去判断是否能把这组数分成两组, 两组和相等:
给定一组数B, 和另外一个数M, 求B是否存在一个子集, 这个子集的和是M
给定一个无向图, 和一个数, 判断这个图是否能找到大小的CliqueClique表示给定一个无向图, 我们需要找到一个或多个集合, 这个集合的任意两个点都相连.并且这个问题还有一个升级版: 就是给定一个无向图, 求这个图最大的Clique是多少?
这个问题是包含上面的问题的, 因为只要我们找到了最大的Clique, 小于这个Clique的Clique都是存在的.对于这个问题, 我们说如果我们拿到了这个图的一个定点的合集, 我们很容易就能验证这个图的Clique是不是这个子集: 只要遍历集合的每个节点看它是否和集合里的所有其他节点相连就可以了如果用Matrix当数据结构存储这个图, 则验证的时间是
如果用Link List当数据结构存储这个图, 则验证时间是
不过不管是哪种方法, 都是消耗多项式的时间去验证我们的答案, 所以这是个NP问题如果我们想解答这个问题, 我们可以Nondeterministicilly选择一组定点, 然后我们去验证这组节点是不是Clique. 这就表明了这是个NP问题 - 因为为了解决它, 我们需要用非确定的方法去解NPHard 问题它可能不在NP问题中, 不过只要一个问题满足下面两点的其中一点, 则他就是NPHard问题:
我们从NP这个问题集合中挑选出任意的问题, 如果这个最终都能被规约成, 则就说明这个问题很牛逼, 很难, 以至于所有的NP问题都没他难, 所以就是NP-Hard
存在一个已知的NP-Hard问题, 如果能把他在多项式的时间内规约成, 则也是NP-Hard问题
NPC (NP完备)问题是NP问题的一个子集, 这些NPC问题是NP问题中最难的那一部分
这里的最难并不是个形容词!!! 它是"Hard", 表示的是NP hard
换句话来说, 如果一个问题既是NP问题, 也是NP Hard问题, 那么它同样也是NPC问题证明第一个NPC问题很难, 但如果当有了第一个NPC问题, 我们就可以把很多问题归约成这个问题, 来证明那些问题都是NPC问题. 而这个第一个NPC问题就是SAT首先, 我们有一堆布尔变量:
每个都可以接受一个值0或1有三种布尔操作: OR, AND, NOT我们把每个变量或者称作term或者literal并且我们会定义一个Clause: 它是一堆terms用Or连接起来, 这个term可能是或者的取反
如果最后的是true, 我们会说这些变量satisfies这个clauseSAT问题就是, 给定个输入bool变量, 和个Clauses,
我们的输出是去判断是否存在一组变量 , 它们可以满足所有的Clauses, 也就是:如我们有三个变量, 我们还有三个Clauses: 对于这个问题, 对应的Satisfying Assignment是但在归约的时候, 通常我们会用一个特殊的SAT: 3SAT
这个3SAT需要有n个变量, 和k个Clauses, 但必须让每个Clause只能正好有三个literals但如果 - 就是如果有一个NPC的问题跟P问题的集合重合了, 那么我们就可以知道
, 因为NPC问题是NP中最难的问题, 如果最难的问题都能用多项式内的时间解决出来, 那么剩下来的那些NP问题都能解决出来(Reduction)
<img alt="Pasted image 20250402133548.png" src="cs3100/complexity-theory/attachments/pasted-image-20250402133548.png" target="_self">
当然, 如果想证明是比要简单的: 因为如果想证明, 只需要给出一个NPC问题, 和一个多项式时间解就可以了, 但如果想证明和集合是不重合的要难得多
所有的NPC问题可以认为是等价的, 因为他们可以在多项式的时间内互相转化
虽然很多问题如Partition, Subset-sub, clique问题看起来不太一样, 但他们本质上都是等价的(就是上面说的)
所有的NPC问题都是无法(目前没有已知)在多项式时间内解决出来, 我们只能使用暴力穷举的方式解决, 如Subset sum, 他的子集数目是
有一些问题我们甚至不确定它是不是在NP里的 - 因为我们无法在多项式的时间内验证他的正确性 - 如给定一个图和一个数, 去判断图中是否没有大小为的clique
<br>如果我们想证明一个问题难不难, 我们仍然可以用Reduction来解决, 这个在<a data-href="Computability#Reducibility" href="cs3100/computability/computability.html#Reducibility" class="internal-link" target="_self" rel="noopener nofollow">Computability &gt; Reducibility</a>中有相似的操作这个的基本理念就是 (也就是把问题 Reduce到问题), 如果问题能用多项式的时间解决出来, 并且我们可以把 Reduce到, 那么也可以在多项式时间内解出来具体的流程就是:
给定一个问题
我们需要在多项式的时间内把他转换成问题
对于问题, 我们使用对应的算法去解决, 得到问题的解
按理说我们通过问题的解能得到问题 的解, 并且他们两边结果必须是相互对应的
总的来说, 如果我们要想证明 (多项式时间归约), 我们要能把 A 转成 B，并且我们需要证明这个转换过程是多项式时间的, 并证明解之间是“iff”关系 <br>比如在这里, 我们就可以去证明如果我们能在多项式时间内解决 <a data-tooltip-position="top" aria-label="Complexity Theory > Subset sum" data-href="Complexity Theory#Subset sum" href="cs3100/complexity-theory/complexity-theory.html#Subset_sum_0" class="internal-link" target="_self" rel="noopener nofollow">Subset sum</a>，那么也可以解决 <a data-tooltip-position="top" aria-label="Complexity Theory > Partition" data-href="Complexity Theory#Partition" href="cs3100/complexity-theory/complexity-theory.html#Partition_0" class="internal-link" target="_self" rel="noopener nofollow">Partition</a>
Partition 问题（问题 A）
输入：一个数集合 A。
目标：能否将它划分为两个和相等的子集？
Subset-Sum 问题（问题 B）
输入：一个集合 B 和一个目标数 M。 目标：是否存在一个子集，使其和正好等于 M？
我们把 Partition 的输入转成一个 Subset-Sum 的输入, 就像之前的归约问题一样, 我们可以把这个Subsum的Solver当做一个黑盒, 直到它能用就行：
把 Partition 中的集合 A 复制到 B（即每个）。
设置目标和 这样, 如果Subset-Sum找到了M, 也就是集合的一半, 我们也就解决了Partition - 因为A剩下的数的和就是另外一半于是，如果能解决这个 Subset-Sum 问题，那么我们也能解决 Partition。
这个过程是 多项式时间完成的，所以这个归约是合法的。如果想证明一个问题是NPC, 则我们有两种选择:
证明问题是NP
并且它还是NP-Hard 理论上来说, 我们可以用任意的NPC问题去做规约来证明是NP hard, 但选择一个好的NPC问题会极大简化这个难度 我们在这里不可以直接用NPC问题()去规约来得到问题也是NPC, 这是因为当我们规约了以后, 我们只会知道, 这个问题和问题只是同样的难, 也就是说它是NP-Hard问题, 但我们仍然没有满足第一点需求: 他是NP问题现在, 我们有了"模板", 就可以用SAT去证明其他的问题也是NPC问题, 如Clique问题:
因为我们已经在上面证明过Clique问题是NP的了, 所以现在只需要用其他NPC问题规约成Clique来表明这个Clique也是NP-Hard就能证明Clique是NPC问题了给一个3SAT问题:
有个变量:
个Clauses: 为了证明这一点, 我们需要把Clique问题简化成3SAT问题, 所以我们就需要在多项式的时间内把3SAT问题转换成一个Clique问题 - 这个Clique问题对应的图有大小的Clique
如果我们可以在多项式的时间内转换成Clique问题, 那么就表示想要解决Clique问题, 那么也就需要已解决3SAT问题, 但3SAT问题是NPC问题, 所以我们也就证明Clique问题也是NPC对于一个完整的证明, 需要有下面这4步:
如何把3SAT转换成Clique问题
解释这个转换为什么是多项式时间的
证明如果Clique问题的图有一个大小的Clique, 则那么也有一个对应的satisfying assignment
再反过来证明如果有一个satisfying assignment, 那么对应的图也会有大小的Clique
如果想把3SAT转换成Clique问题, 我们可以让个Clauses表示个图中的节点, 定义图:
对于每个顶点: 对于每一个Clauses ​，我们创建一个三元组顶点 ，每个三元组顶点表示一个 literal 定义每条边: 两个顶点 和有边 当且仅当 满足下面两个条件： 它们来自不同子句（即 ）
它们所表示的 literal 不互为否定（比如 ​ 和 ​ 不能连边） 如下面这个例子, 我们就成功把一个SAT转换成了一个图, 并且是在多项式的时间内完成的, 然后我们现在的目标就从找出一个literal组合变成找到一个Clique.<br>
<img alt="Pasted image 20250407135911.png" src="cs3100/complexity-theory/attachments/pasted-image-20250407135911.png" target="_self">接着, 我们就需要开始第三步, 证明我们去求解Clique问题就可以去解决SAT问题
Prove: has a clique of size if and only if there is a satisfying assignment for the 3SAT instance
如果图有一个大小的Clique , 则:
既然这个存在, 那么就说明这Clique中的所有两个顶点都相连 的每个顶点都来自于不同的三元组顶点 - 因为, 图有个三元组顶点, 并且三元组顶点中的顶点不能互相连接
没有任何两个的顶点是相互的negation, 因为规则就是那么定的 我们直接把的对应的literal赋值为1, 就能解决这个SAT问题 这是合法的赋值, 因为上面的第二条 - 如果没有这条规则, 就会导致我们把一个bool的正反都设成1
每个Clause都满足条件, 因为上面的第一条 - Clause内部都是用Or连接的, 所以只要有一个bool是true, 就是true, 并且由于每个顶点都是不同的Clause, 所以这样所有Clause都是True. 最后, 就来到了第四步 - 图只有在对应的3SAT有解的时候才存在一个大小的Clique
如果有一个Satifying assignment, 则:
需要表明对应的图有一个大小的Clique
为了做到, 我们可以构建一个大小的Clique , 并且 因为Assignment is satisfying, 所以 每个Clause至少有一个term是1
选择这个term并加入到Clique 中 我们需要证明这个最终的大小就是的: Clique的大小是是因为一共有个Clauses, 并且包含了每个Clause中的其中一个term当做vertex
每两个之间的顶点有边是因为: 这两个顶点并不是来自同一个Triple(三元组顶点)
顶点之间不是相互取反 这样, 我们就完整的证明了这个类似是Clique问题反过来: 也就是我们需要给定一个图, 找到一个Set, 这里面所有的节点都互不相连<br>
<img alt="Pasted image 20250409134038.png" src="cs3100/complexity-theory/attachments/pasted-image-20250409134038.png" target="_self">这个问题就是在图中找到一个顶点的子集, 这个子集里的顶点里所相连的边包含了整个图的所有边如果我们想证明这个问题是NP的, 我们可以去看如果我们有了这个问题的答案, 检验这个答案要多久:
为了检验答案的正确性, 我们需要查看在图中的每个边是否连接着在子集中的顶点, 这个时间是多项式时间内就可以验证的, 所以这是个NP问题但我们现在想证明这个问题是NP Hard:<br>
<img alt="Pasted image 20250409134055.png" src="cs3100/complexity-theory/attachments/pasted-image-20250409134055.png" target="_self">所以, 我们需要在多项式时间内把IS问题变成VC问题:
得构造和 跟原图是一样的, 这个构建过程是多项式时间就可以完成
接着, 我们需要证明图有且只有在有大小的VC的时候, 才会有大小的IS
如果图有大小的IS, 称作:
我们需要证明有大小的VC
是图的所有顶点
则是图中所有不是IS集合的顶点
需要证明是图的VC 因为对于每条边来说, 的顶点不可能全部都在中, 因为是IS
所以, 的某个顶点一定存在于中
这就说明, 肯定与所有的边相连(VC) 如果图拥有大小的VC, 称作
我们需要证明图拥有大小的IS
这就需要证明是一个IS 因为对于每条边来说, 相连的两个顶点其中至少有一个会在VC中
所以, 相连的两个顶点不可能同时出现在中
这就表示是一个IS 这个跟Vertex Cover有点相似: 给定一个Set , 里面有个元素
并且给定个的子集
对于的Set Cover就是我们需要从给定的子集中选出一些, 这些的子集的合集, 就是, 也就比如可想而知, 找到最小的Set Cover是最难的: 因为如果我们已经找到了Set Cover了, 则我们往这个Set Cover中不管加几个新的Set , 这仍然是个Set Cover首先, 我们先来证明这个问题是NP的:
如果我们得到了答案, 也就是sub-collection of subset, 我们只需要查看这些Subset的并集是不是就行. 很显然, 这可以在多项式的时间内完成然后, 我们来证明这个问题是NP-Hard的:
我们可以用Vertex Cover问题去做归约法 - 也就是给定一个VC问题, 我们可以在多项式的时间内构建成Set Cover问题. 然后再去检查这两个问题之间是不是一个成立, 另一个也一定会成立.所以, 我们需要考虑如何把一个VC问题转换成Set Cover, 其实这是有迹可循的:Vertex cover: Use vertex to cover edge
Set cover: Use subset to cover U
对应下来, 我们就需要把顶点变成一个个的Subset, 然后把所有Edge作为U的元素, 而每个顶点相连的边作为这个Subset的元素.<br>
<img alt="Pasted image 20250409143030.png" src="cs3100/complexity-theory/attachments/pasted-image-20250409143030.png" target="_self">
对于构建的过程, 我们可以这么描述:
Construction of an instance of SC based on G and k:
: 图的所有的边
对于图中的每个顶点, 构建对应的子集, 子集的元素就是所连接的所有的边 这个构建过程是能在多项式的时间内完成的
<br><img alt="Pasted image 20250409142742.png" src="cs3100/complexity-theory/attachments/pasted-image-20250409142742.png" target="_self">这个问题有点像Vertex Cover: 也就是给定一个图, 我们需要找到一个顶点集合, 这个集合和图中的所有顶点相连, 而VC问题是需要找到一个子集, 这个子集的顶点连接了所有的边<br><img alt="Pasted image 20250409143947.png" src="cs3100/complexity-theory/attachments/pasted-image-20250409143947.png" target="_self">现在, 我们需要先证明这个问题是NP问题:
我们得到的答案是一个顶点的集合, 我们只需要检查图中所有的顶点是否在中或者被相连
这个会在多项式时间内完成接下来, 我们想判断这个DS问题是否是NP-Hard问题:
我们仍然是可以用VC问题去归约, 就像上面的例子, 只要是Vertex Cover的答案, 也是DS的答案, 但DS的答案不一定是VC的解.(如上面的和都是DS的解, 但前者不是VC的解)所以, 我们不能直接拿DS去解决VC去证明归约是成立的: 因为我们只能拿VC的解得到DS的解, 但是DS的解不一定等于VC的解为了做到这个, 我们需要修改图让两边的答案都能互相转换:
再来回看这个问题:VC - find vertices to cover edges
DS - find vertices to cover vertices
我们可以把每条边都转化成一个额外的顶点. 但如果直接把每个边转换成顶点的话, 又会导致新的问题: 比如和之间多了一个顶点, 我们不可以直接从到了, 因为中间隔了一个新的顶点.
为了解决这个问题, 我们可以再加一个边, 让这两个顶点相连.
这样, 如果我们可以通过找DS来去解决VC了: 因为DS需要找到相连所有顶点的顶点子集, 而我们把边也变成了顶点, 所以只要我们找到了答案, 说明我们相连了所有的顶点, 也相连了所有的边
而VC到DS的转化也是可以的: 因为VC的答案已经相连了所有的边, 但每条边必须连接某个顶点, 所以我们就会知道VC的答案永远会相连所有存在的顶点<br>
<img alt="Pasted image 20250414141255.png" src="cs3100/complexity-theory/attachments/pasted-image-20250414141255.png" target="_self"><br><img alt="Pasted image 20250414141459.png" src="cs3100/complexity-theory/attachments/pasted-image-20250414141459.png" target="_self"><br>
<img alt="Pasted image 20250414141518.png" src="cs3100/complexity-theory/attachments/pasted-image-20250414141518.png" target="_self"><br><img alt="Pasted image 20250414143048.png" src="cs3100/complexity-theory/attachments/pasted-image-20250414143048.png" target="_self">]]></description><link>cs3100/complexity-theory/complexity-theory.html</link><guid isPermaLink="false">CS3100/Complexity Theory/Complexity Theory.md</guid><pubDate>Tue, 22 Apr 2025 06:44:25 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Virtual Memory]]></title><description><![CDATA[虚拟内存主要是在硬件层面上提供的支持
这个主要是发生在读取/存储信息的时候: 比如lw的时候它会把原本的地址替换成虚拟的内存地址. 如我们程序给CPU发指令说要存储数据, CPU会把程序发送的虚拟地址用MMU - Memory Manage Unit进行转换成真实的物理地址, 然后去访问内存.<img alt="Pasted image 20250315194422.png" src="cs4400/attachments/pasted-image-20250315194422.png" target="_self">
上图是虚拟内存布局的示意图, 对于每个程序来说都是这个布局, 而对于实际物理的内存数据的布局, 我们并不知道它具体是什么样因为虚拟地址完全是MMU定义的, 所以可能在两个不同的程序中, 他们分别的两个不同的虚拟地址实际指向同一块实际的地址, 或者两个相同的虚拟地址指向不同的物理地址.
甚至都可能不指向内存的物理地址, 而是指向硬盘的某块空间. 这时候可能会想: 这样不会让Spatial Locality的优化变差吗? 实际上真正的MMU会把连续的一段虚拟地址映射到连续的一块物理地址. 这每一小块都叫做"页" - Page
一般来说, Linux的页的大小是4KB, 现代的操作系统通常是16KB的页大小.像之前进行Fork后, 就会创建一个相同的子程序, 并且速度很快, 这是因为复制的时候根本没有复制任何数据 - 我们只是把两个程序的虚拟地址指向了同一块地方.
等等 - 之前不是说过: 两个线程就算是Fork出来了, 也不会共享数据吗? 为什么他们俩的虚拟地址指向同一块物理地址, 但实际上不会共享数据呢? 这是因为Lazy Copy: 当我们真正开始修改数据的时候, 才会开始修改虚拟地址的映射到一块新的物理地址上, 并且把对应的数据也复制过去 - Copy On Write
这样做的好处就是Fork的时候很快, 并且由于Fork出的进程虽然数据可能不同, 但代码是相同的 - 也就是说在内存中储存的代码仍然可以这么共享, 因为我们通常是不会去修改它. 对于现代的x86-64系统, 通常有48bit来当做虚拟地址, 这表示虚拟内存有256TB那么多.
而实际上, 物理内存大多只有16G ~ 1TB.
所以我们就得映射一大块虚拟内存到物理内存上, 为了做到这一点, 实际上我们可以用类似Cache使用的操作:
对于虚拟内存, 有Virtual Page Offset bits, , 而Virtual Page Number有 bits.
对于物理内存, 有Physical Page Offset, 对应的上面 bits, Physical Page Number是 bits如对于一个48bits的虚拟地址, Offset bit number是12, Virtual Page Number是48-12=36 bits, 这也就是说, 有那么多的虚拟页物理和虚拟地址映射的时候, 使用Page Table来进行查询, 这个Page Table存在于物理内存中, 更准确的是包含在了Kernel Memory中.
对于页表查询的时候, 通过VPN(Virtual Page Namuer)在表中查询可得到PPN, 然后在后面拼接上VPO, 就得到了真正的物理地址但因为Page Table完全体非常大, 我们肯定不可能全部存下来我们会发现, 这个Page Table由于映射关系, 大部分空间都是空闲的, 空间占用是一段一段的 - 局部连续, 但宏观上看内存数据分布是非常稀疏的.所以就引出了Multi-Level Table来节省内存使用: 它会有不同的层级 - 就像多叉树一样: 第一层级(Page Global Directory)比方说就被分成了4块
第二层级(Page Upper Directory)会在第一层级的基础上每块再分4块
第三层级(Page Middle Directory)又会在第三层分4块 - 块
第四层就是原本的页表
因为分成了4层, 每层的数量相同, 所以我们把前面的内存bit(36bits)分成4块, 一块9bits, 分别代表每层
因为每块是9bit也就是512种可能, 表示的就是这是一个512叉树
虽然会需要更多的数据记录每个层级的情况, 但在虚拟内存没有完全用完的情况下, 它是远远比直接映射省空间的示例（3 级页表查找） 假设需要访问虚拟地址 0x12 = 010010: 取 VPN 的第一个部分（如 01），在 Level 1 Page Table 中查找。
取 VPN 的第二部分（如 00），在 Level 2 Page Table 中查找。
取 VPN 的最后一部分（如 10），在 Level 3 Page Table 中查找，获取最终的 PPN。
下面是一个Page Table的例子:<br>当我们发生了<a data-tooltip-position="top" aria-label="OS > ^964d62" data-href="OS#^964d62" href="cs4400/os.html#^964d62" class="internal-link" target="_self" rel="noopener nofollow">Page Fault</a>后, 如果数据不是Vaild - 因为数据还在硬盘中而不是在内存中, OS会开始修改Page Table来尝试解决: 因为数据不在内存中, 但内存是有限的, 所以OS就会把一些不太重要的数据移会硬盘, 然后把需要的数据从硬盘移到DRAM
但如果Page Fault的原因是因为我们读取Page Table中完全没有的VPN, 则会直接报错因为每个程序都有个自己的虚拟内存, 所以我们会有一个Page Table Pointer, 存放在寄存器中(PTBR- Page Table Base Register), 如果发生Context Switch - 切换到其他的程序了, 这个寄存器的数据也会指向Page Table的新的地方这个类似于也是一个Cache(通常是Fully Associative), 他是一个硬件, 用来加速的过程的, 这样当CPU去寻找物理地址的时候, 就不用返回到内存的页表中去查询地址, 要是TLB中有这个地址, 则直接就能知道物理地址是什么了<br>
<img alt="Pasted image 20250324160753.png" src="cs4400/attachments/pasted-image-20250324160753.png" target="_self">
进程抽象 每个程序都有对整个地址的完全控制 进程隔离 每个进程不能互相访问各自的数据 提供了更大的虚拟空间
共享库, 这样只用Load 一次
每个编程语言有自己的Heap Allocator, 帮助用户分配Heap上的空间, 如C++的malloc就像ABI一样, 堆分配也有很多讲究 ...
Allocator必须:
接受任何合理的内存分配
接受任何次数的内存分配
必须返回一个没有被复用的内存块
不能在分配的块中写任何数据
必须按照顺序回复请求
返回的指针必须是16 - byte 对齐的
使用Allocator的程序员必须:
只能使用分配的内存
只能调用free最多一次对于每个分配的内存
使用Allocator的程序员可以:
可以交错的使用malloc和free
可以不用free就退出进程
我们可以用mmap来映射内存地址void* mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
mmap会请求OS去映射一个或多个内存页, 并把它添加到Page Table中
addr – 填入Null让OS帮我们决定
length – 要分配多少Byte prot – bitwise combo: PROT_{READ,WRITE,EXEC,NONE} flags – MAP_SHARED, MAP_PRIVATE, ... fd – file descriptor (-1 for our purposes) , 这个允许让我们把文件映射到内存中
offset – (0 for our purposes)
虽然malloc它背后的mmap看着挺复杂, 但它自身调用起来很简单
当然我们现在需要写一个malloc和free函数. 我们可以用刚学的mmap函数void* malloc(size_t size){ return mmap(..., size, ...)
}
虽然这种没有违反上面所说的协议, 但它浪费了很多的空间. 我们的目标是尽可能的让下面的值大:
但是呢, 根据mmap的规则, 不管分配多小的内存, mmap都会把它约到一个页的大小: 说明就算我们请求了100byte, 他也会分配4096bytes更好的想法是, 把mmap分配的一页, 切成更小的小块, 如每块16 bytes.
当我们调用一次malloc后, 如请求32bytes, 就会使用其中的两块
这样就需要我们记录这个页中哪里还有空闲的blocks如果这样搞的话, 还得让malloc记录每次调用分配了几块内存, 因为在free中, 我们只提供了一个指针, 没有告诉它我们分配了多少bytes.void free(ptr){
}
为了解决上面的问题, 可能想到的第一个解决方法就是存一个指针, 指向了能用的第一个block
比如如果分配了一个Block, 我们就把这个指针往后移动16 bytes(因为一个block就是16 bytes)
如果当前页被用光了, 就再次调用一次mmap如果这么做的话, 就不可以使用free掉的内存了: 因为我们的指针只会向前移动.为了解决这个问题, 我们可以在每次分配内存时, 在分配的block前塞一个index, 表示分配了几个block+1(因为还要包含index在的block)
如我们分配了两个block, 在那两个block前还有一个3. 因为一个Block有16 byte, 我们还可以再塞一个char / bool, 表示后面的这几个block有没有被free掉.typedef struct{ size_t size; // 8 bytes char allocated;// 1 byte
}block_header; void free(ptr){ void* header = ptr – sizeof(block_header); //只有在blocker_header struct的大小跟一个block相同才可以, 这里struct因为padding刚好是16byte,也就是一个block的大小
}
我们还可以进行Splitting: 也就是如果有一段空间是9*16 bytes, 但我们想分配3*16 bytes, 那么就可以把这个9*16byte的部分分成两段:<br>
<img alt="Pasted image 20250326122042.png" src="cs4400/attachments/pasted-image-20250326122042.png" target="_self">
这里的最后一个是一个特殊的Header: 它叫做Terminator, 表示下个block大小是0, 并且已经被占用了
<br><img alt="Pasted image 20250326122057.png" src="cs4400/attachments/pasted-image-20250326122057.png" target="_self">
但这样的话, 就会导致Fragmentation: Block header会越来越多, 然后整个内存会被分为越来越小的一段一段
为了缓解这个问题, 我们可以在每次free的时候, 向后或者向前查看有没有空闲的block, 如果有的话, 则合这两段内存<br>
<img alt="Pasted image 20250326122135.png" src="cs4400/attachments/pasted-image-20250326122135.png" target="_self">
为了向前查看, 这就变成了double linked list - 我们需要加一个footer在header前面, 这样才可以往前走.<br>
<img alt="Pasted image 20250326122154.png" src="cs4400/attachments/pasted-image-20250326122154.png" target="_self">
不过, 为了让我们知道某个Block是不是第一个Block, 我们需要类似Terminator的东西 - Sentinel<br>
<img alt="Pasted image 20250420180239.png" src="cs4400/attachments/pasted-image-20250420180239.png" target="_self" style="width: 300px; max-width: 100%;">
就像上图, Sentinel是半个节点 - 它没有Footer, 也就表示不能往前查询(当然我们也不需要), Header也就只是包含了到下一个正常Block Header的长度.
而Terminator既有Footer也有Header, 因为Header表示这个Block已经被占用, 长度是0, Footer为了找到之前的节点. 所以, 我们就有下面这四种情况:
(这里既没有Terminator也没有Sentinel)<br>
<img alt="Pasted image 20250326122417.png" src="cs4400/attachments/pasted-image-20250326122417.png" target="_self">
但我们其实并不需要去查询邻居的邻居有没有空闲空间, 因为如果相邻的空间是被Free的, 那么它在被释放的时候, 它自己已经会检查左右是否有空闲的, 所以我们不用递归地去查询.我们还需要注意往前查询的时候不可以越界, 当然往后查询也不可以, 一种方法是增加Sentinel和Terminator, 前面的是Sentinel, 后面的是Terminator.<br>
<img alt="Pasted image 20250326123013.png" src="cs4400/attachments/pasted-image-20250326123013.png" target="_self">
我们在这里Sentinel的大小是2是因为2告诉了这不是一个合法的block: 最小的数字应该是3, 不然两个index之间就没有可用空间了.写代码的时候, 可以用define来简化我们的代码:#define GET_SIZE(p) ((block_header*)(p))-&gt;size
#define OVERHEAD (sizeof(block_header) + sizeof(block_footer))
因为padding的问题, 我们的Struct实际上只用了9byte, 但占用了16byte的空间, 我们可以尝试压缩这个struct:
我们可以注意到, 一个Block是16个byte, 并且上面图中的数字都是简写 - 意思就是它是几个block, 我们实际写的时候要写Block count * 16, 这样, 在16进制/2进制上看, 最后一位就永远是0, 所以我们就可以把这个Free的一个bit的信息编码写在size的信息里面<br>
<img alt="Pasted image 20250326124818.png" src="cs4400/attachments/pasted-image-20250326124818.png" target="_self"><br>
<img alt="Pasted image 20250326124840.png" src="cs4400/attachments/pasted-image-20250326124840.png" target="_self">
上面就是压缩的例子: 0x21=00100001, 0x2=32, 因为一个block是16byte, 这个Header是存的size是2, 所以就是16*2=32, 然后再在最后一位放上1, 表示这个Header是没有被free的typedef size_t block_header; #define GET(p) (*(size_t *)(p)) #define PUT(p, val) (*(size_t *)(p) = (val)) #define PACK(size, alloc) ((size) | (alloc))
但由于我们返回的地址需要是16byte对齐的, 所以在第一个Block前要加一个8byte的padding, 因为那个block是allocated block, 我们不能向前查询, 也就没有footer.上面的查询都是依靠header 和 footer来进行向前 / 向后查询, 但然而如果一个page很大, 并且里面有很多占用的frag, 就会很耗时间. 这时候, 我们就可以在frag中再添加一个指针, 表示之后的free block, 甚至再加一个向前的指针表示之前的free block. 这种方法叫做explicit free list<br>
<img alt="Pasted image 20250401125744.png" src="cs4400/attachments/pasted-image-20250401125744.png" target="_self">]]></description><link>cs4400/virtual-memory.html</link><guid isPermaLink="false">CS4400/Virtual Memory.md</guid><pubDate>Mon, 21 Apr 2025 02:54:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250420180239]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250420180239.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250420180239.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250420180239.png</guid><pubDate>Mon, 21 Apr 2025 00:02:39 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[HW6]]></title><description><![CDATA[If a computer can execute instructions per second
Assume one year has 365.25 days(consider the leap year), so there are seconds in a year, and there are seconds in a centurythen it can execute instructions per centuryIf n=100, then in total, it needs Centuries to finish the algorithmIf n=1000, then in total, it needs Centuries to finish the algorithmTrue, since Partition problem is a NPC problem, since every NPC problem can reduct to any other NPC problem in polynomial time, so Partition can be reduct to any other NPC problem. This means that we can solve any NPC problem by just solving Partition problem in polynomial time.True, same as above, since both 3SAT problem and Clique problem are NPC problem, which is NP-Hard problem. Since we cannot solve 3SAT problem in polynomial time, we can still not solve Clique peoblem in polynomial time, since both of them are equally hard, and NPC can reduct to each other in polynomial time.
If we can't solve 3SAT in polynomal time, but can solve Clique in polynomal time, this will cause contradictionTrue, since both problem are NPC problems, which they can reduced to each other in polynomial time according to the theory studied in class.Our goal is to reduct a subset-sum problem in to partition problem in polynomial time.To achieve this, first, we can have a subset sum problem:First, we can calculate the sum of set : Then, we can construct a new Set , which means that there are two more elements in set than set - and these two element's sum is This transformation clearly takes polynomial time.Then, we need to prove relation between two problems:
First, we need to prove if subset sum has solution, then partition problem also has solution:
If there is a subset in which sum is , then can be split in to two parts: and : Because First part is , and second part is , so they are euqal.Then, we need to prove in opposite way:
If can be partition in to two parts, then the subset sum will also have the solution:
If we can partition in to two same sum set, then two set should have size of , total Since those 2 elements that we added's sum is , which is larger than , then they will not in the same set. As the result, we will known that , which is the sum of the answer , so we will know there will be a subset which sum is Our goal is to reduce Clique problem to IS problem in polynomial time.
To reduce Clique problem in to IS, we can construce a new graph such that:
For every node, we keep it same is orignal
For every edge, we add an edge between two node if thses two node isn't connect in the origninal graph .
This construction can be done in polynomial time (about ).
We can solve IS problem on the new graph to solve the orignal Clique problem:
If a node is not connect with another node in the this means that in the original graph, this node is connected with that node. Same as three node or more. So we just need to find a IS in the to get the answer of the Clique problem.Then, we need to prove two problem's relationship is :
If there is an answer for Clique, then there should be an answer for IS problem: Because every node in clique are connected, so in , all these node will not connect to each other, then they will occor in the answer set.If there is an answer for IS, then there should also be an answer for Clique problem: Because if in the , we got a independent set, this means that this set's node will not connect to each other, as a result, in the original graph , all these node will be connected with eachother - which is a clique.a:
To prove this problem is NP, we need to show that if we have answer of this question, we can verify it in polynomial time.
In this problem, the answer is the subset . If we want to verify the answer, we need to check if subset has at least one element in each subset .
For each element in , we need to check each element in , which means that we need to check times. This can do in polynomial time.
As the result, the Hitting Set Problem is NP problemb:
To prove the problem is NP-Hard, can reduce some other NP-Hard problem to this problem in polyminal time, so we can show Hitting Set Problem is at least as hard as that problem(which is NP-Hard).We can reduce Vertex cover problem in to Hitting Set Problem in polyminal time to show Hitting Set Problem is NP-Hard.First, we need to reduce the Vertex cover problem to Hitting Set Problem:
We can create a new set 's every element is a node from Vertex cover problem's graph.
Then we can set each subset equal to the two node of each eadg: for example, if a edge connect vert , then there will be a subset .
Then, when we solve Hitting Set Problem, we need to find if there is a subset in that contains at least one element of each subset . If we find one, it means that we find the answer for the vertex cover problem: since each subset is an edge, and having at least one element in each subset means we have at least one vert connect to every edge in the graph.Then We need to prove if the relation is :
If there is an answer in the vertex cover, there will be an answer in the Hitting Set Problem: this is true because each edge is equal to a subset , and this is one to one relationship. Since we find a subset that contains group of verts that connect to every edge, then we will also get a subset that contains at least one element of each subset .If there is an answer in the Hitting Set Problem, there will also be an answer in vertex cover problem: since and each edge is one to one relationship, it means that if we find a subset that constians at least one element in , then we will also got a group of vert that connect to every edge.]]></description><link>cs3100/hw/hw6/hw6.html</link><guid isPermaLink="false">CS3100/HW/HW6/HW6.md</guid><pubDate>Thu, 17 Apr 2025 04:20:33 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250416124520]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250416124520.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250416124520.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250416124520.png</guid><pubDate>Wed, 16 Apr 2025 18:45:20 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250414143048]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250414143048.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250414143048.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250414143048.png</guid><pubDate>Mon, 14 Apr 2025 20:30:48 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250414141518]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250414141518.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250414141518.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250414141518.png</guid><pubDate>Mon, 14 Apr 2025 20:15:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250414141459]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250414141459.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250414141459.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250414141459.png</guid><pubDate>Mon, 14 Apr 2025 20:14:59 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250414141255]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250414141255.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250414141255.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250414141255.png</guid><pubDate>Mon, 14 Apr 2025 20:12:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250409143947]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250409143947.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250409143947.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250409143947.png</guid><pubDate>Wed, 09 Apr 2025 20:39:47 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250409143030]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250409143030.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250409143030.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250409143030.png</guid><pubDate>Wed, 09 Apr 2025 20:30:30 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250409142742]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250409142742.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250409142742.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250409142742.png</guid><pubDate>Wed, 09 Apr 2025 20:27:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250409134055]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250409134055.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250409134055.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250409134055.png</guid><pubDate>Wed, 09 Apr 2025 19:40:55 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250409134038]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250409134038.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250409134038.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250409134038.png</guid><pubDate>Wed, 09 Apr 2025 19:40:38 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250407135911]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250407135911.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250407135911.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250407135911.png</guid><pubDate>Mon, 07 Apr 2025 19:59:11 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[C语言]]></title><description><![CDATA[ C语言主要是为了尽可能的利用OS和CPU或者内存的性能C语言和其他高级语言有很大的不同
比如, 在Java中创建数组, 其实是创建了一堆pointer, 每个指针指向了一块内存, 而C是单纯的让系统分配一块内存, 这个内存存储了所有的数据这是一个最简单的程序int main(){
}
但为什么返回int的函数没有return? 这是因为仅仅对于main来说, 这是个特例. 这个返回的数字是传递给shell或者说是系统的, 这样系统就知道这个程序有没有工作, 又返回了什么. 至于为什么会返回int, 只是因为这是个约定俗成的协议. 默认来说, 如果返回0, 说明程序执行成功, 如果返回其他数字, 如1, 则这个程序则执行失败. 所以, 还是在main中写上return 0 比较好吧. 在C中, 最常见的输出方式就是用Std I/O 库#include &lt;stdio.h&gt;
int main(){ printf("Hello"); return 0;
}
在printf中如果想输出", 则我们需要在这种特殊符号前面加上"\" 这种转义符如果想在输出中输出变量, 则需要写#include &lt;stdio.h&gt;
int main(){ int x = 5; printf("x = %d", x); printf("%d, %d, %d", x, x, x); return 0;
}
在这里, "%d"就是表示这里应该插入一个变量. 如果有多个%d, 则需要给多个变量通常来说, C没有16 bit的int, 但是可以#include &lt;stdint.h&gt;来得到这种类型所有的程序都运行在flat space address中, 也就是0~2^64-1 的地址, 这对于C语言来说是蛮重要的, 因为它更底层, 也有对地址更多的操作方式就像C++, 在C中, 在类型后面就可以得到对应类型的指针int*
char*
float*
foo*
void*
最后一个指针, 它指向了一个空, 也就是我们表示不关心它到底指向了什么.
至于为什么很多人喜欢写int *a, 而不是int* a 是因为如果要一次声明多个指针的话, 看起来就会怪怪的.int a = 5;
int *p;
p = &amp;a;
int **p2 = &amp;p;
不难理解, 这种跟之前学的C++的原理都是一样的.int main(){ int a = 5; int *p = &amp;a; *p = 10; printf("%d\n",a); //Pring 10 printf("%d\n",*p); //Print 10
}
包括解引用也一样, 直接把*放在指针前面就可以获取指针的内容.与C++一样的是, C也可以对指针进行加减法<a data-tooltip-position="top" aria-label="C++ 特性 > Array" data-href="C++ 特性#Array" href="cs3505/c++-特性.html#Array_0" class="internal-link" target="_self" rel="noopener nofollow">C++中的指针运算</a>int mian(){ char c; char *p = &amp;c; printf("%c\n", *(p+1)); //未定义行为
}
这里就是把指针往前偏移了一位, 打印了完全没有用的地址的内容. (或者说把这个char* 看作一个长度1的array, 我们尝试获得第二个元素.)char arr[5];
//arr存放着第一个字符, 而arr+1就可以得到第二个元素.
需要注意的是, *p对+有更高的优先级, 比如*p + 1会使这个指针指向的元素+1, 而不是把这个指针偏移. 但比起这么写, 不如加上括号看着舒服.在C语言中, 数组永远是连续的一块内存写代码遍历数组的时候, 不要硬编码array的长度, 而是用函数获取数组的长度int arr[5];
sizeof(arr); //return 20 int length = sizeof(arr) / sizeof(int);
for(int i = 0; i &lt; length; i++){} int *p = arr;
sizeof(p); //return 8
需要注意的是, 这个sizeof()看起来是个函数, 实际上它是个操作符. 它会返回这个数组占用的大小, 以byte为单位. 所以就需要用上面这种方法来得到数组的长度.所以, 如果我们用一个指针指向array, 就会立刻失去这个array的长度, 因为指针的大小是固定的. 它是64bit (8byte).上面用[]创建的数组都是在栈上面的, 如果出了范围, 会被自动销毁, 如果想把arr的内容创建在heap上, 需要用malloc函数#include &lt;stdlib.h&gt;
char *arr = malloc(4);
free(arr);
当然, 这就需要手动释放了
而且, 上面的函数比看起来的复杂一些: malloc()会返回一个void*, 而编译器会隐式转换成char* 从这个特点, 我们就可以知道, 这个函数分配的大小也是按照byte来算的. 因为它返回的是void*, 并不知道我们要分配的元素大小是多少.
所以, 就可以用sizeof() * x来让程序计算想要的大小. 如果在Linux上使用malloc来分配远高于系统内存的大小, 系统不会拒绝, 如果使用那些内存, 就会让系统崩溃, 但在Windows上会拒绝此操作.int arr[2][3];
上面是一个2D 数组的例子, 它也是一个连续的内存, 这个内存前半段存储的是一个长度为3的Int array, 后半段是另一个.
虽然我们经常以2D的形式显示出Array, 然而实际上, 每行的数组都是头接着上一行的Array的尾, 组成一个内存中的一个长Array. 在2D的形式中, 所有的语言都以第一个Index作为行号, 第二个Index作为列号. 先行后列<br>像之前<a data-href="C语言#Pointers" href="cs4400/c语言.html#Pointers_0" class="internal-link" target="_self" rel="noopener nofollow">C语言 &gt; Pointers</a>说的一样, 指针和数组是可以兼容的: arr就是一个指向第一个元素的指针.int A[4][7];
int* p = (int*)A;
p[0] = A[0][0];
p[1] = A[0][1];
p[7] = A[1][0];
p[17] = A[2][3];
*((int* )A + (i * N + j)) = A[i][j];
就算是2D array, 也可以一样操作, 因为它在内存上就是一串连起来的数据struct element{
char name[10];
char symbol[3];
double mass;
} //至此没有内存分配 struct element h = {"Hydrogen", "H", 999};
结构体的数据在内存中的排列跟Array很相似, 都是连续的一段数据: 先是10byte的name, 紧接着3byte的symbol. 它会根据创建时候参数的顺序来排列内存中的数据.所以我们访问元素的mass的时候, 就可以直接在struct的地址上shift 13byte找到我们的数据.
这问题就来了: 地址没有对齐: double的地址需要是8的倍数!<br>
在C的层面上, 访问没对齐的地址是一个未定义行为, 因为在硬件层面上, 这就是个很难做到的事情. 尽管x86-6x / 64bit ARM上已经可以读取了, 但仍然有很大的性能影响. 详见<a data-href="汇编语言#ISA VS 微架构" href="cs4400/汇编语言.html#ISA VS 微架构" class="internal-link" target="_self" rel="noopener nofollow">汇编语言 &gt; ISA VS 微架构</a>为了解决这个问题, 我们会在symbol和mass中间夹三个没有用的byte, 这样就可以让double和8的倍数对齐. struct thing{
char a;
short b;
double c;
int d;
}
比如上面的这段代码, 由于char只占用了1, short就需要在char后面加一个byte来对齐2的倍数, 但double有需要再short后面塞4个byte来和8对齐. 这就导致了这个结构体需要占用最少20个byte并且, 由于只占用了20个byte, 如果想跟4的倍数对齐的话, 就需要在结尾塞4个byte来让结尾对齐, 这叫做End Padding. 因为在Array中, 每个Struct需要跟Struct中最大的元素(这里是double)的倍数对齐可以看到, 里面虽然只有15个byte的数据, 但用了24个byte, 非常不节约. 如果重新排序一下, 就可以只用16byte了:struct thing_optimized { double c; // 8 字节 int d; // 4 字节 short b; // 2 字节 char a; // 1 字节
};
这个是用来让编译器知道一个类型还有另外一个名字, 它不会创建一个新类.//format: typedef &lt;typeName&gt; &lt;NewName&gt;
typedef float real;
或者, 我们可以用typedef来免去写structtypedef struct element element;
element h = {...};
这样, 我们每次创建element就不用像前面那样写struct了.
或者可以直接在创建结构体的时候直接加上typedeftypedef struct element{
char name[10];
char symbol[3];
}element; 如果想copy一个char*到另一个char*中(是内容, 不是地址), 可能想到的是转成int*, 然后作为pointer去找这个char的内容. 然而, 这是容易出错的, 因为alignment问题: 比如所有的short的地址都需要是双数结尾, int的地址是4的倍数, long是8的倍数... 正确方法是用memcpy#include &lt;string.h&gt;
memcpy(void *dst, void *src, size_t n);
这个size就是我们要拷贝的数据类型的byte大小Endianness表示的是一个多byte的数据在内存中保存的顺序: 是最大位在前, 还是最小位的byte在前?这种东西大部分时候都用不上, 不过如果我们要在不同的endianness的系统上传文件, 或者查看raw data的时候, 这个问题才会出现在C语言中, 程序不知道String的长度, 而是地址指向第一个char的地址, 往后的所有char都是String的一部分, 直到遇到了一个0字符. 可以用strlen(string)来获取一个String的长度, 这个长度不包含最后的结尾0字符.需要注意的是, 如果使用malloc()函数来给String分配空间的时候, 需要手动分配最后的结尾0字符 - 也就是对于长度3的字符需要分配4char的空间像Array一样, 如果想创建一个array of string(double array, 可以char* string[2];
这个表示的是创建一个array, 里面存放了两个指针, 指向了两个不同的String在C语言中, 如果在IF 语句中, 我们也可以传递int进去, 只有int是0的时候是false, 剩下的所有值都是true, 比如!0就是true, 42 &amp;&amp; 9也是true在bit shifting的时候, 符号性是很重要的://对于有符号的int &gt;&gt;, 会复制最左侧的数字: 10011 &gt;&gt; 2 = 11100
//对于无符号的int &gt;&gt;, 不会复制最左侧的数字: 10011 &gt;&gt; 2 = 00100
并且在类型转换的时候也会有区别: 如果把一个char变成int:
如果char是带符号的, 则char前面都会被填充上char最高位的bit以保持数值正确, 而如果char不带符号, 则直接在char前面更高bit填充0就行反过来如果int变成char的话, 则高位bit都会被直接裁掉.如果让int和unsigned int互相转换, 则直接把bit拷贝过去, 虽然bit pattern没有改变, 但由于类型改变, 得到的结果也会变, 如很大的一个数变成负数.Defined Behavior: 正常的操作, 得到的结果也是固定的Implementation-Defined behavior: 这种行为会被编译器所决定, 在所有机器上会得到一致的结果, 但编译器不同, 可能会导致不同的结果Undefined Behavior: 这种行为一般都是错误的, 会导致不可预测的结果通常来说, 第一要义是保证程序运行, 优化是硬件考虑的事情 - 硬件性能迭代很快
但这不意味着可以完全不管优化: 再牛逼的硬件, 再神奇的编译器也没办法把一个很差的数据结构优化的很好不止coding层面优化, 编译器也会优化代码:
Func Inline 这个表示的就是编译器会找出会不会有些函数只用了一次, 然后直接把这个函数写在被调用的地方. 这样就会很少用到ABI
Instruction Selection: 编译器会选择最适合代码的函数, 如x86-64有一个rol函数, 它是用来bit shifting, 但shift到外面的会在结尾出现. 虽然c语言中没有, 但如果在c语言中试图写一个rotating func, 编译器会看出来, 并调用rol或ror函数
Dead Code Elimination: 编译器会找出有没有哪部分代码永远不会用到, 在编译的时候就会忽略掉那些代码
Common Subexpression Eliminationint f = factorial(5) + factorial(5);
这就是单纯的阶乘, 明明可以直接把阶乘结果*2
但编译器很难知道: 如果这个函数在其他文件中, 它不知道这个函数是单纯的计算, 要是这个函数修改了全局变量呢?
但如果函数在当前文件中, 编译器就可以找出这种问题, 然后优化成factorial(5) * 2, 甚至直接优化成240.Hoisting Loop Invariant Code
这种表示的就是在一个Loop里不停的调用一个函数, 但得到相同的结果.
这种情况跟上面一样, 如果编译器知道这个函数不会修改其他东西 (这种被称作Pure function), 则它就会把这个函数移到loop外面. Division By Constant
编译器可能会把这种除法变成位运算: 如x / 8 = x &gt;&gt; 3
乘法也是一样.Reciprocal Math
在CPU上, 除法比乘法慢, 所以可以有下面这种操作double len = Length();
x /= len;
y /= len;
// Rewrite double invLen = 1.0/Length();
x *= invLen;
y *= invLen;
Mul By Constantleaq (%rsi,%rsi,8), %rax leaq (%rsi,%rax,2), %rax imulq $19, %rsi
如果要把一个数乘19, 编译器会选择不同的方法, 比如上面的两段代码都会有同样的结果总结
编译器在大部分时候还是很聪明的, 我们要相信编译器, 并写编译器能看懂的算法: 比如一个for loop用自己的方法去优化, 最后可能导致编译器没看懂, 反而没有直接写一个简单的loop, 让编译器优化得到的性能好.当然, 还是那句话, 编译器再怎么优化, 大多数情况下它都改变不了算法的BigO, 如O(N²)不会变成O(N), 但编译器通常会把BigO里面的常数降低.
编译器对于单个函数优化很好, 除了inline, 函数之间的关系, 编译器是不会优化, 更别说多个代码文件之间. 因为编译器根本不可能知道用户的输入是什么, 它得到的只有源代码.有些东西, 是程序很难优化, 但在程序员方便很容易:<br>详见<a data-href="汇编语言#循环展开" href="cs4400/汇编语言.html#循环展开" class="internal-link" target="_self" rel="noopener nofollow">汇编语言 &gt; 循环展开</a>现在的CPU大多都有三层缓存: L1,L2,L3 这种被称作SRAM, 非常非常快
还有一个更加广为人知的内存: DRAM, 也就是内存条提供的内存. 之所以叫D-Dynamic内存, 是因为没电数据就消失了
再往下, 就被称为Storage了, 也就是我们的硬盘 - 虽然可以存数据, 但相比SRAM甚至DRAM显得非常的慢.数据在内存中存放的Pattern也有专门的名字:
Spatial Locality: 相邻的数据更有可能被访问 - 如遍历一个数组.
Temporal locality: 刚放进缓存里的数据更有可能会在将来访问 - 如loop里的临时数据i
就像3810中学的一样, CPU读取数据是按块(Block)读取的, 也就是说最小的单位就是一个Block, 现代的CPU的一个Block通常是64~128B的数据.
并且现在的CPU通常都是用Set Associative的优化方案: 比如2 Set就可以在同一行存储两个Block, 提升Hit rate. 这样就算两个Block在Cache里map到了同一行, 也可以记录下来.至于Cache如何存放每个Block, 并访问每个Block的某个Byte, 可以看3810笔记.由于大部分时候都是Cache Miss导致的性能损失, 所以对于性能来说, 应该看Cache Miss Rate:
如99%的Cache hit比98%Cache Hit Rate快了大概一倍, 因为少了一半的Cache Miss既然Cache Hit Rate这么重要, 那我们来计算一下:
假设arr是一个chardouble array:for(i = 0; i &lt; 8; i++){ for(j = 0; j &lt; 4; j++){ arr[i][j]...; }
}
假设我们的Cache 有4 Set, direct mapping, 每个block只有4byte.
那么我们的Cache Miss就是25% 并且这是最优解了: 每一行的第一个都是Cache Miss, 然后剩下3个是Hit.for(j = 0; j &lt; 4; j++){ for(i = 0; i &lt; 8; i++){ arr[i][j]...; }
}
如果我们把代码改成这样: 我们还是8行4列, 但我们访问的顺序是: 先把每行的第一个元素访问, 然后是每行的第二个...
由于数组在内存中是Row major - 也就是对于一行的数据在内存中是连续的.
这样就导致我们Cache Miss Rate提升到了100%. 因为每行的第一个元素都是Cache Miss, 但由于遍历到第五行的时候, Cache已经用完了, 我们会把之前第一行的Block给挤掉, 然后访问第一行的第二列也是Cache Miss.当然, 这种问题是由于Cache超级小. 但在正常电脑上, 我们可能会去访问一个很大的Matrix. 仍然会遇到同样的问题. 尤其是做图片旋转这种问题: 因为我们需要同时用Column Major 和 Row Major access的方法去访问数据, 就总有一部分数据是很高的Cache Miss Rate.但这种问题不是无解的: 我们可以把矩阵拆成更小的块, 这样就会让矩阵相对于Cache没有那么大, 每个块能完全放在Cache中, 这样就可以保证不管是Row Major Access还是Column Major Access都可以有不错的Cache Hit Rate. 这种操作叫做矩阵分块比如上面的Column Major Access的代码, 我们把它分为两块, 一块只有4行, 这样每块正好可以放进Cache中, 然后就能保证就算我们以Column Major的访问, 也可以拥有25%的Miss Rate.不过, 有时并不是矩阵分块永远是最好的方案, 因为它会让Branch Predictor更加难预测, 指令缓存也会增加负担.上面讨论了很多优化的情况, 这里来说一些什么会阻止编译器优化:Function Call
这个就像上面说的阶乘一样: 编译器会对函数做最坏的打算 - 因为它不知道其他文件的函数到底干了什么
为了解决这个问题, 我们可以
把数据存在local, 如果没有全局变量, 则编译器就知道它不会修改全局变量
调整调用函数的顺序, 让ABI出现的更少(比如调用函数要存储寄存器)
把函数放到当前文件中(通常不太现实)
Pointer Alising
访问指针的时候, 编译器很少会优化, 因为如果指针指向同一个地址就会导致结果不一样: 答案从a+2*b变成了a *= 4void a_plus_2b(int* a, int* b) { *a += *b; *a += *b; }
对于编译器来说, 如果它不能证明这两个指针一定指向不同的地址, 则它就会认为这两个指针有指向同一个地址的可能, 然后读取两次b的内容, 而不是优化成a+2b 这种情况不仅仅是两个int指针, 如果是unsigned int和int`, 也会出现这种问题这种特性叫做严格别名规则 (Strict Aliasing Rule) 这个规则对char*和void*无效: void a_plus_2b(int* a, char* b) { *a += *b; *a += *b; }
比如上面这种情况: 就算char和int是两个不同的类型, 但编译器仍然会load两次b. 所以说, 虽然Type-Based Aliasing可以帮我们优化代码, 但我们需要在cast指针类型的时候格外注意这个问题, 因为用错误的指针类型访问内存数据是一个Undefined Behavior.
如果想用两个不同的指针访问同一个地址, 推荐用memcpy函数, 本质上就是用char*去访问那块内存实际上, 我们可以直接在C中使用汇编, 如可以在C中执行汇编的Syscall#include &lt;unistd.h&gt; #include &lt;asm/unistd.h&gt; #include &lt;stdio.h&gt; int my_getpid(void) { int ret; asm volatile ( "syscall" : "=a" (ret) : "0" (__NR_getpid) ); return ret; }
上面的虽然很复杂, 但实际上变成汇编就是这样的:my_getpid: movl $39, %eax syscall ret
]]></description><link>cs4400/c语言.html</link><guid isPermaLink="false">CS4400/C语言.md</guid><pubDate>Mon, 07 Apr 2025 17:44:34 GMT</pubDate></item><item><title><![CDATA[GDB]]></title><description><![CDATA[ctrl-x + o: 切换layout / 终端操作
ctrl-x-a: 打开layout
layout asm / layout src 切换layout显示
info breakpoints: 显示所有断点
d: 删除所有断点
d #: 删除某个断点
x/&lt;n/f/u&gt; &lt;addr&gt;: 查询地址的数值, f是format, 有x, d, u, o, t,c, f, u是uint, 表示数据的大小: b, h, w, g分别是1, 2, 4, 8字节]]></description><link>cs4400/gdb.html</link><guid isPermaLink="false">CS4400/GDB.md</guid><pubDate>Fri, 04 Apr 2025 21:00:31 GMT</pubDate></item><item><title><![CDATA[HW5]]></title><description><![CDATA[For this problem, we can solve it by using the theory that we studied in class:
At here, we need to make a Decider TM that decide language A Convert 's NFA to DFA Make a new DFA which Run , If it accept, we accpet, otherwise reject.
Since is decider, so should also be a decider.For this problem, we can solve it by using the theory that we studied in class:
At here, we need to make a Decider TM that decide language A: Construct two DFA which equals to the regular expressions Construct another DFA where Run on , if it accept, then accept, otherwise reject.
Since is decider, so should also be a decider.
For this problem, we can directly use to solve it, since it can decides if a a CFG can generate a given string.
So, we can Construct a new Turing machine : Run a on , if it accept, thenaccept, otherwise reject.Since will check if there is a specific string in this CFG, we can know if there is in this CFG's language.By proof by contradiction, assume there is a turing machine which can decide Then, we can try to construct a new turing machine that decides : Construct a new turing machine : If looks like , then accept
If not, run to test , if it accept, then accept, else reject. Run on If accept, it means accept the , makes , then we accept; otherwise, if reject, it means reject the , makes , so we reject.
Proof decides :
If , then will accept , which cause , which is a context free language.
If , then will refuse , which cause , which is not a context free language.
By proof by contradiction, assume there is a turing machine which can decide Then, we can try to construct a new turing machine that decides : Construct a new turing machine : Run to test , if accept, accept, else reject Run on If accept, it meas that , since accept every strings (because accept ); otherwise, we can know that reject cause , and will reject Proof decides :
If , then will accept , which cause , which will be accpeted by since is also included in If , then will refuse , which cause , which will be rejected by since it does not include .
By proof by contradiction, assmume there is a turing machine which can decide Then we can try to constuct a new turing machine that decides We can construct another CFG , that Then we can run the machine over the the
If machine accepts, then we accept, else reject.
Proof decides :
If , then will also be accepted by since it has same language with If , then will also be rejected by since it has different language with This question can be reducted to , which is a Turing-recognizable question. is a language that takes a turing machine and a input string , if halt and accept So, we can construct a turing machine that can recognizes : Enumerate all strings in string order
Simulate in this order: Run 1 Step on Run another Step on , run a step on Run another Step on and , run a step on ... If any simulation halts, accept Since we already proofed that is Turing-recognizable, so this question - is also a Turing-recognizable language.]]></description><link>cs3100/hw/hw5/hw5.html</link><guid isPermaLink="false">CS3100/HW/HW5/HW5.md</guid><pubDate>Wed, 02 Apr 2025 22:49:19 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250402133548]]></title><description><![CDATA[<img src="cs3100/complexity-theory/attachments/pasted-image-20250402133548.png" target="_self">]]></description><link>cs3100/complexity-theory/attachments/pasted-image-20250402133548.html</link><guid isPermaLink="false">CS3100/Complexity Theory/attachments/Pasted image 20250402133548.png</guid><pubDate>Wed, 02 Apr 2025 19:35:48 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402130349]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250402130349.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250402130349.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250402130349.png</guid><pubDate>Wed, 02 Apr 2025 19:03:49 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402125834]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250402125834.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250402125834.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250402125834.png</guid><pubDate>Wed, 02 Apr 2025 18:58:34 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402124532]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250402124532.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250402124532.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250402124532.png</guid><pubDate>Wed, 02 Apr 2025 18:45:32 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402124501]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250402124501.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250402124501.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250402124501.png</guid><pubDate>Wed, 02 Apr 2025 18:45:01 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402123857]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250402123857.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250402123857.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250402123857.png</guid><pubDate>Wed, 02 Apr 2025 18:38:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402123556]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250402123556.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250402123556.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250402123556.png</guid><pubDate>Wed, 02 Apr 2025 18:35:56 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250402123019]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250402123019.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250402123019.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250402123019.png</guid><pubDate>Wed, 02 Apr 2025 18:30:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250401125744]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250401125744.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250401125744.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250401125744.png</guid><pubDate>Tue, 01 Apr 2025 18:57:44 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[DB Storage]]></title><description><![CDATA[讨论了这么久如何使用SQL, 但SQL是如何储存数据的呢我们可以想象成, 表中的每行都是一个对象, 然后如果我们要搜索某个数据, 如学生的GPA, 我们会有一个树或者其他的数据结构, 来去检索对应的GPA, 检索到了以后, 那个树的节点会指向对应的学生对象.
我们称这个树的节点叫做Index - 这种Index不是Array的那种Index, 更像是书的那种目录这样, 就引出了消耗: 我们怎么知道一个查询的消耗是多大呢?
这很大程度取决于表格是如何排列的: 比如我们想检索ID, 但表格是按照名字排序的, 那么就是的复杂度, 但反过来, 就是或者更低这就是为什么我们想用Index: 因为原本的对象只有一种排序方式, 但Index就给了我们更多种可以排序的方式. 当我们设置Primary Key的时候, SQL就会把它当做这些对象的排序方式
但如果想用Index, 我们就需要明确写出:CREATE INDEX &lt;index name&gt; ON &lt;table&gt;(&lt;column list&gt;);
当然也不推荐把每列都给上Index, 因为每次添加数据, 都得更新Index, 并且Index也得占用额外的空间(虽然不多)
这就需要思考到底哪列真的需要Index:
我们一般需要知道到底什么查询最常见, 然后给对应的列添加Index除了上面这种Index的方法, 还有Multicolumn Index(这就是为什么上面写的Column list):CREATE INDEX &lt;index name&gt; ON &lt;table&gt;(&lt;column1, column2&gt;);
如CREATE INDEX CourseIndex ON &lt;table&gt;(Dept, Num);
得到的就会是一个新的数据结构, 他的索引的前半部分是部门的名字如CS, MATH等, 后半部分是课程名字如1030,3500等.
合并起来就是:这样, 一般这种是为了我们去查找这种数据:Dept = "CS" and Num = 1030
并且, 如果我们想单单查询部门名字也是可以加速的, 只需要看前半段就可以了
但如果我们想查询课名, 这个Index实际上是无法加速的, 当然我们很少这样查询.
而且这种MultiColumn的Index对于And查询会比两个Index要快: 因为两个Index要做两次Index查询, 然后去比较.
但对OR查询就不一样了: 因为OR要做两次查询, 但后半部分对于Multicolumn是无法加速的]]></description><link>cs5530/db-storage.html</link><guid isPermaLink="false">CS5530/DB Storage.md</guid><pubDate>Sat, 29 Mar 2025 01:27:55 GMT</pubDate></item><item><title><![CDATA[Intro]]></title><description><![CDATA[储存数据和检索数据有很多方法, 但数据量大的时候, 就会变得很麻烦: 如果要使用那种JSON / XML格式, 虽然人看起来比较方便, 但是检索起来, 就需要O(N)的速度, 并且, 如果我们要存储学生和课的关系, 虽然可以把他们放在一起, 如这个课拥有哪些学生, 但如果一个学生没有任何课, 那么就无法用这种方式表达.具体来说, 我们需要从下面四个方面来解决我们的检索问题:
数据规划 <a data-href="Structured data" href="cs5530/structured-data.html" class="internal-link" target="_self" rel="noopener nofollow">Structured data</a> - 数据的表示方式, 还有每个数据的类型等
关系结构 Relation Model - 可以用不同的关系, 来把最基本的数据组成出更复杂更有意义的表格
<br>数据结构 <a data-tooltip-position="top" aria-label="DB Storage" data-href="DB Storage" href="cs5530/db-storage.html" class="internal-link" target="_self" rel="noopener nofollow">Data Structure</a> - 良好的数据结构可以让我们以很快的速度进行查询, 比如提前做好一个二叉树, 用指针指向每个数据, 能加快检索.
<br>查询语法 <a data-href="Query Language" href="cs5530/query-language.html" class="internal-link" target="_self" rel="noopener nofollow">Query Language</a> - 通常, SQL软件会来规定这些查询的语法
实际上, 上面的前三个东西都是已经被Database Management System (DBMS)实现了, 而最后一个语法有很多种不同的, 这节课会使用MySQL来作为DBMS, 并使用SQL语法来进行查询. 请注意, 这两个东西是不同的:
MySQL可以说是SQL的实现(implement), 它实现了语法想要的功能, SQL本身只是个语法, 或者说是Interface, 它不是个数据库至于使用MyQSL这种数据库引擎有什么区别, 可以用个图表示:我们可以用不同的语言去调用SQL API, 然后去操纵数据库去读取或存储数据而设计一个数据库, 可以遵循下面几个步骤: Requirements Analysis - 谁用这个数据库, 需要用来干什么
Conceptual Design - 比较抽象的去思考大体的框架
Schema Refinement - 开始规划Schema
Physical Design - 规划如何把数据储存在硬盘上
Security Design - 规定每个用户的访问规则等
]]></description><link>cs5530/intro.html</link><guid isPermaLink="false">CS5530/Intro.md</guid><pubDate>Sat, 29 Mar 2025 00:54:09 GMT</pubDate></item><item><title><![CDATA[Transactions]]></title><description><![CDATA[在SQL中, 我们可以用Transaction来保证一系列操作不会做到一半报错:如我想让一个账户-100, 另一个账户+100, 要是第二步还没做完, 就断电或者出现错误, 我们肯定希望第一步也撤销.
这就可以用Transaction来做: 它类似创建了一个沙盒, 我们在里面做的任何事情都不会影响到原本的数据库, 但是如果commit后, 就会把我们刚才做的所有操作一并提交给服务器. 这样就保证一系列操作全部能做完.
但如果操作中途出现错误, SQL会执行ROLLBACK: 也就是撤销掉刚刚沙盒里的所有操作虽然Transaction一定程度上可以解决掉多用户交互的问题, 但还是会出现race condition: 如果两个用户同时借书, 但我们的程序想保留最后一本书在图书馆中, 可以这么做:检测库存里有多少书
检测借出了几本书 用两个结果相减得到库存 if(库存 &lt;= 1){ return 失败
}else{ // 耗时操作 - 可能两个用户同时到达这里 借书 commit changes
}
这个问题就违背了Isolation了: 两个操作不能互相影响, 就算他们是并发的.
实际上, 我们是可以修改Isolation原则的等级的: 让数据库宽松一点, 这样就算一个线程还没commit, 另一个线程也能读到它还没commit的东西(dirty read)对于一个默认的数据库, 下面这些就会违背Isolation原则:
Dirty Read: Transaction读取了没有被commit的数据
Non-repeatable Read: 两次选择获得了不同的数据 - 因为中途其他用户的Transaction commit导致数据变化
Phantom read: 选择一个同样的范围, 但返回了不同数量的行, 跟上面相似的原因
Phantom write: 修改一个似乎不存在的行(因为我们在修改的时候, 其他用户添加了一个新的行)
不过就算我们修改SQL让它允许这些操作, 但SQL它自身还是不会允许相同的PK存在 - 如果一个两个线程同时添加了一个1为PK在数据库中, 后添加的会卡住, 直到前面的commit或者Rollback再决定报错或者成功对于SQL, 有四个级别的Isolation Level, 越往上的越不Isolation, 并且会越快, 越往下会越慢, 并且会更保证IsolationREAD UNCOMMITTED - 允许Dirty Read &amp; Phantom Read: 就算没有commit, 其他的session也可以读到那些"沙盒"中的操作, 这样会导致两次读取可能得到不同的结果 READ COMMITTED - 只有commit后, 其他用户才可以读到commit的东西, 可能导致Non-repeatable Read REPEATABLE READ (MySQL default) - 不会存在Non-repeatable Read &amp; Phantom Read: 因为SQL会保存一个"快照"在这个线程没有commit之前, 所有的查询返回的都是相同的值 SERIALIZABLE - 系统会让所有可能会互相影响的操作都互相等待, 直到被等待的Commit或Rollback, 可以认为永远就只有一个用户
比如, 我们有一个代码是:if(count(x) == 0){ //Add a row
}
如果两个线程同时运行, 他们可能同时添加, 导致最终有两行在表中. 就跟上面借书的操作一样
但如果在SERIALIZABLE模式下:set session transaction isolation level SERIALIZABLE
当第一个线程插入一行之后
第二个查询的线程会完全卡住, 然后直到第一个线程插入成功后, 第二个线程会发现已经有一行在表中了, 就会放弃插入.看似很完美, 但如果两个线程都同时的查询了表格, 然后发现表都是0, 并尝试开始插入呢?
这就导致了Dead lock: 因为第一个线程想要插入一行的时候, SQL会阻塞这个线程, 因为它觉得第二个线程需要0行这个环境. 但第二个线程也开始插入, SQL也会以相同的原因阻塞它.
这种情况SQL就会直接报错, 说Dead Lock Occur. 不过这种报错只有其中一个线程出现, 然后这样就会让我们还是达成了目的但为什么不用编程语言的Lock? 这是因为在现实生活中, 一个数据库可能链接着很多服务器, 然后一个服务器Lock后并不能同步到另一个服务器中. 但如果是多个不同的Isolation Level存在呢? 对于每个Session, 他们看到的东西都是取决于他们是什么Isolation Level的.对于两个同时发送的Transactions, 他们中每条指令执行的顺序不一样, 就可能导致不同的结果 - 这里的结果是我们定义的, SQL他自己是不知道的
假设这里有个同时发送的Transactions, 那么就会有个Serial Schedules.
如果我们进一步把Transaction拆成一条一条指令来排序, 如果最终得到的结果和某个Serial Schedule的结果一样, 那么我们就说这个是个Serializable Schedule所以, 对于服务器来说, 有这么多种Schedule可以选择, 并且, 我们甚至在没有commit之前, 不知道用户还会输入什么指令, 服务器到底应该怎么知道选择哪个正确的Serial Schedule?这依靠的是2PL - Two Phase Locking
这个思想是把一个Transaction分成两个部分: Growing phase和Shrinking phase
它里面分成两种Locks: 当读取的时候, 会产生Shared lock 如果一个Transaction申请了一个Shared Lock, 其他Transactions仍然可以继续申请, 不会阻塞 当写入的时候, 会产生Exclusive lock 如果有一个Transaction对某个表的某行申请了这个Lock, 那么其他的Transaction就不可以再对这个数据做任何的操作, 就算读取也不行, 直到这个Transaction结束. 但如果其他Transaction正在读取这个数据, 那么当前的Transaction也会等待那个Transaction结束 在这里, 我们用的是Strict Two Phase Locking - 也就是如果要解锁一个Transaction, 就必须一下全部解锁, 这样会比较简单我们还可以在SQL中直接使用LocksLock TABLE t &lt;READ | WRITE&gt;;
Unlock TABLES;
如果用Read Lock, 那么所有的Sessions都无法写入这个数据, 甚至自己的Session也无法写入. 并且其他Session无法再次申请这个Read Lock
不过这样做会比Serial Transaction慢得多, 现实中很少用到除了上面这种Lock, 还有Select LockSELECT ... FOR UPDATE;
COMMIT/ROLLBACK - 锁自动解锁
这里我们可以选择某一行去Lock, 这样就不会让整个表都被锁住, 然后这样其他的Session也可以去修改表中的其他部分了.
这种锁更加温和一些, 也是Transaction中用的锁]]></description><link>cs5530/transactions.html</link><guid isPermaLink="false">CS5530/Transactions.md</guid><pubDate>Sat, 29 Mar 2025 00:49:38 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250326135921]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250326135921.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250326135921.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250326135921.png</guid><pubDate>Wed, 26 Mar 2025 19:59:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326135846]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250326135846.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250326135846.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250326135846.png</guid><pubDate>Wed, 26 Mar 2025 19:58:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326124840]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326124840.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326124840.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326124840.png</guid><pubDate>Wed, 26 Mar 2025 18:48:40 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326124818]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326124818.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326124818.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326124818.png</guid><pubDate>Wed, 26 Mar 2025 18:48:18 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326123013]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326123013.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326123013.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326123013.png</guid><pubDate>Wed, 26 Mar 2025 18:30:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326122417]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326122417.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326122417.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326122417.png</guid><pubDate>Wed, 26 Mar 2025 18:24:17 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326122154]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326122154.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326122154.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326122154.png</guid><pubDate>Wed, 26 Mar 2025 18:21:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326122135]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326122135.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326122135.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326122135.png</guid><pubDate>Wed, 26 Mar 2025 18:21:35 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326122057]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326122057.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326122057.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326122057.png</guid><pubDate>Wed, 26 Mar 2025 18:20:57 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250326122042]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250326122042.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250326122042.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250326122042.png</guid><pubDate>Wed, 26 Mar 2025 18:20:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250324174606]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250324174606.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250324174606.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250324174606.png</guid><pubDate>Mon, 24 Mar 2025 23:46:06 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250324160753]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250324160753.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250324160753.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250324160753.png</guid><pubDate>Mon, 24 Mar 2025 22:07:53 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[OS]]></title><description><![CDATA[在之前的部分, 讨论的都是一些汇编 / 硬件层面的理论, 现在应该讨论一些关于系统底层的知识了OS - Operating System 其实也是一个程序, 它会在电脑启动的时候运行, 关机的时候结束.
OS比其他程序牛逼的地方就是它有特权 - 能读取任意地方的内存 (包括写入文件到硬盘中), 任何程序有什么小心思OS都可以看得到. OS 内核就是OS中最重要的一部分的代码, 通常来说对于系统文件来说显得非常小. 但它就是有特权的那一部分. 并且只要开机, 内核就会开始运行, 并一直处在内存中.Shell就是用来理解用户输入指令的东西, 如lsShell也是一个程序, 可以用来管理其他程序:
启动 / 结束 / 暂挂程序
回到程序
连接多个程序的I/O
...
虽然Shell没有图形界面, 让小白上手很懵逼, 但它是和OS交互的一种非常基础 / 容易的操作.虽然程序的指令输入进去是一种顺序, 但其实这是一个假象:
因为电脑是多线程的 - 多个程序会同时发送不同的指令给OS. 但对于程序来说, 程序看到的只有自己在OS / 内存 / CPU中, 也就是说每个程序都是独立的.OS只有在下面这些情况下才会介入程序:
Ctrl + C (结束程序)
访问网络数据
除零
非法指令操作
其他程序也在运行
...
Normal Control flow表示的就是CPU正常执行, 也就是会发生之前那些汇编语言的东西 - 该咋咋而 Normal Control Flow会被以下的这些情况打断:
Interrupt
Trap
Fault
Abort
在打断的时候, OS就会暂时介入(执行OS Kernel的代码), 这对于C语言来说是这样的, 跟C++ / Java的那些Exception还不太一样
并且Exception Control Flow不仅仅是用来解决Error的, 如果没有这个东西, 任何的一个dead loop都可能永久的卡死电脑.注意, 下面所说的"异步"不是之前学的那种异步函数: 两个或多个函数同时运行, 这样前台就不会卡死. 这里的异步指的是: 这个事件的发生不依赖于程序的上下文, 如用户的ctrl-c.OS可以在程序执行指令流的时候, 让运行在某个地方停下来, 然后开始执行OS想执行的代码.
最典型的例子就是OS运行多个程序的时候, 每个程序运行一小段后就会被打断, 然后开始运算另一个程序 (进程切换)对于程序来说, 它是比较难知道到底什么时候发生Interrupt, 因为指令完全没有被改变, 从哪断掉的, 从哪继续执行. 唯一有影响的就是时间和Cache - 中间可能隔开了一小段时间或者缓存里的数据被覆盖掉了.这种时间通常来说是我们主动触发的 - 如调用syscall指令.
这时候, OS会开始调动OS Trap Handler代码, 比如读取文件, 访问网络等, 这种操作通常是非异步的. 某些事情可能会产生错误, 如访问一个非法地址的内存.
在我们访问的时候, OS会在那条指令开始接管(跟上面的差不多), 如果出现错误了, 就会重试, 如果还是有问题, 则会直接终止程序.
Fault有很多种不同的例子:
Segmentation Fault - 访问非法地址, 会结束程序(Abort) (如栈溢出)
Page Fault - 程序在尝试访问合法地址, 但实际上因为OS抠门少分配导致的访问非法地址, OS会再继续分配更多的内存, 然后重试指令. Unaligned memory access - 有些架构的CPU实际上支持未对齐的地址访问, 虽然非常慢.
这个简单粗暴, 直接终止现在的指令, 也就是说这个程序就直接断掉了.
通常, 它是由程序内部的错误或严重异常引起的, 比如非法指令, 致命错误或者程序遇到的某些特定条件 (例如, 无法继续执行) 时触发每一种Exceptions都会有对应的Handler, 这些Handler会在OS中处理, 而不同的OS会有不同的Exception处理方法每次开机, OS都会产生一个Interrupt Vector table, 类似一个Switch的Jump table, 每一个Exception编号都会对应一个不同的处理方法. 这个Interrupt Vector Table可以说是一个Global Variable, 因为整个CPU都共享一个.syscall指令是在x86-64中当我们需要OS帮我们干什么的时候调用的指令
在调用的时候, 程序会把syscall的参数放寄存器中, 然后把syscall的ID放入%eax中, 然后就可以执行syscall了, 可以把这个理解成一个协议当然, 在写代码的时候, 我们不会直接写syscall (当然我们想, 语言通常也不支持), 我们可以用一些OS提供的一些wrapper funcs如
write
close
read
...
现代的电脑通常都可以同时运行多个程序了, 就算我们只有一个CPU核心, 他也可以运行多个程序, 这个是OS的功劳. 在Linux中可以输入pstree来看到这个系统运行的所有进程至于怎么做到的, 需要用到上面的<a data-href="OS#Interrupt (异步)" href="cs4400/os.html#Interrupt_(异步)_0" class="internal-link" target="_self" rel="noopener nofollow">OS &gt; Interrupt (异步)</a>, 它会使用一个Timer Interrupt, 每过一段很短很短的时间, 他就会Interrupt现在执行的程序, 然后转到下一个程序再执行一小段时间. 就像杀老师同时教多个学生一样 这种操作叫做Context Switch这也就意味着, 只要电脑上开着多个程序, 在某个时间, 只有一个程序在运行, 然后剩下的多个程序在等待. 但这么换来换去, 每个程序的寄存器里的数据都不一样, 所以我们为了不让程序出错, 就需要保存这些数据.不单单是Timer Interrupt会触发context Switch, I/O(如打字), 或者调用sleep都会触发Context Switch. 而Context Switch的间隔可以被称作Time Slice, 因为它非常短, 人类是无法察觉的. 对于一个进程- Process, 它需要有 Program, Registers, Memory这三个东西, 如果一个程序单纯的在硬盘中, 他不算是个进程.如果CPU是多核的, 那么就可以同时运行多个程序, 然后进行Context Switch但需要注意的是Concurrent Parallel, 前者就是通过Time slice执行多个进程, 而后者是实打实的在同时执行多个线程像之前说的, OS就是用来管理进程的, 所以我们可以要求OS来创建一个子进程(如在bash中使用emacs)通常来说, 每个进程都会有一个父进程. 而每个进程(不管是子还是父), 都会有一个唯一的进程id - pID
在大多数OS中, 都只支持32768个进程数. 在Linux中, 可以用ps来查看所有的进程, 当然ps它自己也是个进程
用pstree就可以查看所有进程和他们的子进程, 并用树的形式表示出来我们可以用kill pid来结束某个程序
ctrl z来暂挂程序, 然后用fg来回到这个程序在C语言中, 用fork();这行代码来创建一个完全一致的子进程. 如果fork()创建子进程失败, 则会返回-1 (通常来说不会).
如:int main(){ fork(); printf("hello");
}
上面这行代码, 会输出两个hello, 就是因为有两个一样的程序都会输出(虽然两个程序的pid不一样)int main(){ int pid = fork(); if(pid != 0){ printf("Hello From Parent"); }else{ printf("Hello From Child"); }
}
这个fork还会返回一个值, 能让我们分辨是不是父进程: 只有父进程fork返回的值才不是0. 或者, 如果得到的pid是-1的话, 我们就会知道现在在的进程一定是父进程, 因为创建子进程失败了.int main(){ fork(); fork();
}
如果这样的话, 就会创建4个进程 - 父进程有两个子进程, 其中一个子进程会拥有一个它自己的子进程.就像之前说的, fork创建了一个子进程, 如果创建失败, 则会返回-1(正常来说, 返回的值是0), 虽然不常见, 但检查syscall的返回值永远是个好习惯.或者, 还可以用execve来把当前程序换成其他进程, 如我们可以在程序中调用ls指令:#include &lt;stdlib.h&gt; int main() { char* args[] = {"/usr/bin/ls", NULL}; //这个是通过Null pointer来知道什么时候是结尾, 类似String需要一个数据是0的byte来结束 char* environ[] = {NULL}; //环境变量 execve( args[0], args, environ); printf("this will not print");
}
就像最后一行: 因为已经进程变成ls程序了, 所以最后一行也就没办法执行. 在Shell程序中, 比如我们想执行ls -l, 它就会转化成下面的代码:char* args[] = {"/usr/bin/ls", "-l", NULL}; char* environ[] = {NULL}; execve( args[0], args, environ); 每个进程除了pid以外, 还有个pgid, 默认来说, 所有程序的子进程都会拥有相同的pgid (Process Group ID)
有了pgid, 这样才可以只用一次ctrl c就可以把所有程序和他的子线程杀死.如我们在OS上运行的所有程序都是有同样的pgid - 因为都是Shell启动的程序(Shell的子进程) - 这是对于前台进程来说, 对于后台进程, Shell会去给他分配一个新的gpid. 如果我们自己写shell程序, 需要自己处理pgid:
用setpgid可以设置一个程序的pgid:#include &lt;unistd.h&gt; int setpgid(pid_t pid, pid_t pgid);
• 如果pid参数是0, 表示我们要设置的是当前这个进程
• 如果gpid的参数是0, 表示我们要用当前进程的pid当做pgid (虽然很多时候用不到, 这只是一个惯例)int pid = fork(); if(pid) // parent setpgid(pid, pid); // Or int pid = fork(); if(pid == 0) // child setpgid(0, 0);
有了进程组之后, 我们可以用kill来结束同一个进程组的所有进程:#include &lt;signal.h&gt; int kill(pid_t pid, int signum);
这里的pid如果是负数, 则会结束这个进程组的所有进程.
但如果是-1, 则是给当前用户的所有进程发送信号在代码中, 如果子进程要发送信号给父进程, 可以使用getppid()来获得父进程的pid, 也可以用getpid()来获得自己的进程id上面已经说了如何用fork + execve来创建新程序user_types a command
int pid = fork();
if(pid == -1) //child process faild.
if(pid == 0){ //child if(execve(command,...) == -1){ exit(); }
}else{
...
}
并且, Shell还需要负责reap进程(因为是Shell创建的子进程, 并且只有父进程可以reap子进程): 也就是如果程序调用exit(), 但没有被reap, 则它的资源还没有被释放. 如果没有被释放, 我们会称他为"僵尸进程". 但如果父进程消失了, systemed会"收养"这个子进程(绑定父进程到进程1上), 然后替你释放. 但如果父进程一直存在, 系统也无力回天了. 所以, 我们需要用一个办法来知道我们创建的子进程什么时候退出了, 然后再给他撅reap了:#include &lt;sys/types.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;unistd.h&gt;
pid_t waitpid(pid_t pid, int *status, int options);
pid：
&gt; 0：等待特定的子进程 (进程 ID 为 pid).
-1：等待任意子进程 (等价于 wait()).
0：等待和调用进程同组的任意子进.。
&lt; -1：等待某个特定进程组的子进程 (组 ID 为 |pid|).
status：
用于存储子进程的退出状态信息 (可使用 WIFEXITED、WIFSIGNALED 等宏解析).
options (可选，可用 | 组合多个) : WNOHANG：如果没有子进程退出, 则立即返回 0, 不会阻塞.
WUNTRACED：阻塞, 直到一个进程终止或停止, 返回 PID
WCONTINUED：阻塞, 直到一个停止的进程收到 SIGCONT 信号重新开始执行
当Options写0的时候, 表示没有任何额外选项, 等价于wait
或者, 我们可以用wait()函数, 他就是一个waitpid(), 不过它的pid参数是-1, options参数是0.实现的效果就是执行这个代码的程序会等待所有它的子进程exit.返回值
成功： 子进程 ID（&gt;0）：表明该子进程已经结束。
0（仅当 WNOHANG 选项启用时）：表示没有已退出的子进程。 失败： -1 并设置 errno（如 ECHILD 表示没有子进程，EINVAL 表示参数错误）. 这个Wait不仅仅告诉了一个程序的结束, 他还帮我们做了reap子进程的这个操作一个非常简化的Shell例子, 就是:while(1){ is_bg = read_and_parse_command(); pid = fork(); if (pid == 0){ // child execve(command[0], command, env); } if (!is_bg){ fg_pid = pid; //很大的问题 } if (fg_pid != 0){ // wait for fg process to finish } }
上面的代码有个很大的问题: 如果子进程在pid赋值到fg_pid之前就结束了, 这种会导致race Condition - 后续父进程中的wait会指向一个可能被回收的进程.为了解决这个问题, 我们可以阻塞信号://伪代码!!!
block SIGCHLD if(fork() == 0) // child ... else globalvar = ...; unblock SIGCHLD
在进程层面中, 可以用Signals来让程序之间互相交流(回想Qt中的Signals和Slot.)<br>我们可以让进程a发送一个Signal, 然后让进程b接收这个Signal, 然后执行Signal Handler的代码 - 非常像<a data-tooltip-position="top" aria-label="OS > Normal / Exception Control Flow" data-href="OS#Normal / Exception Control Flow" href="cs4400/os.html#Normal_/_Exception_Control_Flow_0" class="internal-link" target="_self" rel="noopener nofollow">Interrupt</a>, 只不过Interrupt是OS层面上的.Signal不像网络数据包那样有信息, 我们唯一知道的就是某些事情发生了, 甚至不知道是谁发送的.
并且有时候OS也会发送Signals. 当我们在使用Signal handler处理信号的时候, 当一个信号到达时, 操作系统会中断当前进程的执行, 并转移控制权到信号处理程序. 一旦信号处理程序完成, 操作系统会恢复之前暂停的程序执行, 从信号到达时被暂停的地方继续执行有时候, 如果我们不想让Signal介入, 如干一些重要的事情的时候, 我们甚至可以Block掉Signal. 因为Signal的出现让Race Condition非常容易发生 - 正如之前所说信号是异步的, 就算程序的控制权移交, 如果第二个信号到来, 可能会导致第二个signal 打断第一个signal, 然后互相影响.上面的这些都是一些我们没有编写, 不过程序都默认会识别的Signalssignal(int sig, void (*func)(int));
通过上面的这种方法, 我们可以自定义当接受某些指令的时候执行什么, 如我们可以写一个程序它无法被Kill掉 (强制结束仍然有效)#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt; void handle_sigint(int sig) { printf("Received SIGINT (%d), but ignoring it!\n", sig); // ↑垃圾代码
}
int main() { signal(SIGINT, handle_sigint); // 设置自定义信号处理 while (1) {} return 0;
}
因为Signal是一个async-signal-safe的函数, 我们需要尽量避免在Signal Handler里调用它 - 极易导致race Condition.同样的, 我们还可以发送信号, 如kill, 这个函数可以让我们给OS一个指令, 让他把指定的PID结束int kill(int pid, int sig);
在阻塞信号时, 信号会被加到pending中. 信号会一直等待, 直到阻塞结束, 然后再被signal handler处理. 在C中, 我们需要用sigporcmask函数sigprocmask(int how, const sigset_t* set, sigset_t* oldset);
sigset_t sigs; //因为我们可能要屏蔽多种信号, 所以是个set
sigemptyset(&amp;sigs); sigaddset(&amp;sigs, SIGCHLD); sigprocmask(SIG_BLOCK, &amp;sigs, NULL); //信号开始被阻塞
if(fork() == 0) // child ... else globalvar = ...; sigprocmask(SIG_UNBLOCK, &amp;sigs, NULL); //至此,可以执行Signal Handler了
上面就是个使用信号阻塞的例子: 因为前景进程和shell会互相抢资源, 要是进程抢的资源比较多, 直接做完了它的工作, 它就会发个SIGCHLD信号表示这个进程退出了, 但这时候, shell可能还没有往自己的数据中记录这个程序已经开始执行了, 就导致我们可能会去试图释放一个不存在的进程如果多个相同的信号同时到达, 可能Handler只会处理一个为什么要关心这个事情? 这是因为写Shell程序的时候要写Signal Handler, 比如处理僵尸进程. 但由于可能有多个子进程同时结束, 就会导致可能重复的sigchld被忽略. 所以我们就需要避免这种事情的发生 - 例子:#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;signal.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt; void handle_sigchld(int sig) { printf("Child process terminated!\n"); while (waitpid(-1, NULL, WNOHANG) &gt; 0); // 防止僵尸进程
} int main() { signal(SIGCHLD, handle_sigchld); if (fork() == 0) { exit(0); } // 子进程 1 退出 if (fork() == 0) { exit(0); } // 子进程 2 退出 if (fork() == 0) { exit(0); } // 子进程 3 退出 while (1) pause(); // 等待信号
}
可能得到的结果是下面这种 - 只收到了一次Child process terminated!
因为对于这种信号, 像之前说的, 可以把他们当做是布尔值: 我们只知道有没有发生过, 不知道发生了几次并且如果一个信号在Handler处理信号的时候到达, 它会加入pending队列, 但如果等待队列里还有一个相同的信号, 则新到的信号会被忽略:void handle_sigint(int sig) { printf("Handling SIGINT...\n"); sleep(3); // 模拟长时间处理 printf("Done handling SIGINT\n");
} int main() { signal(SIGINT, handle_sigint); while (1) pause(); // 等待信号
}
如果连续按三次ctrl-c, 可能会得到下面的结果:Handling SIGINT...
Done handling SIGINT
因为handler也是个函数, 当他正在运行的时候, 新来的信号也可能会把handler打断. 而这种打断也分情况: 就是上面的例子: 多个相同的信号出现 - 则最后的信号处理会可能会覆盖掉前面的信号处理. 还有就是多个不同的信号出现 - 则最后出现的信号所调用的信号处理会打断前一个信号处理, 直到处理完毕后再返回处理上一个被打断的信号处理函数
现在就出现了问题: 比如进程同时退出, 这种可能会同时触发的信号会导致可能只有一个进程被清理. 你可能会想到直接屏蔽掉信号, 先安心地清理这个程序不就行了? 实际上确实可以, 我们可以用mask和pause()函数: 在调用完这个函数, 当前的程序会被挂起, 直到收到信号但这种操作又会导致新的问题:sigprocmask(SIG_BLOCK, &amp;mask, NULL); // 1. 先阻塞信号
// Race Condition: 这里如果信号到了，但还没调用 pause()，信号就丢了！
pause(); // 2. 进入睡眠，但此时可能已经错过信号
为了避免信号丢失, 我们可以在使用sigprocmask()的基础上用这个函数:sigsuspend(sigset_t* mask);
通常用于 同步信号处理, 确保进程在等待信号时不会因竞争条件 (Race Condition) 导致信号丢失.这个函数会做的事情是:
替换进程的信号屏蔽字，将其设置为 mask 指定的值(通常是屏蔽所有信号，除了想要等待的信号)
挂起进程（休眠），直到接收到一个未被屏蔽的信号。
处理这个信号（如果注册了信号处理函数 sigaction 或 signal）。
恢复旧的信号屏蔽字（恢复 sigsuspend() 之前的屏蔽字）。
继续执行进程后续代码。
sigset_t mask, oldmask;
sigemptyset(&amp;mask);
sigaddset(&amp;mask, SIGUSR1); // 1. 先阻塞 SIGUSR1，防止 Race Condition
sigprocmask(SIG_BLOCK, &amp;mask, &amp;oldmask); // 2. 在这里执行一些操作（信号可能已到达，但不会丢失）
// 3. 使用 `sigsuspend()` **原子地** 替换屏蔽字并进入等待
sigsuspend(&amp;oldmask); // 这里等待 SIGUSR1 到达
// 4. `sigsuspend` 返回后，信号屏蔽字已经自动恢复 printf("SIGUSR1 received!\n");
对于Linux中, 所有的东西都是文件: 就算是鼠标的移动, 键盘的敲击的记录都会存在File中, 我们需要去读取才可以知道鼠标怎么移动了如果要打开一个文件, 需要open函数, 它会返回一个给系统用来分辨的id (File describtor).#include &lt;fcntl.h&gt;
int open(const char* path, int flags);
int close(int fd);
而读取完以后需要close, 如果close失败, 则会返回-1打开文件后, 我们也可以读取和写入文件:#include &lt;unistd.h&gt;
size_t read(int fd, void* buf, size_t n); //读取 &lt;=n bytes从fd到buf
size_t write(int fd, const void* buf, size_t n);//写入 &lt;=n bytes从buf到fd
// 当write写完后, 会在结尾放一个eof, 但如果有多个write链接着这个文件, 则只有最后一个write关闭后才会放eof
这两个函数都会返回读取 / 写入了多少byte, 如果发生错误则返回-1
对于read, 有线程正在以write模式开启了这个文件, 并且文件中没有end of file符号, 则它会阻塞线程, 直到数据被放入buffer中 (这是因为refcount的功劳, 它知道有没有writer指向这个文件)
如果refcount=0, 并且文件中没有任何数据, 或读到EOF符号, 则read会返回0, 表示end of file.
read每读一个byte, 都会把他从buffer删掉.约定俗成, 对于一个程序, 它只要创建了, 就会有三个fd已经帮你打开了:
stdin
stdout
stderr
在原本的Shell中, 程序会通过stdin来接收键盘的输入, 然后再通过stdout来输出到终端. 当然, 我们也可以通过stdout来输出到其他的程序, 这种是通过dup2函数做到: 作用是让 dest_FD 指向 source_FD 指向的文件int dup2(int source_FD, int dest_FD);
//这里的效果是后者的fd变成了前者fd指向的文件
在系统中, 每个进程都会有自己的FD table, 这个表格记录了每个进程的每个fd指向了Open file table中的哪个文件引用
然后, 在OS中还会有Open file table, 它记录了一个refcount, 这个表示的是有几个fd正在指向它, 当refcount = 0的时候, OS就会自己帮你关闭它. 它还记录了这个文件是用来读还是写的(当然可以读和写)
对于stdin来说, 他的模式就是读, 我们尝试写入就会失败, 而stdout就是写入模式.比如, 当我们写open(..., O_WRONLY);时, 在FDtable对应的线程中, 会添加一行, 然后指向Open file table中新的一行, 它指向了我们准备写入的文件, 然后refcount = 1
如果上面的open函数返回的 fd是3, 而原本的stderr的fd是2, 如果我们写:dup2(3,2);
这时候, stderr在fd table中就不会再指向原本的Open file table行了, 而是指向之前我们打开的那个文件.
得到的结果就会是输出stderr就不会再输出到终端, 而是输出到我们正在写入的文件中通过pipe函数, 他会创建了 一个匿名的、内核管理的缓冲区 (pipe buffer), 可以用于进程间通信int pipe(int fds[2]);
通过fds[0]可以读取文件, 通过fds[1]可以写入文件. 这样, 我们可以在这个线程中左手倒右手: 自己读自己写.
当然, 更有用的是用fork创建两个线程, 然后通过pipe创建的共享文件来进行交流: 这是因为fork创建的进程副本几乎所有的东西都是相同的, 所以父进程和子进程的两个新fd (fds[0]和fds[1])会分别指向两个相同的Open File Table, 然后指向同一个系统中的buffer需要注意的一点是, 如果fork后, 我们需要让接收数据的线程关闭写入的fd, 而发送的线程最好也关闭读取的fd. 这是因为可能发送数据的线程已经写完了, 但接收数据的线程的写入没写任何数据, 但还连接着那个文件, read会一直阻塞线程, 以为还有数据要写入 - 因为虽然写入线程把写入关了以后会放入EOF并被write读到, 但由于系统发现还有write连接到文件, 就仍然会继续等待在现实中, 也很容易出现两个程序同时访问一个文件, 实际上, 这需要用锁来解决. 在这里不进行讨论至此, 我们就可以自己实现Shell中的pipe功能了: 我们可以把一个程序的stdout接入到另一个程序的stdin中.]]></description><link>cs4400/os.html</link><guid isPermaLink="false">CS4400/OS.md</guid><pubDate>Mon, 24 Mar 2025 19:48:46 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250319144523]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250319144523.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250319144523.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250319144523.png</guid><pubDate>Wed, 19 Mar 2025 20:45:23 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250319143916]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250319143916.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250319143916.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250319143916.png</guid><pubDate>Wed, 19 Mar 2025 20:39:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250319135158]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250319135158.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250319135158.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250319135158.png</guid><pubDate>Wed, 19 Mar 2025 19:51:58 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250317144241]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250317144241.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250317144241.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250317144241.png</guid><pubDate>Mon, 17 Mar 2025 20:42:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250317143252]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250317143252.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250317143252.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250317143252.png</guid><pubDate>Mon, 17 Mar 2025 20:32:52 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250317142846]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250317142846.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250317142846.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250317142846.png</guid><pubDate>Mon, 17 Mar 2025 20:28:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250317141816]]></title><description><![CDATA[<img src="cs3100/computability/attachments/pasted-image-20250317141816.png" target="_self">]]></description><link>cs3100/computability/attachments/pasted-image-20250317141816.html</link><guid isPermaLink="false">CS3100/Computability/attachments/Pasted image 20250317141816.png</guid><pubDate>Mon, 17 Mar 2025 20:18:16 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[HW4]]></title><description><![CDATA[q1q20-&gt;x,Rq3#-&gt;R0-&gt;Rq41-&gt;x,Lx-&gt;Rx-&gt;Lq5#-&gt;L0-&gt;Lx-&gt;R#-&gt;Rq6x-&gt;Raccept˽-&gt;Ra:
Turing machine is a special form of PDA, which has a pointer that can point to arbitrary position of the stack - it can move back and forward.In this question, we can use the two stack to simulate an "array": If we want to access a specific element of a stack, and we have two stacks:Example - access index 3 and change to 9
Stack 1:
1 2 3 4 5
Stack 2:
(empty)
↓ move all element to stack 2 untile we find 3:
Stack 1:
1 2 3
Stack 2:
5 4
↓ change 3 to 9, and put element back
Stack 1:
1 2 9 4 5
Stack 2:
(empty)
As example above, we can access a specific element of a stack, so we changed this stack to a array, which equals to the turing maching: a PDA with a tape.b:
If we have a 3-PDA, that means we have a 2 tape turing machine: by using one stack, we can use those 2 stack as an array(tape)
For now, this question changes to "is a 2 tape(multi-tape) turing machine more powerful than a normal turing machine?"
For this question, answer is no: because we can use a normal turing machine to simulate a multi-tape turing machine: split the tape in to severial parts, and each part means one tape of multi-tape turing machine, and if a tape need more space, just move every elements behind that tape backward.For doubly infinite tape machine, we can use a multi tape turing machine to simulate it: we take first tape as the right part of the doubly infinite tape machine, and the second tape as the left part of the machine. If the pointer go to the left of the doubly infinite tape machine, we will move the pointer on the first tape to left, untile we met the left mose element (like $), If we still need to move leftward, we can start to move the second tape pointer to right, vice versa.For a decidable language, it means that a string and a decidable language which , if , the machine will accept it and halt. if , the machine will refuse by halting.
a:
If we want to proof the decidable language is closed under intersection, we need to find a new machine that only accept the string if both and accpet it.
M= “On input :
1. Run on . If it halts and rejects, reject. If it accepts, continue on Step 2.
2. Run on . If it halts and rejects, reject. If it accepts, accept.”
Since both machines are decider, so they will always halt if the string is not in the language. So, the new machine we got will also always halt to refuse.
b:
For star, we need to build a machine that accept any string that , which is accepted by .
M= “On input :
1. If string is empty, accept
2. Run on string , go to start if trys to accept the string. If already loop over the string, and we are in orignal accept state, we accept
Since the will always halt, the new machine will also always halt to accept or refuse.
c:
Complementation's new machine is easier to build: we just change the original machine 's accpet to refuse, and every refuse condition to accept, so we will get a new machine that will only accept the string that not in the machine .
Since original machine is decider, which means it will always halt, so the new machine will also always halt, since the result (accept or reject) is just the reverse of a:
If we need to proof Turing-recognizable language is close under intersection, we need to construct a machine that will accept a string only if and will accept it. For this, we can repeat the process of Q6-a: do first then . Since both machine are recognizer, which means that we know machine will halt when the string is in the language and we don't know what if the string is not in the language, the new machine must be a recognizer - the string must in both language, so both machine will halt.b:
For proving Turing-recognizable language is close under star, we can do same thing as question Q6-b:
M= “On input :
1. If string is empty, accept
2. Run on string , go to start if trys to accept the string. If already loop over the string, and we are in orignal accept state, we accept
Similar to part a, because is a recognizer machine, so we only know it will halt for accept.
Because we just use repeat few times to build , so since is a recognizer, we will know will also be a recognizer, since every string that will halt, will also halt for accept.M= “On input :
1. For every char in string, we add what we read from tape to stack, and non-deterministically move to step 2
2. For every char in string that we read on tape, we remove from stack. If stack empty, go to step 3
3. For every char in string, we add what we read from tape to stack, and non-deterministically move to step 4
4. For every char in string that we read on tape, we remove from stack. If stack empty, and if the tape is also empty, we accept.]]></description><link>cs3100/hw/hw4/hw4.html</link><guid isPermaLink="false">CS3100/HW/HW4/HW4.md</guid><pubDate>Mon, 17 Mar 2025 03:51:30 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250315194422]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250315194422.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250315194422.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250315194422.png</guid><pubDate>Sun, 16 Mar 2025 01:44:22 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[C Sharp With SQL]]></title><description><![CDATA[这节课中, 会使用C# 来编写服务器的后端.第一步, 就是提供Batabase的信息:connectionString = "server=atr.eng.utah.edu;database=SomeDatabase;uid=joesmith;password=123"
我们会发现, 这个密码是直接硬编码进代码中的. 这不是我们想要的, 所以我们也可以用某种方法在运行时让用户输入密码然后连接字符串接下来, 我们需要创建一个MySqlConnection对象:using( MySqlConnection conn = new MySqlConnection(connectionString)
){ conn.Open(); //执行指令等...
}
然后我们需要告诉SQL想要执行什么指令MySqlCommand command = conn.CreateCommand();
command.CommandText = "select Author from Titles join ...";
现在我们有了连接对象, 还有了要执行的指令, 就可以开始执行了:using (MySqlDataReader reader = command.ExecuteReader()){ // reader就是一个能读取sql返回的信息的对象 while(reader.Read()){ //调用reader.Read()会去到下一行 data = reader["column name"]; data = reader[1]; //0是第一列 //用[]可以访问某列的数据,如果知道顺序可以直接用序号 }
}
Non-Query表示的是不会返回结果的操作: 如添加行, 或者添加表格.
这种操作在C#中会表现的不太一样try{ int numRows = command.ExecuteNonQuery();
}catch(Exception){ // output something ...
}
更准确说, ExecuteNonQuery() 会返回一个int, 表示有几行被影响了
但为什么我们想这么做?
这是因为如果我们想插入一些可能已经存在的数据, 虽然可以先查询数据在不在, 如果不在就插入. 但这种操作非常耗时: 数据库可能一毫秒就完成了, 但指令通过网络传播可能需要100毫秒. 这就导致了我们的操作慢了2倍所以, 与其用两次指令, 不如用上面的方法, 在报错的时候输出或者忽略.
更简单的一种方法是在插入语句中加入ignore, 这样就可以避免产生Exception - 因为catch报错是一个高消耗的操作而且, 在很多时候, 我们实际上完全不关心到底有多少数据被影响了, 直接一直插入数据就好. 但上面这种操作必须需要等待SQL返回int才会继续执行. 这就会导致网络延迟仍然占据大部分等待时间.
对于这种问题, 有两个方法:
创建一个新线程来执行SQL插入. 使用async MySql library来进行异步操作
不过需要注意的是, 每一个sql connection只能同时执行一条指令, 如果我们创建很多很多线程同时发送指令, 可能导致问题. 上面的两种操作并不是为了并行插入的, 而是为了让发送指令后程序不会卡死的.
如果想一次执行多个插入指令的话, 可以用一种叫batch command操作: 不仅C#可以用, SQL终端也是支持的: select * from Titles; select * from Inventorys;
我们只要在分号后面继续写指令就可以了因为我们是程序员, 所以经常想把一些算法用C# (后端)解决, 实际上很多时候SQL处理大型数据的速度远比我们写的代码要快得多. 就像上面的插入指令一样.然而, 很多时候的操作并不是那么轻易就能直接在SQL上执行的:
比如我们有一个分数表格, 然后还有一个TXT文件记录了我们要修改的分数. 并且如果旧分数比新分数高, 我们想保留旧分数. 我们首先想到的操作是:using( MySqlConnection conn = new MySqlConnection(connectionString)
){ conn.Open(); foreach(int id in newScores.Keys){ command.CommandText = "Select ... from ... where sID = " + id; //遍历所有分数, 每个id去查询在不在数据库中 using (MySqlDataReader reader = command.ExecuteReader()){ reader.Read(); int oldScore = reader.GetInt32(0); reader.Close(); //必须close如果想执行另一条指令 if(oldScore &gt; newScore) continue; //sudo code //Update the score... } }
}
实际上, 我们完全可以把这个if指令写在Sql语句中:command.CommandText = "update scores set score = " + newScore + "where sID = " + id + " AND " + newScore + " &gt; score;";
在之前说过, 在C#中我们会动态构建查询命令, 并且SQL还支持一条数据中包含多条指令(Batch command).
这样, 就有条件使用SQL注入攻击了: 某些坏B可能会在数据中自己补全插入信息, 然后跟着一个;, 然后再跟着一些奇怪的命令: 如delete from xxx. 如果真执行了, 那就完犊子了
所以, 我们需要写避免SQL注入的代码.为了防止注入, 我们可以用一些方法解决掉那些可疑的字符:我们可以先整理一遍用户的输入:因为SQL也是支持转义的, 所以我们可以在所有的引号前都加上一个\, 这样我们就可以允许用户把"当做字符输入进去, 还不会引起问题不过需要注意的是, 不仅仅是引号会出问题, \也同样会出问题, 还有%等. 所以说这个很麻烦, 可以用第三方库来解决SQL注入那么严重的问题, 官方肯定也会有解决办法, 所以MySQL会支持一种可以直接避免注入的方法对于SQL4.1以后的版本, 他就支持SQL parameters: 也就是我们可以在SQL中定义参数, 也就是先定义语句, 然后把参数填进去. 就算我们把一个指令填进去, SQL会仍然把这条语句当做参数来进行查询.
换句话说, 只要这玩意定义了, 就永远只能执行这种功能, 没办法被注入可疑代码.想做到这点, 我们可以用@.CommandText = "Select ... Where Col1 = @Val1 AND Col2 = @Value2";
通过@, 可以让SQL知道后面跟着的是一个可变的变量.
然后再通过Parameters.AddWithValue(string parmName, data parmData)来给变量赋值command.Parameters.AddWithValue("Val1", myVariable);
然后我们直接该怎么执行怎么执行就可以了这种操作不仅仅可以防止SQL注入, 还可以提升效率: 我们如果想执行多个相似的指令的时候, 可以直接修改参数command.Parameters["@Val1"].Value = 1;
command.Execute...
不过想做到这点, 就需要在执行完AddWithValue(string parmName, data parmData)之后跟上一个command.Prepare();来达成类似编译的效果IDisposable 是一个接口, 要实现这个接口, 只需要一个方法: Dispose(). 这个方法是在这个Object需要cleaned up, restored, unwound的时候调用的.IDisposable o = ...; try{ //code that might fail
}
finally{ o.Dispose(); //Always execute
}
// Or do things below
using(IDisposable obj = new ...){ //code might fail
}
因为我们在执行一些操作的时候, 可能会失败. 但失败还是不失败, 执行完毕都需要释放这个object, 所以就用实现了IDisposable的接口的对象using(MySqlConnection conn = ...){...}
在写C#代码的时候, 我们经常会想: 要是能用C# object来表示数据, 然后直接访问该多好 - LINQ让我们可以做到这点要使用LINQ, 我们需要先把SQL的表格转换成C#的对象, 这点我们可以用Scaffold来做到: 这个算是一个库, 可以读取SQL数据库然后生成一堆C#的类, 并且这些类还能记录One to many等relationship.生成完类之后, 我们可以用LINQ(Language Integrated Query) 来访问SQL中的数据: 因为已经有了C#的类, 所以我们可以"认为"所有的数据都是在本地以C#类型存储, 然后直接拿Object.data等方式直接获取就可以了
实际上是, LINQ会把我们对C#数据的查询代码自动转换为SQL语言, 发送给SQL服务器, 然后把数据返回给我们, 这样得到的结果就是看起来就像直接访问本地对象一样.
当然, LINQ里也有Join等
如我们有两个class - Players和Games, 想找出所有当过黑方的玩家:IEnumerable&lt;Players&gt; query = from p in db.Players join g in db.Games on p.PId equals g.BlackPlayer select p;
这个Query是一个实现了IEnumerable接口的对象, 如List, 这样就可以让我们用foreach遍历:foreach(Players x in query){
...
}
当然, 我们也需要装模作样的用using连接我们"假设"的本地数据库(毕竟本地数据库内部要连接真正数据库, 可能会报错等):using(ChessContext db = new ChessContext()){ query = from ....
}
上面的ChessContext就是那个Scaffold生成的"本地数据库"并且由于LINQ是在C#中写的, 所以可以在查询语句中很轻易的整各种花活:var query = (from p in db.players where p.Name.Contains("xxx") //这里表示p.Name 包含 xxx where p.Elo % 5 == 3 //也可以用%符号 orderby p.Elo descending //用SQL排序 select p).Distinct();//这里是在本地用IEnumerable来去重
在LINQ中, 不仅仅有原本的数据, 当我们查看它生成的文件, 可以看到一些Navigation属性, 这个是一些快捷查询.如果想让语句返回多个对象(多列), 则需要创建tuple:var query = from p in db.Players join g in db.Games where p.Pid qeuals g.BlackPlayer select new Tuple&lt;uint, string&gt;(p.Elo, g.Result);
但由于遍历Tuple的时候, 需要写tuple.Item1()等, 非常麻烦, 所以就需要用到匿名类:var x = new //没有真正的类型名字 { elo = 5, name = "Dan",
};
这种type创建只能用var + new:var query = from p in db.Players join g in db.Games where p.Pid qeuals g.BlackPlayer select new { elo = p.Elo, result = g.Result, success = true, //也可以附加一些其他信息 }; foreach(var p in query){ Debug.WriteLine(p.elo); ... return Json(query.ToArray()); //这个能以Json array的格式返回查询
}
当然, 不仅仅是查询, LINQ也可以做增删改:
就像我们在给真正的数据结构添加数据一样, 直接创建一个对象, 然后添加到数据库对象中Players newPlayer = new Players();
newPlayer.Name = "Danny";
newPlayer.Elo = 1200;
db.Players.Add(newPlayer);
db.SaveChanges(); //真正上传到服务器, 通过transaction
对于删除, 我们可以先查询得到结果, 然后再通过RemoveRange()来移除查询到的数据var query = ...
db.Patrons.RemoveRange(query);
db.SaveChanges();
对于修改, 我们可以先做查询, 然后foreach来遍历每行进行修改:var query = ...
foreach(Parton p in query){ p.Name = ...
}
db.SaveChanges();
之前说的query 得到的都是一个一个的数据, 然后一起组成了个array, 那如果我想得到更紧凑的信息, 如一个array里存放了很多条数据事实上, 我们可以在创建物体的时候进行查询, 这样虽然还是得到的是一个array, 但我们可以直接把这个array放在对象里:var query = from t in db.Titles select new{ t.Title, Serials = from i in db.Inventory where i.Isbn == t.Isbn select i.Serial }
这样, 我们就可以得到一个array, 它的每个元素都代表了Title中的一本书, 和对应在Inventory中所有编号
实际上, 对于LINQ, 他有更简单的方法: 在创建整个结构的时候, LINQ会发现, 一个Title可能对应多个Inventory中的书 (One to Many), 所以, 在Title下, 有一个属性就是Inventory, 在我们查询的时候, 可以直接使用t.Inventory()来获取这本书对应Inventory中所有的数据.
当然在上面这种情况我们只需要Serial, 所以可以这么写:var query = from t in db.Titles select new{ t.Title, Serials from i in t.Inventory select i.Serial }
那么就来了一个新问题: 如果Inventory中没有任何书, 我们仍然会得到一个对应的对象 - 因为Title中存在, 但Serial中的数据就是一个empty array
这个问题也可以用t.Inventory中的函数解决:var query = from t in db.Titles where t.Inventory.Any() //添加过滤条件, 表示必须要有数据 select new{ t.Title, Serials from i in t.Inventory select i.Serial }
如, 我们想把库存(Inventory)表和书籍(Title)表合并, 并且如果书不在库存中, 我们想显示null:var query = from t in db.Titles join i in db.Inventory on t.Isbn equals i.Isbn into rightSide from j in rightSide //临时的表格 select new{t.Titles, j.Serials}
上面的写法可能有点奇怪, 而实际上我们可以把每个from当做一个foreach loop:foreach Title t foreach Inventory i matching t select new{t.Titles, j.Serials}
但是, 我们会发现还是有问题: 因为如果Inventory(库存)中没有匹配的书, 也就不会执行最里面的添加操作. 但我们是想返回NULL的, 所以就需要加上DefaultIfEmpty()var query = from t in db.Titles join i in db.Inventory on t.Isbn equals i.Isbn into rightSide from j in rightSide.DefaultIfEmpty() //就算j是空的, 也会继续执行 select new{t.Titles, j.Serials}
然而, 还是不可以直接使用: 因为当j是null的时候, 如果试图访问j的属性, 会导致null pointer exception. 而且由于LINQ中不支持if检测, 我们需要三元运算来解决这个问题:j == null ? null : (uint?)j.Serial //因为默认的uint类型不是nullable,所以需要类型转换
并且我们是可以进行多次Left Join的, 只要重复上面的步骤就行]]></description><link>cs5530/c-sharp-with-sql.html</link><guid isPermaLink="false">CS5530/C Sharp With SQL.md</guid><pubDate>Sat, 15 Mar 2025 05:48:17 GMT</pubDate></item><item><title><![CDATA[HW3Q6]]></title><description><![CDATA[q1ε,ε$loopε,εEε,EE+TIt can expandto two nodesε,TTxFε,F(E)ε,ETε,TF(,(ε),)εa,aε+,+εx,xεε,$εq2ε,Fa]]></description><link>cs3100/hw/hw3/hw3q6.html</link><guid isPermaLink="false">CS3100/HW/HW3/HW3Q6.md</guid><pubDate>Tue, 04 Mar 2025 00:22:37 GMT</pubDate></item><item><title><![CDATA[Context Free Languages]]></title><description><![CDATA[例子:
对于一个语法G:规则: 我们会写下第一个起始变量, 然后不停的根据规则把变量替换成字符串(字符串中可能还有变量) 直到所有变量都变成了终止符. 比较像CS2420的最后的作业 / Houdini的植物生成语法
如上面的语法就会生成下面的字符串:A -&gt; 0A1 -&gt; 00A11 -&gt; 00B11 -&gt; 0011
A -&gt; 0A1 -&gt; 00A11 -&gt; -&gt; 000A111 -&gt; 000B111 -&gt; 000111
A -&gt; B -&gt; ""
...
L(G) 表示的就是这个语法能生成的所有字符串<img alt="Pasted image 20250129140002.png" src="cs3100/automata/attachments/pasted-image-20250129140002.png" target="_self">
但可以看到, 上面的规则中, 并没有写一定需要一个终止的情况, 所以下面的语法虽然无法生成任何字符串(由于终止不了), 但仍然是一个合法的字符串B-&gt;0B
B-&gt;1B0
<br><img alt="Pasted image 20250129141246.png" src="cs3100/automata/attachments/pasted-image-20250129141246.png" target="_self">
如果要设计一个CFG, 它生成多种CFL, 然后union在一起, 我们可以先分别创建生成那些CFG的CFL, 如S1, S2, 然后让初始的变量是
如果想把DFA转换成CFG, 我们可以跟着节点的步伐走: 如果节点i到节点j需要a, 我们可以创建一个CFG规则是.
如:如果一个CFG能用多种Parse Tree来生成同一个字符串, 则我们会说这个语法是有模糊性的.有一种方法去验证模糊性是去替换变量的时候, 从左到右替换变量 - 这种方法叫Left most derivation, 如果这个CFG没有Ambiguity, 则得到的Parse Tree永远是相同的如果这个语法有多个leftmost derivations, 则这几个leftmost derivations 产生的字符串是derived ambiguously.如果一个CFG的所有规则都是下面这种格式, 那么这个CFG就是一个CNF:在上面的4个例子中, 只有G4是一个Chomsky Normal Form
G2不是是因为Start只能变成一个Variable, 而规则是变成两个
首先让S0作为起始, 然后添加一个规则是S0变成原来的Start Variable S, 这样可以保证规则右侧不会出现Start Variable
消除所有能变成空字符串的规则(根据最后一个规则, 只有起始Variable可以变成空字符串)<br>
<img alt="Pasted image 20250203134742.png" src="cs3100/automata/attachments/pasted-image-20250203134742.png" target="_self">
消除所有的对于A-&gt;B的Unit rule, 如果B-&gt;u, 则可以写成A-&gt;u
把剩下的不符合规则的rule都变成符合规则的形式:
因为右侧只能是两个Variable或者一个字符, 所以必须把下面这种长字符串变成多个规则串在一起:<br>
<img alt="Pasted image 20250203134729.png" src="cs3100/automata/attachments/pasted-image-20250203134729.png" target="_self">
CNF的好处是: 它用来设计CFG的算法很好, 并且对于一个CNF, 长度为N的字符串, 这个CNF一定会用2N-1的步骤去生成它, 不多也不少. PDA 可以说是一个Finite Automata + Stack.
我们可以往这个栈里面压入数据或者取出数据, 这就让DFA有了记忆.又回到了之前的问题:
我们之所以没办法设计一个机器识别这个字符串, 是因为没有记忆来记录0和1的数量. 但现在不一样了:
我们可以一边添加0, 一边在栈中压入0, 当我们开始添加1的时候, 就开始从栈中取出0, 直到0被取光. Formal Description
5. 从输入中读取0, 并同样压入栈, 直到读到1
6. 当读到1, 开始从栈中pop 0
7. 当1读完的时候, 刚好栈空了, 则接受这个字符串, 否则拒绝 - 如1比0多, 1比0少, 或者0夹在了1中间.因为转移方程可能有多种选择 (跟NFA一样), 所以和NFA一样, 只要有其中一个Computation thread在Accept state, 就接受这个字符串<br>
<img alt="Pasted image 20250203143205.png" src="cs3100/automata/attachments/pasted-image-20250203143205.png" target="_self">q2q3q1ε,ε$0,ε01,0ε1,0εq4ε,$ε
上图就是一个机器用来检测 <br><img alt="Pasted image 20250203144505.png" src="cs3100/automata/attachments/pasted-image-20250203144505.png" target="_self">
通常我们都在最开始放一个$来检测栈有没有空
需要注意的是, PDA不可以显式的去检测输入有没有空: 因为我们可以不读取任何字符串, 然后直接对栈进行操作. 所以有可能字符串读完了, 我们还有操作没做. 如上面的这种语言, 我们需要识别出一个字符串, 这个字符串分为两段, 前半段是后半段的相反.
由于PDA跟NFA的行为比较相似: 他们都可以是同时走多条路线.<br>
<img alt="Pasted image 20250205133510.png" src="cs3100/automata/attachments/pasted-image-20250205133510.png" target="_self">
因为可以走多条路线, 所以我们每次添加一个字符, 都可以认为这个字符的下一个是属于后半段的, 就通过一个空字符来转移到开始检测后半段的部分.画图蛮麻烦的, 我们可以用"伪代码"的形式表示出来图
Read and push input symbols. Nondeterministically(表示的是空字符串转移状态) either repeat or go to (2), i.e., guess the middle is reached.
Read input symbols and pop stack symbols, compare. If ≠, then reject this branch.
If all input is read and stack is empty, then accept 读取所有a, 直到读取到b. Nondeterministically to 状态2或状态4
每读取一个b, pop一个a. 如果没有任何a在stack中, 且读取到了c,到3
如果所有的input都是c, 则accept
读取每一个b, 直到读取到c, 然后开始每读取到c, 就pop一个a. 如果没有任何a在stack中, 并且没有任何input, 则accept
像之前的Regular language == DFA一样, 我们可以证明Context Free Grammar和Push Down Automata可以互相转换CFG -&gt; PDA
首先, 我们需要先证明所有的CFG都可以转换成PDA<br><img alt="Pasted image 20250205140713.png" src="cs3100/automata/attachments/pasted-image-20250205140713.png" target="_self"><br>
<img alt="Pasted image 20250205140724.png" src="cs3100/automata/attachments/pasted-image-20250205140724.png" target="_self">
具体步骤就是:
把Start Variable和$符号一起放入栈中
重复下面的几步 如果栈顶是一个变量A, 则Nondeterministically选择一个A的替换规则 (如上图第一个E变成了E+T)
如果栈顶是一个字符(terminal)a, 则读取下一个输入字符和这字符a作比较, 如果不相等, 则拒绝这个字符串
如果栈顶是$, 则进入Accept State, 如果没有任何字符了, 则接受这个字符串 Example<br><img alt="Pasted image 20250205141829.png" src="cs3100/automata/attachments/pasted-image-20250205141829.png" target="_self">现在需要证明所有的PDA都可以变成CFG.
但这个证明太复杂虽然PDA已经很强大了, 但是我们仍无法解决这样的问题:
Pumping Lemma for CFLs:
这个跟之前的有点相似:
对于所有的CFL A, 有一个pumping length p, 它会使一个字符串分为5段s = uvxyz. 这个字符串s存在于A中, 且s的长度大于等于p.
这个被切成5段的字符串有下面特性:<br>
首先, 我们先假设CFL是<a data-tooltip-position="top" aria-label="Context Free Languages > Chomosky Normal Form(CNF)" data-href="Context Free Languages#Chomosky Normal Form(CNF)" href="cs3100/automata/context-free-languages.html#Chomosky_Normal_Form(CNF)_0" class="internal-link" target="_self" rel="noopener nofollow">CNF</a>形式, 所以对于Parse Tree, 他会生成一个二叉树: CNF规定一个变量只能变成两个变量或者一个terminal. 在二叉树的最底端, 每个叶子Variable连着一个terminal.我们还假设这个树超级大, 以至于所有变量就算用一遍也生成不了这个字符串, 这就表示至少有一个变量用了两遍. 我们单拎出这一条重复某个变量两次的路线来讨论如上面这个长度的字符串就一定会有个重复的变量在路径的某处, 因为高度都有var+1那么高<br><img alt="Pasted image 20250205144526.png" src="cs3100/automata/attachments/pasted-image-20250205144526.png" target="_self">
这里就假设, 这个重复的变量是R, 由于CNF的规则, 除了起始变量以外的变量不可以变成空字符串, 所以这个变量R一定会一生二, 二生四... 然后产出一条长的字符串, 在这里, 第一个出现的R最终得到的字符串是v+x+y这么长.
当然, 由于R会重复, 所以第二个R也产生了一段字符串, 这里是x
所以我们可以记作:emmmm, 等等, 这个R最终能变成vRy感觉是个递归啊: 字符串v和y可以左右无限延伸: 这就是为什么在规则中我们写
但为什么第二个规则要写|vy|&gt;0是因为如果第一个R的左子树或者右子树正好是第二个R, 那么这第二个R产生的子树x就会把v或者y给挤掉. 但永远不会同时挤掉两个对于第三个规则, 我们可以把R(vxy)定义成最后一遍重复的R, 这样, 它一定不会比p长.如何选择p?
如果我们用的是上面的方法(CNF), 那么我们知道, 一个Var只可以变成两个Var, 所以就是定于一个b, b=2, 如果不是CNF, 我们把b定义成规则右侧最长的数量, 如A=B+C, 这里b=3, 再定义一个m, m是表示这个规则中所有Variable的数量
然后我们可以说
只要大于等于p长度的字符串, 则一定包含两个重复的变量. 现在, 就来用Pumping Lamma来证明无法变成一个PDA, 或者说它不是一个CFG.我们可以先说有一个字符串s, 它:
根据之前的规则:我们可以知道 且, 所以表示的是我们不能同时在vxy中包含0和2, 因为单单1的字符串长度就是p了. 这就导致了如果我们重复v和y, 就会导致出现不相等的0或1或2.
根据Proof by Contradiction, B这个语言不是个CFG.虽然PDA可以识别
这是因为第二部分的字符串是反着的, 我们可以用栈的后进先出的特点去检测. 但语言C不行. 我们现在来证明它.我们现在来假设一个字符串:我们可以选择v=0, x=1, y=0, 这样他的长度是3, 也满足小于p, 并且v和y可以无限重复, 也在语言A中. 这时, 会发现我们选择的字符串不怎么好, 因为它没有证明这个语言不是CFG上个字符串因为1太少了, 让我们可以让v和y同时包含两个0. 但这个字符串不会了:这个字符串因为我们无法同时在v和y中包含三个数 - 因为如果三想包含三个数, 中间夹的字符串长度必定等于p, 这就导致了v和y不能同时包含一个相同的数, 如0,0或者1,1. 这样, 如果重复v和y的话, 就会导致前后两段字符串不再相等.
然后我们就可以用Proof By Contradiction来表示这个语言A不是CFG.现在有个语言:
现在需要证明这个语言不是CFG
我们可以用Pumping Down的方法(也就是把v和y数量1变成0)
假设, 由于这三个字母的长度都是p, 这就导致中不可能同时包含三个字母.
如果让同时包含ab, 我们重复v或者y就会违反规则
如果同时包含bc, 则如果我们删掉, 就会导致bc字符串部分比a的部分少
如果只包含a或者c, 如果重复a, 会满足不了规则, 如果删掉c, 也满足不了规则. 像之前的DFA一样, Context Free Language也是有Closure Properties的: 这个套路跟以前一样, 新加一个初始Variable, 然后这个Variable 既可以去原本的起始变量也可以去另外一个起始变量这个也很简单, 如果想连接两个语言, 可以直接创建一个新的变量, 它会同时变成两个起始变量这个跟Concatenation 有点相似, 我们可以增加一个起始变量, 它可以变成空字符串或者变成自己和原本的起始变量:
Intersection并不是一个Closed操作, 也就是说两个CFL相交, 产生的并不一定是CFL, 如:可以看到, 这两个语言都是CFL, 但合并在一起, 就变成了
而这个已经被证明过不是CFL了但如果是一个Regular Language, 是一个CFL, 也会是个CFL.<br>
如果想设计出这样的PDA, 我们可以同时记录原本的DFA和PDA的State, 就像<a data-href="Conecpts#Closure properties" href="cs3100/automata/conecpts.html#Closure properties" class="internal-link" target="_self" rel="noopener nofollow">Conecpts &gt; Closure properties</a>里的Intersection一样
当然, 我们还得记录PDA中对于栈的修改, 加到对应的节点上.]]></description><link>cs3100/automata/context-free-languages.html</link><guid isPermaLink="false">CS3100/Automata/Context Free Languages.md</guid><pubDate>Mon, 03 Mar 2025 23:57:15 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Conecpts]]></title><description><![CDATA[A union B
A Diff B:
A Cartesian product B
Complement of A : _A
Alphabet: 非空的有限的一个字符的集合
String: 从Alphabet中选出的字符组成的一个有限的序列
这个w就是一个对于α的一个字符串
表示的就是这个w字符串的长度
表示的就是一个空的字符串如果一个字符串是另一个字符串中连续的一段, 则这个字符串是substringConcatenation
如果把一个字符串y跟在字符串x后面, 则就可以得到Concatenation xyLanguage
a set of string over an alphabetEmpty language, 也就是没有任何string的language
如表示的就是一个合集, 里面有01, 0011, 000111...]]></description><link>cs3100/automata/conecpts.html</link><guid isPermaLink="false">CS3100/Automata/Conecpts.md</guid><pubDate>Mon, 03 Mar 2025 20:38:49 GMT</pubDate></item><item><title><![CDATA[Q2]]></title><description><![CDATA[q1q20-&gt;x,Rq3#-&gt;R0-&gt;Rq41-&gt;x,Lx-&gt;Rx-&gt;Lq5#-&gt;L0-&gt;Lx-&gt;R#-&gt;Rq6x-&gt;Raccept˽-&gt;R]]></description><link>cs3100/hw/hw4/q2.html</link><guid isPermaLink="false">CS3100/HW/HW4/Q2.md</guid><pubDate>Wed, 26 Feb 2025 23:09:00 GMT</pubDate></item><item><title><![CDATA[HW1]]></title><description><![CDATA[Both 3 and 4 string will be accepted by MWhich is one or more 0 followed with one 1, and followed with any number of 0aabaa(3), bbaab(4) and bbbaa(5) will be accepted by this NFA. q1q2q30q3q11x0,1101]]></description><link>cs3100/hw/hw1/hw1.html</link><guid isPermaLink="false">CS3100/HW/HW1/HW1.md</guid><pubDate>Wed, 26 Feb 2025 22:59:00 GMT</pubDate></item><item><title><![CDATA[Turing Machine]]></title><description><![CDATA[图灵机是图灵在1936年提出的一个设想, 类似是一个Push Down Automata, 不过它可以访问任意位置的内存具体的操作是:
在一个无限长的纸带(无限的内存) 上面, 通过有限的数量的规则定义的操作操纵一个指针, 在纸带上左移 / 右移, 然后在指着的地方写入数据, 虽然纸带是无限长的, 但指针不能左移到起始点的左侧.
同时, 这个纸带也记录着我们输入的数据.
这个机器的另一个特点就是可以在任意时候接受/拒绝. 不像PDA那样必须读完所有输入才可接受/拒绝.
但它也有一个毛病: 这个机器只要没有接受/拒绝, 他会一直运行下去, 不管有没有输入, 这种叫做停机问题, 因为我们根本不知道它什么时候会停. 比如, 我们可以设计出一个图灵机, 它可以识别: 搜索"#", 如果没有, 则拒绝, 如果有, 回到最左边
开始检测第一个字符和"#"后的第一个字符是否相等, 不等则拒绝, 如果相等, 则删掉这两个字符
开始以同样的方法检测第二个字符, 直到所有字符均已检测, 这样就可以接受.
上面说的"删掉" 更准确的说, 我们是把这个字符替换成一个特殊的字符, 替换成这字符就表示删掉了. 因为我们没办法直接删除数据. 描述图灵机分为三类:
Formal Description
Implementation description - 描述出更细节的High-level description, 描述了如何修改数据, 但不用画出state diagram
High-level description - 单纯的描述算法, 不用管指针和纸带具体的规则
图灵机是一个7-tuple Machine: <img alt="Pasted image 20250212141933.png" src="cs3100/turing-machine/attachments/pasted-image-20250212141933.png" target="_self">
其中, 都只有一个对于一个输入, 永远只有两个结果: 接受和拒绝, 不过拒绝有两个情况: 一个是停机拒绝, 另一个是继续运行(looping), 我们称他为reject by looping.对于之前的问题, 画成图就是这样的:<br>
<img alt="Pasted image 20250212142741.png" src="cs3100/turing-machine/attachments/pasted-image-20250212142741.png" target="_self" style="width: 400px; max-width: 100%;">
其中的表示的是我们把1变成x, 然后把指针向右移. 写成公式就是
我们也可以不修改这个字符, 直接移动指针: 检测是否字符串是, 如果不是, 则拒绝
先删除一个a, 然后开始移动到b, 然后每删除一个b, 就删除一个c, 直到所有b消失 如果所有的c都消失了, 但b没有消失, 则拒绝 恢复所有删除的b
如果有剩余的a, 返回第三步
如果没有任何的a和c, 则接受这个字符串.
=“On input w:
1. Check whether w has #; if not, reject.
2. Check whether the substring of w on the left side of # is the same as the substring on&nbsp;
the right side of #. If yes, accept; otherwise reject.”
: Current State
: 在纸带上, 指针之前所有的字符
: 在纸带上, 指针之后所有的字符 (包含指针所指的这个字符)
: 在纸带上所有的字符
比如, 我们想把这个图灵机设计成初始状态: 指针在最左边, 指针右侧是输入: - 也就是是start state 就是我们的输入上面的这种设置, 我们可以说如果能通过单纯的一步变成新的设置, 则我们可以说 Yield 如: Yield if , 就像这里我们把指针指着的a变成了b, 然后指针左移如果一个start configuration 能变成, 一直变成, 并且 是Accept Configuration, 我们就说接受这个字符串现在, 来设计一个图灵机, 它可以识别这个字符串是否是:
也就是说必须全部是0组成, 并且0的数量必须是2的次幂, 如1,2,4,8,16个0首先, 从抽象层面去想这个算法, 无非就是去检测这个数是不是2的次方. 对于这种操作, 我们可以把这个数一直除以2, 直到得到1.
对于图灵机来说, 我们可以先检测这个0的数量是不是双数. 然后隔一个0就删掉一个0. 做完一边操作之后, 再检测一遍是不是双数个0, 如果是, 继续下去, 如果是单数个0, 则判断是否只有一个0, 如果只有一个0就接受.现在伪代码写完了, 现在开始设计一个图灵机吧
我们需要搞一个特殊符号在左侧替换掉0, 不然我们不会知道什么时候到最左边. 这里我们用空符号来替换掉最左侧的0 ()
我们还不想要空字符串, 所以如果刚开始就遇到空符号, 则直接拒绝
现在就需要隔一个删一个了: 因为我们想先略过一个0再删一个, 然后第一个0已经被我们标记成空符号了, 所以直接开始删掉下一个字符, 然后开始往右隔一个删一个()
但如果我们在跳过一个0后, 发现没有0给我们删了, 就表示这个0的数量不是双数了, 则直接拒绝
到达最右侧后, 我们会开始往左移动, 直到最左侧()
然后又开始向右开始检测, 如果我们看不到任何0了, 就表示我们把这个字符串除以多次0之后, 只剩下第一个0, 就接受(), 如果看到0了, 就说明还有1个以上的0, 所以我们继续开始隔一个删一个()<br>
<img alt="Pasted image 20250219143241.png" src="cs3100/turing-machine/attachments/pasted-image-20250219143241.png" target="_self">
再来看另一个例子:
首先我们需要用Implementation-level description - 也就是先形容指针是怎么移动的: 检测是否字符串是, 如果不是, 则拒绝
先删除一个a, 然后开始移动到b, 然后每删除一个b, 就删除一个c, 直到所有b消失 如果所有的c都消失了, 但b没有消失, 则拒绝 恢复所有删除的b
如果有剩余的a, 返回第三步
如果没有任何的a和c, 则接受这个字符串.
首先让一个图灵机识别语言
如果还有另外一个语言, 我们会说可以识别如果
这种语言就叫Turing-recognizable如果会在任何输入都一定会停机(Halts - 也就是不会无限循环), 我们会说这个图灵机是Decider
如果另外一个语言, 我们会说 decide 如果 且 是Decider, 并且这个语言是deciable或者Turing-Decidable假设这个语言对于一个图灵机
如果是 T-recognizer
对于所有字符串, 字符串都会让机器停机并接受
但如果字符串, 我们无法知道字符串会让机器无限循环(也算拒绝的一种)还是停机并拒绝
如果是decider
对于所有字符串, 字符串都会让机器停机并接受
如果字符串, 字符串都会让机器停机并拒绝
我们可以说, T-recogniazble是语言最外层的集合, 里面包含了T-decidablel, 图灵机的集合里包含了CFLs, 而CFLs的集合中又包含了Regular Language.首先, 就是Decidable语言在union下有闭包性质: 也就是语言他们俩都是Decidablel, 则 也是Decidablel.为了证明这一点, 我们就需要设计一个图灵机, 他可以同时识别语言和语言:
对于字符串运行图灵机, 如果接受则接受, 如果拒绝则执行步骤2
对于字符串运行图灵机, 如果接受则接受, 如果拒绝则拒绝
既然Decidablel已经有Closure under Union了, 我们来看一下Recogniazble会不会Closure under Union:
但我们不能用上面那一点, 因为对于decider图灵机, 我们可以保证图灵机会停机并拒绝, 但对于Recogniazble语言, 对应的图灵机我们无法保证图灵机会停机 - 它可能会reject by looping.我们可以稍作修改: 也就是做一个NTM来同时运行两个字符串, 如果把这个NTM转换成DTM, 也就是根据的规则运行一步, 然后再运行一步, 这么交替运行下去(达成了并行的方法). 如果其中一个机器接受了, 则接受. 如果两个机器都停机并拒绝了, 则拒绝. 如果两个机器都无限运行下去, 则这个字符串就是reject by looping现在我们想证明对于Concatenation, 两个Decidable语言的Concatenation也会是一个Decidable语言.这时候, 又要请出NTM了: 我们需要找到正确的切割点, 把字符串分成能识别的和能识别的. 然后让两个机器去分别检测两个对应的字符串, 然后如果其中一个拒绝, 则我们拒绝. 如果两个机器都接受, 则我们接受这个字符串.对于recogniazble语言, 证明也是很相似的M= “On input w:
1. Non-deterministically partition w into two substrings w1w2
2. Run on . If it halts and rejects, reject. If it accepts, continue on Step 3.
3. Run on . If it halts and rejects, reject. If it accepts, accept.”注意: 在证明recogniazble的时候不要单纯的说如果机器拒绝... 因为单纯的拒绝没有意义, 它可能还存在reject by looping. 我们需要准确说halts and rejects图灵机就是现代计算机的原型. 但为什么用图灵机当原型?
这是因为其他的模型跟图灵机能做到的都差不多 - 就像不同的编程语言实现同一种算法一样, 他们性能可能稍微不同, 但都能实现相同的算法.我们选这个图灵机主要的一个原因就是它比较简单易懂. 而我们现在会看一些其他的图灵机变种:
stay put TMs
Multitape TMs
Nodeterministic TMs
这个是跟我们学过的图灵机非常的相似: 他就是单纯的在我们学过的图灵机上加了一个新功能: 可以让指针不移动这个图灵机和我们之前学过的图灵机能干到的东西是完全一致的, 因为我们可以证明就算它多了一个功能, 还是没有产生质的飞跃:
为了证明这个, 我们可以制造一个图灵机, 用来模拟Stay put 图灵机 - . 非常简单粗暴, 直接让原版图灵机先右移然后再左移就能达成原地不动的效果.
虽然这种需要多执行一步, 但不得不承认的事情是原版图灵机也能做到. 这个图灵机的效果就是有多条纸带: 其中一条是输入, 然后有很多很多条用来存数据的纸带. 我们可以同时用多个指针读写多条纸带.
这个听起来很牛逼的样子, 但实际上还是跟原版图灵机相似:
跟上面的证明方法一样, 我们仍然需要创建一个原版图灵机, 它等价于Multitape 图灵机.
答案是, 在这个无限长的纸带上面, 分割成很多段, 每段代表其中的一条纸带. 如果Multitape图灵机中的某条纸带需要额外空间, 则我们把在这个原版图灵机的对应的部分之后的所有元素往后移动一个, 这样就会得到一个新的空间.
虽然这样听起来非常麻烦, 但仍然符合要求不是吗.这个挺好理解: 也就是之前的DFA变成NFA, 我们这里需要证明 "NTM" 等价于原版图灵机.
其实方法比较简单, 我们只需要根据之前把NFA变成DFA的方法来改就可以把一个Nodeterministic TM变成一个图灵机.我们可以把这个NTM的每条分支都当做树的一个节点, 然后通过BFS(广度优先搜索)搜索有没有接受State现在就来构造一个DTM来达成跟NTM同样效果的图灵机吧:
首先, 我们需要想象一个多叉树来表示这个NTM所有的分支. 回想2420中如何完成BFS - 也就是把根节点的所有子节点放到一个队列(FIFO)中, 然后再从队列中pop出一个, 把这个新pop的节点的子节点放入队列中如此循环
对应到TM中就是对于一个根节点是A, 有BCD子节点的树, 我们会在纸带上写上A#B#C#D, 然后指针往后移动到B, 找到B的子节点是EFG, 纸带就变成了x#x#C#D#E#F#G如此循环. 直到遇到了Accept State.]]></description><link>cs3100/turing-machine/turing-machine.html</link><guid isPermaLink="false">CS3100/Turing Machine/Turing Machine.md</guid><pubDate>Wed, 26 Feb 2025 21:46:54 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Query Language]]></title><description><![CDATA[如果我们自己来写数据库, 则查数据的时候, 就需要写:for (x in xxx){ xxxxxx
}
对于大量的查询, 这是很容易出错的, 所以最好的方法就是用现存的一些已经写好的语法, 如SQL软件中的语法SELECT name FROM Students JOIN Courses WHERE courseName = "Database"
比如上面的代码就是, 我们想找到所有的学生名字, 那些学生是来自Students数据库, 并且让Students数据和Courses数据关联, 再筛选出所有课名是Database的show databases; //列出所有数据库
use xxx; // 使用某个数据库
show tables; //列出所有表格
My SQL支持很多中类型:
Integers - [tiny, small, medium, big]int [unsigned]
Reals - float, double, decimal
Dates - Date, datetime, timestamp, time, year
Strings - char(m), varchar(m) - SQL中需要规定String的大小
Blobs - Binary Large Objects - 可能是视频, 文件等
Enums CREATE TABLE &lt;name&gt; ( &lt;column1Name&gt; &lt;type&gt; [col properties], &lt;column2Name&gt; &lt;type&gt; [col properties], ..., [table properties]
);
用上面的代码可以创建出一个表格, &lt;&gt;表示的是占位符每列都可规定Column Properties, 比如NOT NULL
UNIQUE
PRIMARY KEY
DEFAULT (expression)
AUTO_INCREMENT //设置数值是否自增
CHECK (expression)//检测此列数值是否在规定范围内
REFERENCES reftable(refcolumn) [ON DELETE action] [ON UPDATE action]//把这列设成foreign key
//最后两个指令有些MySQL上用不了, 虽然能执行, 但不会干任何事情, 通常把他们设成table wide pro
Table Constraints是写在表格的最后面, 并且我们可以给它一个名称:CONSTRAINT constraint_name constraintsUNIQUE(col_name [...,...])
PRIMARY KEY(col_name [...,...])
FOREIGN KEY(col_name [...,...]) 想要在SQL中用Foreign Key的话, 需要:
Foreign必须要有引用的key
Foreign key和被引用的key必须要有同样的type
声明Foreign key的时候需要和声明被引用的key是同样的顺序, 如PK(x, y)就必须是FK(x, y)
在mySQL中, 应该这么写::FOREIGN KEY(&lt;columns&gt;) REFERENCES &lt;table&gt;(&lt;table's key&gt;) ON DELETE &lt;action&gt;
ON UPDATE &lt;action&gt;
比如已经有了一个t1的表格, 然后想创建一个叫ref1的表格, 并且让ref1里的属性a引用t1里面的xcreate table ref1(a int, foreign key(a) references t1(x))
这样操作之后, SQL就不会允许我们在ref1表格中插入t1的x没有的key了如果被ref的表格的key是由两个属性组成的, 则引用的时候需要同时写上这两个属性, 不然数据库会拒绝此操作(如t2的表格的PK是由x,y同时组成的)create table ref2(a int, b int, foreign key(a,b) references t2(x,y) on delete cascade)
上面还定义了删除会使用什么操作, 这里用的是<a data-tooltip-position="top" aria-label="Structured data > Referential Integrity" data-href="Structured data#Referential Integrity" href="cs5530/structured-data.html#Referential Integrity" class="internal-link" target="_self" rel="noopener nofollow">cascade</a>操作
就算我们使用了cascade操作, 但如果想要drop(直接删除)这个被引用列的表格的时候, 数据库也会拒绝, 因为这样正在引用的数据库就没有意义了ALTER TABLE &lt;table&gt; ADD &lt;column&gt;
//eg:
ALTER TABLE Title ADD PubDate DATE NOT NULL;
上面这个操作在添加完数据后, 因为我们设置了不允许NULL, 它已经存在的行的PubDate 会变成DATE数据类型的默认值:0000-00-00ALTER TABLE &lt;table&gt; MODIFY &lt;column&gt; &lt;new type&gt;
//eg:
ALTER TABLE Inventory MODIFY Serial INT UNSIGNED
//添加 Foreign Key
ALTER TABLE &lt;table&gt; ADD FOREIGN KEY (columns) REFERENCES &lt;table&gt;(columns)
//eg:
ALTER TABLE &lt;Phones&gt; ADD FOREIGN KEY (CardNum) REFERENCES &lt;Patrons&gt;(CardNum) //删除 Foreign Key
ALTER TABLE &lt;table&gt; DROP FOREIGN KEY &lt;constraint_name&gt;
//eg:
ALTER TABLE &lt;Phones&gt; DROP FOREIGN KEY &lt;cardnum_fk&gt;
INSERT INTO &lt;table name&gt; VALUES(value1, value2)
这个意思就是把数据插入到表格中, value1, 2...表示的是插入一行数据, 一行的每列从左到右的值
可以用describe Table来看这个表格的每列是什么INSERT INTO &lt;table name&gt; (colX, colY) VALUES(value1, value2)
如果有些数据是系统生成的, 则可以用上面的代码 - 我们规定了只输入哪些列的值, 而没有填写的值会以设定的方式来填写(如自增或者NULL)有时候我们会想让SQL跟编程语言中的map一样: 如果不存在就创建, 如果存在就更新. 这个是支持的, 只要在指令后面跟上ON DUPLICATE KEY UPDATE就行
如我们想添加一个玩家的ELO信息, ELO取最高值.insert into Players (Name, Elo) values ("So, Wesley", 2880)
ON DUPLICATE KEY UPDATE Elo = IF(2880 &gt; Elo, 2880, Elo);
这里用的IF更像是三元运算符: 如果前面的条件是True, 值会变成2880, 否则则会保持不变(Elo)注意, 如果Delete指令没有写Where的话, 他会直接删除整个表格的所有行DELETE FROM &lt;Table name&gt; WHERE ... 然而光这么删不会更新自增数字: 比如卡号5被删掉了, 新的卡号加进去会是6, 而不是补上5. 如果要更新自增数字, 就需要:alter table Patrons auto_increment=5 如果想要修改数据, 可以用Set关键词:UPDATE &lt;table name&gt; SET col1 = val1, col2 = val2 WHERE ... SELECT [DISTINCT] target-list
FROM relation-list
[WHERE qualification]
[ORDER BY column] [DESC]
[LIMIT number]
这是一条完整的SQL查询语句, 其中的[]表示的可以选填的数据
Select: 选择某列, 也可以用星号*表示全部, 也叫wildcards
Dinstinct: 表示过滤掉所有选出的列的重复的行
From: 表示选择的目标
Where: 表示的是一些过滤条件, 条件是布尔表达式
Order By: 根据某列来进行排列
Desc: 表示要降序排列
Limit: 返回的行的数量
当我们想把某些数据筛选出来(如最老的几本书), 你可能会肉眼去看最老的几本是哪几本, 然后用WHERE Serial &lt;= 1003来得到. 然而, 这种先知道答案再去查询的操作就是Query By Instance, 并且它是一个很坏的操作, 因为是依靠我们目前所知的信息去筛选的, 但凡数据稍微变化, 就会产生问题. 实际上, 我们可以使用Order By + LIMIT 来寻找, 就算数据产生变化, 我们仍然可以知道最老的几本书是哪些当然, 请不要把Query By Instance和 "使用常数去筛选" 搞混, 前者是依靠我们的有限的信息去筛选, 而后者是我们本来就要去筛选这个, 如 "叫John的会员"现在, 需要考虑的是如何查询带有关系的表格, 如一个表格Phones记录的Card num和Phone num, 另一个记录了Card Num和Name. 而现在想知道的是某个人的电话是什么这时候, 如果我们只用SELECT函数也是可以的, 不过这个操作是把表格合并起来, 不过合并的方式很简单粗暴: 就是把每个可能的组合都合并起来, 得到的新表格的行数就是两个旧表格行数的乘积, 所以这个操作也叫Cross ProductSELECT * FROM Patrons, Phones
可想而知, 这样会得到非常多的没用的数据. 这时候就要用WHERE筛选: SELECT Patrons.CardNum, Name, Phone FROM Patrons, Phone
WHERE Patrons.CardNum = Phones.CardNum
因为SQL表格不允许有重复的Attribute, 所以我们需要用表格标题来区分这个表格里重复的属性.在实际操作中, 是非常建议加上Filter的, 因为数据多起来, Cross Product的数量也会变得越来越多. 而加上过滤的话, 系统会先过滤, 然后再相乘实际上, 上面的这种写法就是同等与Join:SELECT * FROM Patrons, Phones
SELECT * FROM Patrons JOIN Phones
SELECT * FROM Patrons INNER JOIN Phones
这三种写法完全一样, 都是创建一个临时的表格, 来存放生成出来的cross product相似的, 也可以用on来代替where:SELECT Patrons.CardNum, Name, Phone FROM Patrons, Phone
ON Patrons.CardNum = Phones.CardNum
不过, 这个On 只能用在Join后面, 且大部分时候都不太需要, 除非在某些Outer Join的情况下上面的这种情况很常见, 所以就有个操作: Natural JoinSELECT * FROM Patrons NATURAL JOIN Phones;
SQL会知道这两个表格相同的就是Card num, 然后会Join在一起, 并只显示一列. 如果两个表格里有两列相同的Attribute, 则Natural Join只会显示出两个Attribute 同时相等的一行T1 JOIN T2 WHERE T1.x = T2.x AND T1.y=T2.y
看起来似乎Join只能连接两个表格, 实际上, 这个Join本质就是产生一个临时的新表格, 所以我们可以用多个Join来连接多个表格:Patrons JOIN CheckedOut JOIN Inventory
<br>之前, 我们学了如何用<a data-href="Relational Algebra" href="cs5530/relational-algebra.html" class="internal-link" target="_self" rel="noopener nofollow">Relational Algebra</a>来更容易的写出查询某个数据的伪代码, 现在是时候把它变成SQL看得懂的代码了虽然没有一个模板, 可以把伪代码直接变成SQL, 但还是有一些规律的首先, SQL不能没有SELECT, 对应的就是π. 不过就算关系代数里没有π, 也需要写SELECT *. 然后, 我们的第二个基本符号就是σ, 它对应的就是WHERE 如:
SELECT CardNum FROM Patrons WHERE Name = "Dan";
那么命名呢? SQL里其实也是有命名的SELECT p.CardNum from Patrons p WHERE p.Name = "Joe";
只需要在本来的名字后面跟着别名, 就可以完成命名(两个名字都可以使用)
并且神奇的是, 就算在命名之前, 也是可以用这个别名的, 如上面的p.CardNum上面只是命名整个表格, 我们还可以用as重命名某个列:SELECT p.CardNum as cn from Patrons p WHERE p.Name = "Joe";
这样, 输出的表格在显示出来的时候, 就会显示cn而不是CardNumSELECT Serial FROM
(SELECT ISBN FROM Titles WHERE Title = "The Lorax") as lorax
NATURAL JOIN Inventory;
在SQL中也可以加括号, 然后再用as来给这个括号中得到的表格一个新名字. 虽然在上面的代码中, 我们没有用到我们起的lorax的名字的表格, 但这样做不仅是对我们有用, 更多的是为了避免SQL混淆对于cross productx, 和⋈ 都非常好表示, 其实就是JOIN和NATURAL JOIN. 而Union 就稍微有点奇怪了. 比如我们现在有两个表格, 里面都有Addr属性, 现在我们想把他们合并成一个表格:SELECT Addr FROM T1 UNION SELECT Addr FROM T2
之所以说奇怪, 是因为这个SQL语句不是Nested Query, 但是它有两个SELECT
并且在合并的时候, SQL会自动去重, 除非我们写UNION ALL, 会允许重复出现 还有一点奇怪的是, 假设T1和T2是可以直接合并的 - 也就是说两个表格的属性都是一样, 但我们还是不可以直接Union, 还是得select * 才可以.T1 UNION T2; //WRONG
SELECT * T1 UNION SELECT * T2;//CORRECT
并且, SQL跟Relational Algebra不一样的是, SQL其实是不关心数据类型的, 比如我在指令中把ID和地址合并到一起了, 在Relational Algebra中做不到, 因为名不一样, 但SQL却可以, 虽然得到的数据可以说是没有太大的意义, 甚至连什么type都没有准确定义虽然在SQL中定义了Intersection操作, 但在本节课的SQL服务器中, 并不存在这个指令.<br>
幸好的是, 在关系代数中就已经讨论过如何<a data-tooltip-position="top" aria-label="Relational Algebra > 稍微进阶" data-href="Relational Algebra#稍微进阶" href="cs5530/relational-algebra.html#稍微进阶" class="internal-link" target="_self" rel="noopener nofollow">用基本符号得到交集</a>或者我们可以换一种思路, 如果直接把两个数据做Cross Product, 然后去看对应的数据有没有同样的, 如果同样就说明这行数据在交集中
如:SELECT * FROM (SELECT Addr FROM T1) As T1Addr NATURAL JOIN (SELECT Addr FROM T2) As T2Addr;
或者, 可以用IN关键词. 这个IN就是跟在Where后面的, 表示我选的数据也需要在另外一组数据里面 SELECT ... FROM table1 WHERE x IN (SELECT ...);
SELECT Addr FROM T1 WHERE Addr IN (SELECT Addr FROM T2);
需要注意的是, 这个In后面跟着的Nested Query并不需要像之前的Nested Query一样加上as去除混淆.这个In关键词本质就是拿着前者的每行数据去后者的列表中一行一行的去看, 如果在第二个表格中存在这个数据的话, 则把这个数据放到结果表格中Set Difference跟Intersection很相似: Intersection是去得到两个表格中都有的, Difference是去掉两个表格中都有的数据. 可以说Difference就是"Not Intersection"非常巧的是, 上面的In关键词是可以在前面跟着Not的 - 也就是说我们可以得到某个数据, 它不在我们指定的表格中.
当然, Set Difference就是有先后顺序了, 比如我们想要让T1 - T2:SELECT Addr FROM T1 WHERE Addr NOT IN (SELECT Addr FROM T2);
现在, 有一个表格有id和手机号
如果想要找到一个表格中有相同手机号的人该怎么办?其实, 这个问题可以用Self Join解决:
如果我们把这个表格和自己Join, 就可以得到4列数据, 两列ID, 两列手机号.
而现在不是要去看相同的ID的行, 而是看不同ID的行: 也就是如果两列的ID不相同, 但手机号却相同, 这样就找到了拥有相同手机号的不同的人但仔细一想: 如果Self Join的话, 就需要我们重命名一下表格, 因为如果两个表格完全一样, 那么得到的属性也会是完全一样的: T1.a, T1.b, T1.a, T1.bSELECT p1.id, p2.id FROM Phones p1 JOIN Phones p2 WHERE p1.id != p2.id AND p1.phone = p2.phone
前面我们学过, 不管是JOIN还是INNER JOIN还是T1, T2, 得到的都是Inner Join, 也就是把前一个表格的每行和另外一个表格的每行组合到一起.但Outter Join不太一样: 它分为LEFT JOIN和RIGHT JOIN, 并且它还需要使用ON关键词LEFT JOINT1 LEFT JOIN T2 ON condition
他会首先像JOIN T2 ON ...那样选出所有的满足条件的行, 并且还会附加上T1(前者表格)里的所有行RIGHT JOINT1 LEFT JOIN T2 ON condition
可想而知, 他就是LEFT JOIN反过来: 先像JOIN那样选择所有满足条件的行, 然后再附加上T2表格中的所有行但具体有什么用呢?
它可以显示出更多的信息, 比如有两个表格, 一个是所有图书馆会员的卡号, 另一个表是图书馆的卡借出去的书
如果我们用SELECT * Patrons p LEFT JOIN CheckedOut c On p.id = c.id;
这样就可以得到所有会员的卡号, 并且如果有会员借了书的话, 还会包括这个会员借书的信息.
由于我们用的是Left Join, 左边的表(会员表)不管有没有满足要求(不管借没借书)都会出现在表格中. SQL会把那些空的信息用NULL填充并且Left Join和Right Join都支持Natural关键词, 也就是说上面检测id是否相同可以直接用Natural省略掉SELECT * Patrons NATURAL LEFT JOIN CheckedOut;
通过上面的表格, 我们可以直接知道哪些人没有借书:SELECT * Patrons NATURAL LEFT JOIN CheckedOut WHERE Book_Serial IS NULL;
//找出借书的人
SELECT * Patrons NATURAL LEFT JOIN CheckedOut WHERE Book_Serial IS NOT NULL;
至于为什么需要是IS NULL而不是=NULL, 是因为它并不是一个值, 他是Three Value Logic中的一个Logic之前肯定学过Two Value Logic: 也就是True 和False. 而Three Value Logic就是在这基础上加上个Unknown, 表示的是它既不是true, 也不是False.
在SQL中, NULL表示的就是Unknown
比如我们比较5 = NULL, 就好比我们问5是不是未知数一样, 答案也是未知的. 在编程语言中, 我们肯定会认为这本来就不相等: 因为NULL它是空啊
而在SQL中, 如果把一个数和未知数(NULL)作比较, 得到的永远是NULL. 如果我们把NULL和NULL做比较, 得到的也会是NULL. 这个NULL既不是True, 也不是False, 所以它不会满足任何条件.这就是为什么上面如果我们要查询一个数是不是空, 需要用IS, 而不是用=有意思的是, 我们可以用已知数和未知数做运算, 比如6+NULL, 可想而知, 得到的也会是NULL那么问题就来了: 如果一个记录作业成绩的表格中有作业分, 还有一列是Extra Credit, 但如果学生没做额外作业, Extra Credit就是Null 而不是0.如果我们直接相加Score和Extra, 就会导致问题: 数字+未知数=未知数SELECT (Score + Extra) FROM Scores; //可能返回NULL
这就需要用到COALESCE函数. 这个函数会接受一系列参数, 会返回这一系列参数中第一个不是NULL的值.COALESCE(NULL, NULL, 7, NULL, 15) -&gt; 7SELECT (Score + COALESCE(Extra,0)) FROM Scores; //不会返回NULL
在SQL中, 不仅仅可以用=,&gt;,&lt;等来比较字符串, 还可以用正则表达式来筛选字符串, 需要使用LIKE关键词SELECT * FROM T1 WHERE Title LIKE 'D_n%'
这个_表示的是一个任意的字符, %表示的是0个或任意多个任意的字符
不过SQL的"正则表达式" 肯定没有编程语言的那么牛逼SQL中有Date和DateTime类型. 他们包含的数据有差别:比如DOB是一个Date数据, 我们可以这么筛选:SELECT * FROM T1 WHERE DOB &gt; '1990-01-01';
虽然我们在拿一个Date和String作比较, 但是SQL很聪明, 可以把正确格式的String转换成Date由于Date还是符合类型, 所以可以访问其中的某个值:SELECT YEAR(DOB) FROM Students;
SELECT MONTH(DOB) FROM Students;
不止这些, SQL还有内置函数, 他可以把Date转换成其他格式:dayname(date) //告诉是星期几
monthname(date) //告诉是几月
dayofmonth(date)
...
SELECT dayname(DOB) FROM Students; //返回所有学生的生日是周几
SQL还可以使用获取到的日期来直接进行运算:SELECT Name, (2025 - year(DOB)) FROM Students;
不过这个有一些问题: 因为我们只考虑的年份, 所以如果这个学生是3月出生, 但现在还是2月, 那么说明这个学生还没有到下一岁. 这样会导致学生在2月之后出生的都多算了一岁.实际上, 我们可以用SQL给我们专门用来算日期的函数timestampdiff()SELECT Name, timestampdiff(year, DOB, '2025-02-02') FROM Students;
SELECT Name, timestampdiff(year, DOB, curdate()) FROM Students;
这个函数的第一个参数是结果显示的格式, 二和三参数是要做差的两个日期. 并且牛逼的是, 如果我们作差的格式是day, 它还会自动计算是不是闰年, 确保不会少几天或者直接用curdate()或者now()来获得今天的日期, 不过前者是Date, 后者返回的是DateTime. 当然这两个数据在这里都可以运行Aggregate function是一系列函数, 用来计算表格的某个值, 通常只作用于表格的某一列COUNT(...) //表格的行数
MAX(...) //这一列的平均值
MIN(...) SUM(...)
AVG(...) SELECT COUNT(ISBN) FROM Titles; //返回Title表格中ISBN的数量
并且, 得到的是单独的一个数, 所以我们可以把最终结果当做一个值进行运算:
比如想要求出Games里白方的胜率SELECT (SELECT COUNT(*) FROM Games WHERE Result="W") / (SELECT COUNT(*) FROM Games)
如果单用GROUP BY这个关键词, 他会先用指定的数据进行分组, 然后对于每组选出一个数据表示这个组. 如果只用Group By的话, 它跟distinct的作用是一样的: SELECT Major FROM Students GROUP BY Major;
SELECT DISTINCT Major FROM Students;
这两行命令都是返回一列Major数据, 然后每行是一个不重复的Major但如果我们搭配Aggregate function的时候, Group By就会开始变得有用起来了.
由于我们用了分组, 所以如果查询语句中还有Aggregate function, 他会给每组分别进行Aggregate操作:SELECT Major, Count(*) FROM Students GROUP BY Major;
这样我们会得到一张表格:它表示的就是每个专业分别有多少人通常来说, 因为这些数据都是代表整个组的, 所以我们通常是会展示出Aggregate的结果和分组的依据(如这里的Major). 如果我们用把语句中的第一个Major换成Name, 则这个结果就没有太大的意义了.
因为如果用显示Major和Count, 不管选出的数据随机到组里的哪个, 都能代表整个组的数据需要注意的是, Count()的参数并不总是可以用*, *表示的是任意一列只要有数据就行. 但如果我们用Student Left JOIN Enroll, 可能会得到含有Null的表格 - 如果某些学生没有参加任何课程的话.
这时候如果想统计每个学生报了几节课, 就需要用count(cID)这种了, 因为如果学生没有报课, 则Left Join之后他的cID那一列会是null. 当有统计了每节课有多少学生后, 如果有很多很多课, 但我只想找到那些学生数量大于5的课, 该怎么办?SELECT cID, Count(*) FROM Enroll GROUP BY cID WHERE Count(*) &gt; 5; //WRONG
然而, SQL不会允许我们对Aggregate function得到的结果使用Where进行筛选, 甚至Where关键词需要在Group by之前, 因为SQL允许的是我们是先对数据进行筛选, 再进行分组正确的是去使用Having关键词. SELECT cID, Count(*) FROM Enroll GROUP BY cID Having Count(*) &gt; 5;
SELECT cID, Count(*) as c FROM Enroll GROUP BY cID Having c &gt; 5;
<br>由于不想在语句中重复使用两次Aggregate function, 我们可以<a data-tooltip-position="top" aria-label="Query Language > Rename, Nested Queries" data-href="Query Language#Rename, Nested Queries" href="cs5530/query-language.html#Rename,_Nested_Queries_0" class="internal-link" target="_self" rel="noopener nofollow">重命名列</a>来化简.具体来说, Having是用来筛选组的, 而Where是专门用来筛选行的请记住, Aggregate 函数不是返回某行, 而是通过表格的数据运算后返回一个数据
但是, Group关键词分完组后, 给的是这个组中随机一行的数据. SELECT Dept, MIN(Price), Name FROM Items GROUP BY Dept;
比如上面的代码中尝试使用Group by + Aggregate函数来得到每个部门的最便宜的物品名字和价格.
但这个代码实际上是错的, 因为除了Min()返回的是通过整个Group计算的数据(是正确的), 剩下的两个数据完全就是在组中随机挑选的值.
由于是通过部门的名字分组, 所以部门也是正确的, 但每个商品的名字不同, 就导致名字很可能是错误的值.实际上, 由于我们已经知道了最小值, 我们可以再把得到的表格Join到原来的表格, 然后去Match到正确的名字.
如找到每个专业里最老的学生的名字:SELECT Name FROM Students Join (SELECT Major, MIN(DOB) AS dob FROM Students GROUP BY Major) AS oldest WHERE oldest.dob = Students.dob and oldest.Major = Students.Major;
上面的语句是先把学生按照专业分组, 找到每个专业最老的学生的出生日期, 并把得到的表格命名为oldest, 然后再让oldest表格和Student表格叉乘, 再根据出生日期和专业筛选就可以了如果想要找出学校专业的人数的平均值, 就可以通过Nested Query来做两次Aggregate:SELECT AVG(c) (SELECT COUNT(*) AS c FROM Students GROUP BY Major) AS temp;
这个就像是Switch语句, 可以生成一个新列, 这列的每行是根据这行的其他数据得到的:SELECT sID, cID,
CASE WHEN Grade LIKE 'A%' THEN 'Superior' WHEN Grade LIKE 'B%' THEN 'Good' WHEN Grade LIKE 'C%' THEN 'Adequate' else 'Poor'
END AS Remarks
FROM Enrolled;
这样, 我们会得到一个表格, 三列分别是学号和课号, 还有对应的"Remarks", 这个Remarks就是通过成绩来进行判断得来的如果我们判断的是分数, 或者年龄等, 那应该是按照顺序判断, 因为这个Case是从上到下判断的, 遇到的第一个满足条件的就会执行上面有些地方用 AS, 有些地方有不用, 下面是一个表格说了那些需要用, 哪些不需要:<br>Condition Operators就是之前用在Where后面的. 不仅仅是x &gt; 5这种是在查询Condition, 使用<a data-tooltip-position="top" aria-label="Query Language > ^24d577" data-href="Query Language#^24d577" href="cs5530/query-language.html#^24d577" class="internal-link" target="_self" rel="noopener nofollow">in</a>的时候, 也可以说是Condition, 因为它也是跟在Where后面的, 如:select x from y where x in (select ...);
这个in 不仅仅可以是个nested Query (某些操作会返回多行数据), 还可以是hard coded的值.除了in之外, 还有一些对于Nested Query的Condition:x IN A -&gt; true if x in A
EXISTS A -&gt; true if A is not empty
x OP ANY A -&gt; true, 如果A中的任意一个数据y, x OP y = true(这里OP是运算符如"=") 比如 x &gt; ANY A 表示的只要x比A中任意值大就是true
x OP ALL A -&gt; true, 如果A中的所有数据, 每个数据x OP y = true 比如 x &gt; ALL A 表示x必须比A中的所有值都大才是true
<br>有了它, 就可以做<a data-tooltip-position="top" aria-label="Relational Algebra > Division Operator" data-href="Relational Algebra#Division Operator" href="cs5530/relational-algebra.html#Division Operator" class="internal-link" target="_self" rel="noopener nofollow">division</a>的操作了:
比如我们想找出有没有学生把所有课都上了: 就可以先去看course (c)表, 得到所有课程的cID, 然后去看enroll (e)表 中的哪个学生同时拥有所有的cID就可以了
在SQL中, 可以这么做:select s.sName
from Students s
where not exists (select c.cID from Courses c where not exists (select e.cID from Enrolled e where e.cID = c.cID and e.sID = s.sID));
这里的格式显示出它是三个nested select, 可以把他想象成三个嵌套着的 for循环.
from Students s 可以看作是foreach Student s, 剩下的是foreach Course c...在最里层的循环, 我们就跟正常代码的循环一样, 拥有了s, c, e的信息SELECT e.cID FROM Enrolled e WHERE e.cID = c.cID AND e.sID = s.sID;
最里层的代码用伪代码展开就是这样的:for(Student s in Students_Table){ for(Course c in Courses_Table){ for(Enrolled e in Enrolled_Table){ if(e.cID == c.cID &amp;&amp; e.sID == s.sID) add this row } }
}
可以比作是循环Enroll表中的每个Enroll行, 如果不等于当前循环的学生id和课号, 则不返回当前行.第二个循环就是SELECT c.cID FROM Courses c WHERE NOT EXISTS (...);
因为我们用的是Not Exists, 表示的是内循环返回必须没有返回任何行
说人话就是只要学生没参加当前循环的这个课, 则把这个课返回.最后一个循环是select s.sName from Students s where not exists(...)
也就是说, 第二层循环返回了这个学生没有参加的所有的课, 而最外层循环则是再去检测当前的学生得到的 "没有参加的课" 的表是不是空的. 如果不是, 则不添加这个学生. 这样, 就可以得到参加了所有课的学生的名字了.<br>在之前学过如何删除数据<a data-tooltip-position="top" aria-label="Query Language > Delete" data-href="Query Language#Delete" href="cs5530/query-language.html#Delete_0" class="internal-link" target="_self" rel="noopener nofollow">Delete</a>. 当然, WHERE ... = x这个指令的x不仅仅可以是一个数, 还可以是一个sub query, 就像上面AS的部分说的. 比如我们可以写一个SQL指令是: 移除Joe在Checked out的所有的书(Joe的id是1).delete from CheckedOut where CardNum = 1;
这种是query by instance, 当然不想这么干, 我们可以用个子查询先查出Joe的ID是多少, 然后再进行删除:delete from CheckedOut where CardNum = (select CardNum from Patrons where Name = "Joe");
<br>但这种操作对于多个目标的时候就不能用了: 因为"="只能作用于单个数值比较. 对于比较多个数据, 我们需要用<a data-tooltip-position="top" aria-label="Query Language > ^24d577" data-href="Query Language#^24d577" href="cs5530/query-language.html#^24d577" class="internal-link" target="_self" rel="noopener nofollow">in</a>关键词delete from CheckedOut where CardNum in (select CardNum from Patrons where Name = "Joe" or Name = "Dan");
聪明的你可能发现: 为什么不用Join, 然后再删除? 这种操作看起来是可以的, 实际上是不行: 因为joint是生成一个临时表格, 但删除这个临时表格是没有意义的:delete from CheckedOut natural join where Name = "Joe"; //Wrong
不过我们可以稍加修改, 来让他符合我们的要求:delete CheckedOut from CheckedOut natural join where Name = "Joe"; //Wrong
这里, 我们是告诉SQL, 在Natural Join中符合要求的行, 对应到CheckedOut表格, 就是我们想要的数据.知道了怎么删除, 现在来看怎么添加数据. 假设Joe借了Lorax这本书, 我们想在CheckedOut中添加这个信息, 但这个是比较困难的, 因为CheckedOut表格中只有CardNum和Serial, 我们不能直接知道Lorax的序列号, 还有Joe的CardNum实际上, Insert操作和Delete操作差不多, 里面的数据不仅可以是固定的数值, 也可以是Nested Query:insert into CheckedOut values(x, 5);
insert into CheckedOut values( (select ...), (select ...)); insert into CheckedOut values( (select CardNum from Patrons where Name = "Joe"),
(select Serial from Titles natural join Inventory where Title = "Lorax" limit 1));
比如上面的第三条, 就能让我们添加Joe借了Lorax这本书的信息.不过这又有了个问题: 如果还有一个人要借这个Lorax, 虽然Inventory里有两本这个书, 但上面这个Query只会返回第一个Lorax. 所以我们还需要把这个指令修改一下, 这样它不会选择那些已经被Checked out的书insert into CheckedOut values( (select CardNum from Patrons where Name = "Joe"),
(select Serial from Titles natural join Inventory where Title = "Lorax" and Serial not in (select Serial from CheckedOut) limit 1));
这里, 我们通过添加一个and连接一个not in条件来限制
不过上面的代码还是有一个问题: 如果没有任何Lorax可以借, 那么那么SQL会直接报错.
因为如果没有书的话, 第二个Sub Query会返回一个NULL, 然后就表示我们试图把一个Null和一个数据添加到CheckedOut中. 如果我们不想直接报错(放到程序中会使程序崩溃), 而是给个警告的话, 就可以在开头添加一个ignore:insert ignore into CheckedOut values( (select CardNum from Patrons where Name = "Joe"),
(select Serial from Titles natural join Inventory where Title = "Lorax" limit 1));
这样, SQL就会遇到问题会记录下来, 使用show warnings;指令可以查看触发的警告]]></description><link>cs5530/query-language.html</link><guid isPermaLink="false">CS5530/Query Language.md</guid><pubDate>Sun, 23 Feb 2025 05:04:16 GMT</pubDate></item><item><title><![CDATA[HW3]]></title><description><![CDATA[a: b:
i. True
ii. Falsec:SA 1 B0 AB 10 AεB 1εd:
This language generates a string that contains at least one 1, and if it contains zero, it must occurs before all other ones. Sa Sa S b SεεSa S b Sεεa Sa:b:c:a:
q3q5q1ε,ε$0,ε01,εε0,0εq6ε,$εq20,ε0q41,εε0,0εb:
q3q1ε,ε$ε,εεq6ε,$εq2a,εaq4c,εεε,εεb,aεq8ε,ε$ε,εεq0ε,$εq7a,εεq9c,bεε,εεb,εbq1ε,ε$loopε,εEε,EE+TIt can expandto two nodesε,TTxFε,F(E)ε,ETε,TF(,(ε),)εa,aε+,+εx,xεε,$εq2ε,Faa:
Assume every characters appear p times.
According to pumping lemma rule:If there is a string: Even it in rhe language , but It cannot be divided to five strings:
Since cannot be equal or longer than p, so for , it cannot contains a and b or c and d at same time, because between a and b, there are p number of c, same as c and d
Because we cannot contain a and b or c and d in , and can't be null, when we repeat the v and y, the new string we got will no longer be in language , since there are not equal number of a and b or c and d
By proof by contradiction, this language is not a context free language.b:
Assume string like this:
, this string is in this language, but it cannot be divided in to five strings:
Accourding to pumping lamma:Since cannot be equal or longer than p, so for , it cannot contains both a and c at same time, because between a and c, there are p number of b.
As the result
If contains a and b, the new string won't in the language if and repeat 0 time, since p-1 &lt; p.
If contains b and c, the new string also won't in the language if and repeat more than one time: since number of c will greater than the number of a.
If contains only a or b, the new string still won't in the language if and repeats 0 times just like first conditions - this causes By proof by contradiction, this language is not a context free language.Assume and is both CFL.
Because CFL is has property of clousure under union, so is also CFL. So if CFL is closed under complementation, should also be a CFL.
Accourding to DeMorgan's law, Because we already assume CFL is closed under complementation, both and is CFL. However, CFL is not closed under intersection. Which means Left side of the equation is CFL, but right side of the equation is not CFL. This caused contradiction.
As the result, the CFL is not closed under intersection.Assume there is a regular language and another LanguageSince is a regular language (Can draw a DFA which have have four state, for checking a, b, c), If it union with the language , we will get a new language
However, this language is proved to be not a CFL in question 7 b.
Accourding to the closure property of intersection of a CFL and a regular language is still a CFL, we should get a CFL if the language is a CFL. However, we get a non CFL result, which lead to contradiction, this means is not a CFL language.]]></description><link>cs3100/hw/hw3/hw3.html</link><guid isPermaLink="false">CS3100/HW/HW3/HW3.md</guid><pubDate>Wed, 19 Feb 2025 22:10:28 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250219143241]]></title><description><![CDATA[<img src="cs3100/turing-machine/attachments/pasted-image-20250219143241.png" target="_self">]]></description><link>cs3100/turing-machine/attachments/pasted-image-20250219143241.html</link><guid isPermaLink="false">CS3100/Turing Machine/attachments/Pasted image 20250219143241.png</guid><pubDate>Wed, 19 Feb 2025 21:32:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ER Diagram]]></title><description><![CDATA[UsersIDDepartmentsDOBNameTimeGradeContentAssignmentOfferOfferStart TimeTeachStudentProfessorFirst NameLast NameAdminSubjectNameNumberCourseM1LocationSemesterClassEnd TimeM1EnrollM1MMWorkMajorM11MAssignmentCategoryNameDue DateMax PointContentNameGrade WeightBelong1MBelongM1SumbitMMScoreis-a]]></description><link>cs5530/hw/project/phase-1/er-diagram.html</link><guid isPermaLink="false">CS5530/HW/Project/Phase 1/ER Diagram.md</guid><pubDate>Sun, 16 Feb 2025 23:39:40 GMT</pubDate></item><item><title><![CDATA[SQL Command]]></title><description><![CDATA[Departments:CREATE TABLE Departments ( Name varchar(100) NOT NULL, Subject varchar(4) NOT NULL, PRIMARY KEY(Subject)
);
Students:CREATE TABLE Students ( uID char(8) NOT NULL, FirstName varchar(100) NOT NULL, LastName varchar(100) NOT NULL, DOB date NOT NULL, Major varchar(4) NOT NULL, PRIMARY KEY(uID) FOREIGN KEY(Major) REFERENCES Departments(Subject) ON DELETE SET NULL
);
Professors:CREATE TABLE Professors ( uID char(8) NOT NULL, FirstName varchar(100) NOT NULL, LastName varchar(100) NOT NULL, DOB date NOT NULL, WorkAt varchar(4) NOT NULL, PRIMARY KEY(uID) FOREIGN KEY(WorkAt) REFERENCES Departments(Subject) ON DELETE SET NULL
);
Administrators:CREATE TABLE Administrators ( uID char(8) NOT NULL, FirstName varchar(100) NOT NULL, LastName varchar(100) NOT NULL, DOB date NOT NULL, PRIMARY KEY(uID)
);
Courses:CREATE TABLE Courses ( Name varchar(100) NOT NULL, Number unsigned small int NOT NULL, LastName varchar(100) NOT NULL, Subject varchar(4) NOT NULL, CourseID unsigned int NOT NULL AUTO_INCREMENT, PRIMARY KEY(Number, Subject); FOREIGN KEY(Subject) REFERENCES Departments(Subject) ON DELETE SET NULL
);
Classes:CREATE TABLE Classes ( Y Semester ENUM('Spring', 'Fall', 'Summer') NOT NULL, Number unsigned small int NOT NULL, LastName varchar(100) NOT NULL, Subject varchar(4) NOT NULL, PRIMARY KEY(Number, Subject); FOREIGN KEY(Subject) REFERENCES Departments(Subject) ON DELETE SET NULL
);
Enrollment:CREATE TABLE Enrollment ( uID char(8) NOT NULL, FirstName varchar(100) NOT NULL, LastName varchar(100) NOT NULL, DOB date NOT NULL, PRIMARY KEY(uID)
);
]]></description><link>cs5530/hw/project/phase2/sql-command.html</link><guid isPermaLink="false">CS5530/HW/Project/Phase2/SQL Command.md</guid><pubDate>Sun, 16 Feb 2025 23:24:16 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250212142741]]></title><description><![CDATA[<img src="cs3100/turing-machine/attachments/pasted-image-20250212142741.png" target="_self">]]></description><link>cs3100/turing-machine/attachments/pasted-image-20250212142741.html</link><guid isPermaLink="false">CS3100/Turing Machine/attachments/Pasted image 20250212142741.png</guid><pubDate>Wed, 12 Feb 2025 21:27:41 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250212141933]]></title><description><![CDATA[<img src="cs3100/turing-machine/attachments/pasted-image-20250212141933.png" target="_self">]]></description><link>cs3100/turing-machine/attachments/pasted-image-20250212141933.html</link><guid isPermaLink="false">CS3100/Turing Machine/attachments/Pasted image 20250212141933.png</guid><pubDate>Wed, 12 Feb 2025 21:19:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[汇编语言]]></title><description><![CDATA[输入/输出都会被编码成指令:
Registers
Immediates
Memory
subl %eax, %ebx // %ebx = %ebx - %eax
subl %16, %rsp // %rsp = %rsp - 16
对于x86-64, 有两种不同的格式, AT&amp;T和因特尔. 前者是source在destination前面, 后者是反过来的, 由于gcc使用的是AT&amp;T语法, 所以这里也用同样的格式上面可以看到有subl, 这个l表示的是我们操作的内容大小:movx source, dest
我们通过R[%xxx]表示访问某个寄存器的值, M[xxx]表示访问这个地址里存的数值寄存器还可以保存地址, 如果要访问寄存器存储的地址的值, 需要加上括号Example Meaning
(%eax) M[R[%eax]] 获取eax寄存器存的地址,获取这个地址指向的值
8(%rsp) M[8 + R[%rsp]] (%eax, %ecx) M[R[%eax] + R[%ecx]]
(%eax, %ecx, 4) M[R[%eax] + R[%ecx] * 4] 获取ecx的值并*4, 偏移eax的指针,最后获取值
(, %ecx, 4) M[R[%ecx] * 4]
*0x8(, %ecx, 8) M[0x8 + R[%ecx] * 8]
可以看到的是, 这些指令比MIPS复杂多了, 这样可以让一条指令干更多的事情.load effact addressleaq (%rbx, %rsp, 4), %rax
//calculate %rbx + %rsp * 4, 把结果放在%rax中 //这条汇编等效于
long f(long a, long b){ return a + (b * 4);
}
//仅仅操作地址,没有读取内容
Flags是最后执行的运算指令的副产物, 他能让我们知道两个数之间哪个更大. 加法和减法都会更新下面的Flags.
需要注意的是, 做加法和减法的时候, 我们是遵循着CS3810里的加法器来运算: 存算的两个寄存器里面存的都是bits, 没有正负区分. 加法就是正常加, 而减法就需要把减数的数取反+1 (比如CF里的-1+1的例子.)
<a data-tooltip-position="top" aria-label="" rel="noopener nofollow" class="external-link is-unresolved" href="" target="_self">https://www.bilibili.com/video/BV1T442197ZY</a>虽然加法减法都能改变Flags, 但如果只想比大小的话, 可以用cmp指令, 它相当于sub指令, 但不会储存结果. 由于sub a, b = b - a, 同样的, cmp a, b 也是在拿b去比较a, 需要反过来看Carry out / borrow of MSB, 比如我们把一个-1+1 1111
+0001
------
10000
由于最大的bit(MSB)已经超出存储范围了, 所以就存在了CF中
还有把0 -1也会产生同样的结果
计算方式可以是C_in和Carry out bit做xor运算. C_in是3810里学的加法器的最低进位: 如果做减法需要取反+1, 所以C_in就是1. 这个很简单, 如果运算结果是0, 则这个flag就是true如果最高位是个1, 或者说运算结果是个负数, 则这个flag就是true.
这个最高位不包括Carry out bit, 它只包含计算机能显示出来的bit, 如第31位bitsigned overflow flag. 因为在编译器层面, 它不关心到底是不是正数还是负数, 都是一串bit, 所以每次做加法的时候, 有两个flag来记录, 一个是带符号的OF, 一个是不带符号的CFOF是用来判断有符号的情况下的: 如果两个正数相加变成了负数, 或者两个负数相加变成了正数, OF都是1更简单的检查方式是去看carry out bit (最高位进位)和 次高位进位是否相同, 如果不同, 则发生signed over flow, 如下面的-7 - 7 1001 //-7
+1001 //-7 -----
10010 //最高位进位(CF)是1,但次高位进位是0 由于-7的二进制补码是1001, 两个相加得到了10010, 也就是14, 如果两个数是9(Unsigned), 也是一样成立: 就是18. 然而问题是MSB是会被截掉的: 真正得到的值是0010, 也就是2 - 从负数(-14)warpping 回正数(2)了.通过Flag, 就可以看出大于, 小于, 等于的结果: 如果两个数之间的ZF是1, 则就表示他们俩相等.但如果是大于小于就会复杂一些:
Signed Less Than:
如果两个数都是正数, 把a - b, 如果结果小于0(SF是1), 则b &gt; a
如果a和b都是负数或者是不同的正负, SF在这里同样有用
唯一没有用的情况是如果a是一个非常小的数, 接近int_min, 如果a-b的话, 则会发生warpping - 数会变得特别大. 这就需要检测OF
最终得到SF ^ OF可以表示a &lt; b的结果在x86-64中, 运算cmpx指令的时候, 就会执行两个数相减, 然后更新四个flag
在执行完cmp指令后, 可以使用setcc dest来运行某种比较, 然后把结果放到dest中. 这里的cc是一种比较, 如setl是set less than 相似的还有jcc, 比如je- jump equal, js - jump if negative ...<br>
<img alt="Pasted image 20250124023837.png" src="cs4400/attachments/pasted-image-20250124023837.png" target="_self">pushx source
// %rsp -= size(x)
// M[%rsp] = source
popx dest
通常, 操作stack都是这么操作, push是把stack往下压, 然后放入数据, pop是取出数据然后把栈指针加上数据的大小
虽然栈是往下涨的(增加数据要减少), 但我们会说新加的数据是在栈顶
并且, 在调用函数的时候, 会额外分配栈的空间, 而新分配的站的底部(内存的顶部)会存放这个函数的return addressApplication Binary Interface是在编译过程中很重要的东西: 虽然一个程序是很多文件组成, 如多个c文件, 但他们分别编译完后却组成了一个完整的程序. 这就是ABI的功劳.分开编译的文件通过ABI的协议来互相交流, 如内存布局, 函数调用, flags什么的都是它管理传递参数时, 小参数(小于64bit)会进入前六个registers (%rdi, rsi, rdx, rcx, r8d, r9d)
edi和rdi是同一个register, 不过rdi是64bit的, 它的后半32bit包含了edi的内容
如rsp-&gt;64bit, esp-&gt;32bit, sp-&gt;16bit, spl-&gt;8bit返回时会把参数放到%rax / %eax中在调用函数之前, caller (调用函数的函数)会把return address和那些参数(前六个参数以外的) 放到stack中. 这段存储参数的部分时caller stack frame. 其中return address是在caller stack frame的下面, callee stack frame的最上面(栈的最底部)
然后在callee执行运算的时候, 会shift %rsp(stack pointer)来去访问caller stack frame中的参数.
在函数执行完毕准备return的时候, 就会去把自己占用的stack给pop掉, 然后把caller 存储在stack上的return address pop掉并返回但在传参的时候怎么知道调用的函数有没有把edi那些寄存器覆写? 这是因为有协议(3810中学的)
寄存器分为两种:
Preserved registers, 调用者需要存储的寄存器
Temporary register, 是被调用的函数去存储的寄存器
<br><img alt="Pasted image 20250127120214.png" src="cs4400/attachments/pasted-image-20250127120214.png" target="_self">
比如, 下面的代码就有两个参数是Caller saved:int foo(void) { int a = ??; int b = ??; int g = foo(a, b); return g + a + b; }
在汇编中, 可以把它推入栈中, 然后调用完在取出来main: ... movl b, %esi movl a, %edi pushl %edi pushl %esi call foo popl %esi popl %edi ...
或者我们可以把这个偷偷塞到被调用的函数需要去存的寄存器中, 如ebp中. 虽然caller不用存了, 但callee又需要存, 反而更困惑了main: ... movl b, %ebp movl a, %ebx movl %ebp, %esi movl %ebx, %edi call foo addl %ebp, %ebx addl %ebx, %eax
float a = ...; if (a == b) statement1; else if (a == 5) statement2; else statement3; switch(a) { case b: //Error statement1; break; case 5: statement2; break; default: statement3; }
Switch的code一定可以转换成If else, 但不是所有的If Else都能变成switch: 这是因为Switch的条件之恶能是整数, 且不能是变量
然而, If else如果Case变多的话会更消耗资源: 它需要一步一步的向下比较. 而Switch是Constant的执行时间, 是因为它用的是jump table. 这个表格中存储了所有的case的数字, 然后和对应需要转跳到的代码位置.
switch(x) -&gt; goto JUMP_TABLE[x]jmp *.L4(,%rdi,8) //L4地址+rdi*8, 然后转跳这个地址,因为不仅是数据,代码也存在内存中.
.L4: .quad .L3 //每条代码的大小是8byte .quad .L5 //如果rdi=1, 则转跳.L5 .quad .L6 .quad .L7 .L3: movl ... ret .L5: addl ... ret
看起来很合理, 但上面只能是switch case必须是连续的. 如果L3和L4的数字差距很大就歇菜了: 虽然可以在中间塞一些其他指令, 但当数字非常大的时候也是不行. 这时候编译器就不会用jump table而去用其他的东西.
如果case是负数的话, 编译器会把所有数字加一个数字, 把他们都变成正数, 然后再去运行.
并且, 如果输入的数字没有任何switch case对应, 编译器会用一个cmp来检测出来, 然后会跳过switch或者去default case. 或者如果cases是1,3,5,7,9这种的, 编译器也会在中间加上转跳来弥补总的来说, 编译器在case数量很少的时候, 或者case number差距很大的时候, 他会放弃jump table, 转而使用if chain.微架构定义了ISA在晶体管层面上怎么实现的.
常见的微架构是一下操作16byte的内存块. 如下面一个指令moveb (%rbx), %al
这个指令仅仅读取了一个byte然后存入al中.
在CPU中, 他会访问那块内存, 然后直接抓取那里的16byte, 然后选取我们想要的那一个byte, 然后存入al.movl 14, %eax //这里的14不是$14, 也就是说这代表的是个地址而不是imm
这个14由于没有对齐: 14长度是4byte, 也就是从14~18, 但一下读16byte只能是0~15和16~31. 这样就需要读两次. 然后这就又涉及到CS3810的Cache Hit / Miss 了ABI规定, 调用函数之前, 栈的指针必须是16的倍数. 也就是说$rsp必须在0x11 0 的地方(最后一个数字是0结尾.)
比如, 我们调用一个函数, 首先会把8byte的 return address存到栈上, 然后还需要在新的函数中保证$rsp必须是16的倍数
这就是为什么下面的C需要push 24bytevoid foo() { long a = 5; //8byte
long b = 7; //8byte //8byte(unused),为了给swap对齐
swap(&amp;a, &amp;b); }
foo: subq $24,%rsp movq $5, 8(%rsp) movq $7, (%rsp) ... call swap
系统分为Big Endianness和 little Endianness
big Endianness更符合直觉一些, 因为比如要存一个数据0xAABBCCDD, 在地址中显示出来就是:但对于little Endianness, 它是反过来的(单个byte没反, 只不过是byte的顺序反了)对于我们学的x86-64系统来说, 选择的是little endianness.
比如在int i = 0x746162; char* str = (char*)&amp;i; printf("%s", str);
如果我们print出来的话, 由于是little endianness, 所以在内存中存的是:
Piplined 像之前3810说的一样, 流水线可以把一条指令的cycle降至接近1
通常CPU的stage可以从3~30
一个cycle只会开始一个指令 Superscalar 一个Cycle可以同时开启多个指令
大部分时候都是在有管线的情况下才会有Superscalar Out of order 把指令重新排序, 得到更好的性能, 但不会改变行为
大部分时候都是在有Superscalar的情况下才会有 Out of order 考虑下面的代码, 如果一个乘法需要3 cycles, 这三个乘法要几个?int a,b,c; p1 = a * b;
p2 = a * c;
p3 = c * b;
是5个cycle, 因为有管线, 除了第一个乘法要3cycles, 剩下的每个就需要1个额外的cycle如果加上dependency的话:int a,b,c; p1 = a * b;
p2 = a * c;
p3 = p1 * p2;
这样就需要7个cycle: 因为p3需要等p1和p2得到结果后才能乘, 那么就需要3+1+3=7 cycles但有些指令并不可以在下一个cycle再发送一个同样的指令, 这种叫做没有fully piplined:比如上面的除法, 它需要24个cycle才可以运算完, 并且在一个divide后, 需要等6cycles才可以执行下一个除法.for(i = 0; i &lt; length; i++) { product = product * a[i]; }
比如这个代码, 在CPU看来, 就是:imull (%rdi,%rdx), %rax addq $8, %rdx cmpq %r9, %rdx jne .L4 imull (%rdi,%rdx), %rax addq $8, %rdx cmpq %r9, %rdx jne .L4 imull (%rdi,%rdx), %rax addq $8, %rdx cmpq %r9, %rdx jne .L4
由于前两条指令没有依赖, 所以可以同时执行, 第三,四个指令是Cycle2开始执行.
但问题来了, 我们不可以在Cycle3执行第二个乘法指令: 因为一个乘法需要3cycle, 所以我们需要再额外等一个cycle才能执行下一个乘法.
对于上面的代码, 我们的CPE (Cycle per Element)是3, 如果画成图就是这样的:<br>
<img alt="Pasted image 20250210124353.png" src="cs4400/attachments/pasted-image-20250210124353.png" target="_self">这一个cycle虽然少, 但架不住多啊, 所以我们需要优化这个瓶颈:int product1 = 1; int product2 = 1; for(i = 0; i &lt; length - 1; i+=2){ product1 = product1 * a[i]; product2 = product2 * a[i + 1]; }
<br><img alt="Pasted image 20250210124419.png" src="cs4400/attachments/pasted-image-20250210124419.png" target="_self">这样, 我们的CPE就变成了1.5. 我们甚至可以把三个乘法在一个循环中, 这样就可以完全利用所有的空闲.上面的这种操作, 就叫做循环展开, 不过虽然循环变快了, 但需要注意的是, 这种操作可能导致out of bound, 或者要是Array的长度不是展开的倍数, 那么我们需要处理剩下没有运算的数据.我们可以用Superscalar来进一步提升程序性能: 如果两个指令不会互相冲突, 则CPU会把它同时执行.
这种叫做Exploit Instruction-level paralleslism(ILP)
比如:addl $4, $eax
imull $edi,$esi
这两条指令, 操作不同的数据, 而且指令也不一样, 所以OOO和Superscalar会让他们同时执行, 并且顺序不重要.addl $4, %eax
imull %edi, %esi
sall $2, %eax
比如上面的指令, add和imull可以同时执行, 但因为sall需要修改%eax, 但addl也会修改它, 所以addl和sall不能同时执行.
就算我们把imul和sal互换位置, 它仍然会同时执行addl和imul, 因为OOO会发现可以这么优化 - OOO观察一块代码, 来看里面有什么指令可以交换位置来进行优化Superscalar还会优化if, 就像3810中说的Branch predictor一样, 不过如果猜错了, 就需要额外的时间来把之前提前执行的指令撤销]]></description><link>cs4400/汇编语言.html</link><guid isPermaLink="false">CS4400/汇编语言.md</guid><pubDate>Mon, 10 Feb 2025 19:48:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250210124419]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250210124419.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250210124419.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250210124419.png</guid><pubDate>Mon, 10 Feb 2025 19:44:19 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250210124353]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250210124353.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250210124353.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250210124353.png</guid><pubDate>Mon, 10 Feb 2025 19:43:53 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[SQL]]></title><description><![CDATA[P1. 1select Name from Patrons natural join CheckedOut group by CardNum order by count(Name) desc limit 1; select Author from Titles group by Author Having Count(*) &gt; 1; select Author from Titles natural join Inventory group by Author Having Count(Serial) &gt; 1; SELECT Name, COUNT(Serial) AS NumBooks, CASE WHEN COUNT(Serial) &gt; 2 THEN "Platinum" WHEN COUNT(Serial) = 2 THEN "Gold" WHEN COUNT(Serial) = 1 THEN "Silver" ELSE "Bronze" END AS Loyalty FROM Patrons NATURAL LEFT JOIN CheckedOut GROUP BY CardNum;
P2: select Name from Players where ELO &gt;= ...; select distinct Name from Players join Games where Players.pID=Games.WhitePlayer; select distinct Name from Players join Games where Games.result="W" and Games.WhitePlayer=Players.pID; select distinct Players.Name from Players join (select * from Games natural join Events where year(Date)=...) as GAME where WhitePlayer=pID or BlackPlayer=pID; select D.Name, Date from Games natural join Events join (select * from Players where Name = "...") as D where (D.pID=Games.WhitePlayer and Result = "B") or (D.PID=Games.BlackPlayer and Result = "W"); SELECT distinct CASE WHEN pID=WhitePlayer THEN (select Name from Players where Players.pID=BlackPlayer) WHEN pID=BlackPlayer THEN (select Name from Players where Players.pID=WhitePlayer)
END AS Players
FROM Players, Games where Players.Name = "..." and (Players.pID=Games.WhitePlayer or Players.pID=Games.BlackPlayer); --or select BlackPlayer from (select pID from Players where Name = "Carlsen, Magnus") as P join Games where P.pID=WhitePlayer UNION select WhitePlayer from (select pID from Players where Name = "Carlsen, Magnus") as P join Games where P.pID=BlackPlayer; select Name from Players where Name not in (select distinct Players.Name from Players join Games on (Players.pID=Games.WhitePlayer and Games.Result='B') or (Players.pID=Games.BlackPlayer and Games.Result='W')); --or
--第一个查询性能更好, 因为它只计算一遍subquery, 但第二个每个player都要计算一遍subquery select p.Name from Players p where not EXISTS (
select * from Games g where (g.WhitePlayer=p.pID and g.Result="B") or (g.BlackPlayer=p.pID and g.Result="W"));
P3: delete CheckedOut from CheckedOut natural join Patrons where Name='...'; insert into CheckedOut values(
(select CardNum from Patrons where Name = "...1"), (select Serial from Titles natural join Inventory where Title = "...2" and Serial not in (select Serial from CheckedOut) limit 1));
]]></description><link>cs5530/hw/hw5/sql.html</link><guid isPermaLink="false">CS5530/HW/HW5/SQL.md</guid><pubDate>Sun, 09 Feb 2025 22:35:32 GMT</pubDate></item><item><title><![CDATA[HW3Q5Pb]]></title><description><![CDATA[q3q1ε,ε$ε,εεq6ε,$εq2a,εaq4c,εεε,εεb,aεq8ε,ε$ε,εεq0ε,$εq7a,εεq9c,bεε,εεb,εb]]></description><link>cs3100/hw/hw3/hw3q5pb.html</link><guid isPermaLink="false">CS3100/HW/HW3/HW3Q5Pb.md</guid><pubDate>Sat, 08 Feb 2025 03:07:02 GMT</pubDate></item><item><title><![CDATA[HW3Q5Pa]]></title><description><![CDATA[q3q5q1ε,ε$0,ε01,εε0,0εq6ε,$εq20,ε0q41,εε0,0ε]]></description><link>cs3100/hw/hw3/hw3q5pa.html</link><guid isPermaLink="false">CS3100/HW/HW3/HW3Q5Pa.md</guid><pubDate>Sat, 08 Feb 2025 02:38:24 GMT</pubDate></item><item><title><![CDATA[HW3Q2]]></title><description><![CDATA[Sa Sa S b SεεSa S b Sεεa S]]></description><link>cs3100/hw/hw3/hw3q2.html</link><guid isPermaLink="false">CS3100/HW/HW3/HW3Q2.md</guid><pubDate>Sat, 08 Feb 2025 00:51:37 GMT</pubDate></item><item><title><![CDATA[HW3Q1Pc]]></title><description><![CDATA[SA 1 B0 AB 10 AεB 1ε]]></description><link>cs3100/hw/hw3/hw3q1pc.html</link><guid isPermaLink="false">CS3100/HW/HW3/HW3Q1Pc.md</guid><pubDate>Fri, 07 Feb 2025 23:16:34 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250205144526]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250205144526.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250205144526.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250205144526.png</guid><pubDate>Wed, 05 Feb 2025 21:45:26 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250205141829]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250205141829.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250205141829.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250205141829.png</guid><pubDate>Wed, 05 Feb 2025 21:18:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250205140724]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250205140724.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250205140724.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250205140724.png</guid><pubDate>Wed, 05 Feb 2025 21:07:24 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250205140713]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250205140713.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250205140713.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250205140713.png</guid><pubDate>Wed, 05 Feb 2025 21:07:13 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250205133510]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250205133510.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250205133510.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250205133510.png</guid><pubDate>Wed, 05 Feb 2025 20:35:10 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[PDA Ex]]></title><description><![CDATA[q2q3q1ε,ε$0,ε01,0ε1,0εq4ε,$ε]]></description><link>cs3100/automata/attachments/pda-ex.html</link><guid isPermaLink="false">CS3100/Automata/attachments/PDA Ex.md</guid><pubDate>Mon, 03 Feb 2025 22:01:38 GMT</pubDate></item><item><title><![CDATA[NFA2DFA 1]]></title><description><![CDATA[q1q2q30,ε11q1q2q1q2q31x0NFADFAq20101]]></description><link>cs3100/automata/attachments/nfa2dfa-1.html</link><guid isPermaLink="false">CS3100/Automata/attachments/NFA2DFA 1.md</guid><pubDate>Mon, 03 Feb 2025 21:56:34 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250203144505]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250203144505.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250203144505.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250203144505.png</guid><pubDate>Mon, 03 Feb 2025 21:45:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250203143205]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250203143205.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250203143205.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250203143205.png</guid><pubDate>Mon, 03 Feb 2025 21:32:05 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250203134742]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250203134742.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250203134742.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250203134742.png</guid><pubDate>Mon, 03 Feb 2025 20:47:42 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250203134729]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250203134729.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250203134729.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250203134729.png</guid><pubDate>Mon, 03 Feb 2025 20:47:29 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[HW4]]></title><description><![CDATA[ 1:
2:
3:
4:
1:
2:3:4:5:6: 7:1:This query is searching for name of students who enrolled at least one course and doesn't have grade in C.2:This query is searching for name of students who have the same Date of Birth with Maria (Not include Maria).3:This query is searching for name of Courses which are enrolled by every students.4:5:]]></description><link>cs5530/hw/hw4/hw4.html</link><guid isPermaLink="false">CS5530/HW/HW4/HW4.md</guid><pubDate>Sun, 02 Feb 2025 21:42:39 GMT</pubDate></item><item><title><![CDATA[HW2]]></title><description><![CDATA[q1q0MIf M has a DFA, then we can construct a machine that first recognizing language A (which is M). Then we can change all states except original accept state in to accept state. Like in the graph, M state is the accept state, we change it in to normal state and make q1 and q2 in to accept state.Since this is a DFA, it will contains all the possibilitys of the string, and by changing the state, all the strings that will be accept by M, will not be accept by new machine, vise versa. Which we got a new machine that equals the complement of MEach answer's first two strings will be accepted by Regex, and last two strings will not.
a:abab
ababab a
b
b:ab
b bb
aa
c:a
ba ε
b
HW2P4⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'q1 q2 0 q3 1 q4 0 ε ε 1 q5 q1 q2 a,b q3 a q4 b ε ε Figure 1
HW2P5_1⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'q1 a q2 b a b q1 a q2 b a b To special form q0 ε q3 ε Delete q1 q2 bb*a∪a q0 b*a q3 ε Delete q2 q0 ba(bba∪a)* q3 Figure 2
HW2P5_2⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'a:
Proof By Contradiction:
If this language is regular, then there always exist a string which:
Then accourding pumping lemma, we need to split it in to three parts
Due to rule 2 and 3, |xy|&lt;=p, then ywill be one or more 0.
Then the string xyz will also satisfy this: But if y repeat more than one times, the first part of new string will have more zero than second part of string.
By proof by contradiction, A is not a regular language.b:
Proof By Contradiction:
If this language is regular, then will exist a string which:
Due to rule 2 and 3, |xy|&lt;=p, then ywill be one or more 1.
Then the string xyz will also satisfy this: But if y does not exist in the string (i=0), the first part of new string will have fewer one than second part of string.
By proof by contradiction, B is not a regular language.a:
HW2P7b:
Proof By Contradiction:
If this language is regular, then will exist a string which:
Due to rule 2 and 3, |xy|&lt;=p, then ywill be one or more b.
Then the string xyz will also satisfy this: But if y repeat more time than before, then there will be more b than c, which dose not in language C.
By proof by contradiction, C is not a regular language.c:
Because the regular language has Closure properties under operation like intersect. If A and B is both regular language, C will also be a regular language, since C = A ∩ B.
However, C is not a regular language, since B is regular language, so A must not be a regular language.d:
For language A, we set p to 2Then, due to rule 2 and 3: |xy|&lt;=p, and y can't be empty, there are two condition:
x=ε, y=a and x=a, y=a In both condition, z will contains both b and c. No matter how many times y repeat, the string will always in the language A. Even y repeat zero time, or there is only one a, the string still in the language, since we didn't modity bc part, then their number will always equal.]]></description><link>cs3100/hw/hw2/hw2.html</link><guid isPermaLink="false">CS3100/HW/HW2/HW2.md</guid><pubDate>Sun, 02 Feb 2025 18:26:39 GMT</pubDate></item><item><title><![CDATA[HW2P1]]></title><description><![CDATA[q1q0M]]></description><link>cs3100/hw/hw2/hw2p1.html</link><guid isPermaLink="false">CS3100/HW/HW2/HW2P1.md</guid><pubDate>Sun, 02 Feb 2025 18:24:25 GMT</pubDate></item><item><title><![CDATA[ER Model]]></title><description><![CDATA[Entities Relationships model是<a data-tooltip-position="top" aria-label="CS5530/Intro > ^d9fd26" data-href="CS5530/Intro#^d9fd26" href="cs5530/intro.html#^d9fd26" class="internal-link" target="_self" rel="noopener nofollow">设计数据库</a>的第二个阶段. 这个阶段不会去关心表格是如何规划的, 我们需要先设计出ER Model, 然后再把它转换成表格一个Entity就是一个物体, 如{u0123456, Danny, 6-27-1983}, 一个Entity就是由一组属性组成的.
而Set Entity就是对于一种实体的集合, 如所有的学生, 所有的汽车 ... 关系就是用来表示两个或多个实体之间的关系:
Danny works in School of Computing
上面的Danny 和 SoC是两个不同的实体, 中间用工作(关系)链接所以, 就可以说是Works in是对于Employees和Departments之间的一种关系. 员工有很多, 部门也有很多, 就可以用Works in来表示哪个员工在哪个部门工作
可想而知, 一个实体可以用同种关系对应多个实体, 如一个员工在多个部门工作, 或者一个部门有很多不同的员工并且, Relationship Attribute可以让信息变得更多:
Danny works in SoC since 2010
这里自从2010表示的就是Relationship Attribute. 这个属性不归属于任何实体, 而是归属于RelationshipER Model的好处就像是UML, 我们可以用表格或者文字来准确的描绘数据库设计. 就像UML表格一样, 这个也是有独特的语法和规则的 SSNNamePayEmployeesdIDdNameBudgetDepartmentWorks InSince=entity set=attributeunderline=part of the key=relationship set it doesn't need a keyManageManagersubordinateM1就如同上面的例子, 一个Relation(菱形)通常是没有key的, 也不应该有key, 因为它是用来连接两个Entity的. 并且, 两个Entity不必不同, 比如员工之间可以互相管理. 并且最好把这种线给加上额外的备注 - 比如谁被谁管理. 在表格中, 还可以表示出额外的信息, 如员工可不可以在多个部门工作? 一个部门可不可以有多个员工? 这叫做Cardinality of the relationship............Many To ManyOne To Many......One to One需要注意的是, 这里的点不比都需要有Relationship关联, 并且, 两边是可以互换的, 如左边可以是Employee, 也可以把Employee换到右边去. 这就是为什么没有Many to one relationship在上面的表格中, 员工和部门的关系就是One to many的关系, 有一点很困惑的是, 虽然M在员工那边, 1在部门那边, 实际上是一个部门可以有多个员工, 而不是员工可以去多个部门并且, 还可以在表格中表示: 每个员工必须至少去一个部门, 但部门不一定有员工, 就可以在关系上多加一条线(比如图中的那个紫线) 如果想表达OOP那种继承关系也可以, 如:class Employee{int SSN; String name;}
class HourlyEmployee extends Employee{float wage;}
class SalaryEmployee extends Employee{float salary; Benefits b;}
这里, 就可以说HourlyEmployee is a EmployeeSSNNameEmployeesHourlyEmployeeWageSalariedEmployeeBenefitsSalary=IS-A但问题就来了: 给一个数据, 我们怎么知道应该把它归类于某个实体的属性, 还是把这个数据变成一个实体?有些数据比如学生和学生ID是很好分辨的: 学生ID肯定是学生实体的属性. 但要是无法分辨的呢?
比如居民数据: 有居民的名字和他们住在哪. 我们可以只创建一个居民实体, 然后让他有名字和居住地, 也可以弄一个居民实体和一个住址实体, 然后让两个实体进行关联对于这种情况, 可以用下面几点进行判断
这个数据有没有复杂到可以找到key?
其他的实体可不可以拥有多个这个数据? 如员工可不可以有多个住址?
这个数据可不可以跟多种实体进行关联?
如果上面的某条或者多条是yes, 则通常都会把这个数据定义为实体.
比如上面的住址, 如果我们把两个信息分别作为两个实体, 那么我们还可以添加Relationship Attribute, 如这个居民从什么时候住的这个地址, 什么时候离开的.我们来让问题变得更复杂一些: 如果一个员工要管理某个或多个部门, 应该怎么做?
可能想到的是, 创建两个Entity: 员工和部门, 中间用manage Relation联系起来. 这样还可以在manage Relationship中添加Relationship Attribute, 比如预算.
但如果要是我们想让这个管理有个固定的预算, 然后每个部门的预算是这个固定预算的平均值呢? 如果还是用上面的方法就会很麻烦 - 如果预算一变, 就得把每个部门的预算都给修改, 明显不切实际. 如果把budget直接移动到员工的属性里也是不行的, 因为不是每个员工都会管理部门.正确答案是创建一个新的实体, 它记录了哪个员工是管理部门的, 然后这个实体里面存放了每个管理的预算
EmployeesDepartmentsIs Manager1ManagerAppointmentManagedBy11MIDBudgetWorks InM1
这样, 每个员工最多可以是一个Manager Appointment, 每个Manager Appointment都记录了这个管理有多少的预算, 并且, 每个管理可以关联多个部门然后, 还可以根据实际情况加上Constraint, 比如这里就说: 每个员工都得有工作, 且不能在多个部门
每个部门都至少有一个员工
至少存在一个Manager Appointment, 且一个员工只能是一个Manager
每个Manager至少管理一个部门, 且每个部门必须有且只有一个管理
在之前, 一直都是binary Relationship, 也就是一个关系只关联两个实体, 而实际上, 一个关系可以关联多个实体提到这个是因为之前的住址问题: 如果一个人搬走了以后又搬了回来, 就会导致问题: 虽然它的start time和end time是不同的, 但是这个是Relation Attribute, 而我们无法用一个关系重复链接两次一样的东西. 对于上面这个问题, 我们可以创建一个新的实体叫Duration, 把start 和end属性给它. 然后用Relation同时连接三个实体: 居民, 地址, 和持续时间. 通过这样, 虽然居民和地址会相同, 但持续时间不会相同Weak Entities就是那些无法仅用自己的属性来定义的实体. 它是用它自己的属性外加别的实体的key来定义的, 也就是说, 这个实体的某个部分是基于其他的实体某些部分来定义的比如, course和class的区别:
Course:
Subject - CS
Number - 5530
Name - DB
Description - ...
上面这种就是Strong Entity, 因为用自己的属性就可以定义
Class:
Semester - Spring 2025
&lt;reference to course&gt; - 如Course ID
而上面这种却不行, 因为对于2025春季, 有很多的课, 而如果要区分课的话, 就需要用Course的属性. 对于这种情况, 在图标中就应该这么画:
ClassSection OfMCourse1cIDSemesterLocationTeacherProfessorsuID1M
对于一个Class, 它必须依赖一种课才能出现, 而一种课能开很多个课堂. 对于这种Supporting Relationship Set, 就用双层菱形表示, 如果一个弱实体引用了其他实体的属性, 则用双层的方形表示
因为Class自己的Semester key无法作为单独的Key, 所以标记为虚线, 意味着这是个Partial Key, 剩下的Key可以通过这个双层菱形知道是来自Course的并且, 一个Weak Entity不必只能依赖一个其他实体的属性, 比如上面就可以看到它还可以依赖Professor这个属性(这里画成蓝色只是表示可以这么干). 如果也依赖Professor这个属性, 那么就可以在同一个学期开同一门课多次, 只要是不同的教授就行. 我们还可以把多个Weak Entity串联起来, 只要有一个Strong Entity在末尾就可以了. 这个关系就是: 一个Weak Entity基于另一个Weak Entity, 这个Weak Entity又基于另外一个Weak Entity, 最后的Weak Entity基于一个Strong Entity对于这种Weak Entity chain, 它的key会越来越复杂, 因为每个weak Entity key都需要包含前一个weak Entity的key. 对于这种情况, 我们就可以为每个entity都加一个id, 这个id代替原来的key:
比如上面的Course肯呢个有Department 和 Num(如CS, 2420), 那么class就需要Key有Department, Num, Semester. 但如果我们把这个部门和课号设成Unique(或者说Candidate Key), 然后给一个新的key叫cID, 这样Class的key就可以少一个了.
甚至, 我们可以进一步: 如果class还有被依赖的weak entity, 那么我们可以再创建个key叫class ID, 这样Class的Key也会减少成一个了当然, 不仅仅是Weak entity chain可以用这种方法简化, 普通的表格也可以: 只需要把原本的Primary Key变成Unique, 然后创建一个id就可以了如果想把一个ER Model 转换成Relation Model, 可以遵循下面的步骤:
每个实体都会变成一个Schema
<br>Relationship Set会根据<a data-tooltip-position="top" aria-label="ER Model > Cardinality" data-href="ER Model#Cardinality" href="cs5530/er-model.html#Cardinality_0" class="internal-link" target="_self" rel="noopener nofollow">Cardinality</a>变成Schema或者合并到别的Schema中
比如, 要把这个表格转换成Schema:
sIDNameDOBStudentcIDNameCoursesEnrollGradeMM
因为有Student和Courses, 就有两个Schema(表格)
下面的PK表示的是Primary Key, NN表示的是Not Null但Enroll怎么表示? 这时候就要看Cardinality了: 这里是Many to Many, 所以我们就需要额外创建一个表格, 因为我们是不可能把这种信息放在其他表格中:
放在学生表格中, 他们每多上一节课, 就需要多加一列, 并且还没办法储存成绩, 如果放在课程的表格中, 每多一个学生, 就需要多加上一列.所以, 就需要创建一个Enroll的表格, 当然最明显的就是Grade属性要放到这个表格中, 然后它还需要信息分别取表示Student和Course, 所以就加上他们俩的key: sID和cID, 标记为Foreign Key - FK由于这是个Many to Many关系, 所以必须需要两个信息才能知道哪个学生上了哪节课, 所以key就是{sID, cID}对于One to Many就变得有些复杂了, 因为它还会根据Constraint和Cardinality的1在哪边来更改Relation最后的结果
SSNNamePayEmployeesdIDdNameBudgetDepartmentWorks InSince=entity set=attributeunderline=part of the key=relationship set it doesn't need a keyManageManagersubordinateM1看上面这张图, 每个员工只能在一个部门工作, 所以我们完全有理由把Works in Relationship和员工合并起来: 因为部门的信息永远只占一列, 不像学生上课能上好几门.所以, 对于One to Many, 通常是合并M那条线链接的Entity和RelationshipEmployee↑Department↑可以看到, 员工表格哪里有NN?, 这是因为这里我们需要用Cardinality来判断是不是必须填写这个数据: 如果每个员工必须去某个部门工作, 则就是Not Null, 但如果Cardinality不是双横线, 则有些员工可能没有在任何部门工作, 也就不一定是Not Null了.<br>
并且, 就算dID是Foreign Key, 他也可以是null的. 你可能会认为把FK设成null会引起<a data-tooltip-position="top" aria-label="Structured data > Referential Integrity" data-href="Structured data#Referential Integrity" href="cs5530/structured-data.html#Referential Integrity" class="internal-link" target="_self" rel="noopener nofollow">引用完整性</a>的问题, 但其实不会, 因为null是个特殊的数值, 它就没有引用, 所以也就不会导致引用出错我们可以把One to One关系当做是One to Many关系, 所以可以把任意一边的Entity和Relationship合并起来但需要注意的一点是, 如果是One to One了, Merge的那边, 需要加上Unique标签, 因为是一对一关系, 所以就不能出现多个重复的数据. 比如上面的员工和部门的图, 如果是一对一关系, 那么一个部门只能有一个员工, 那么员工表格中的dID应该被标记为Unique<br>如果这个关系中有<a data-tooltip-position="top" aria-label="ER Model > Weak Entities" data-href="ER Model#Weak Entities" href="cs5530/er-model.html#Weak_Entities_0" class="internal-link" target="_self" rel="noopener nofollow">Supporting Relationship</a>的话, 我们可以把它看做是One to Many Relationship: 把M那边连接的Entity和Relation合并, 唯一的区别就是在Weak Entity那里加上它依赖的Strong Entity的Key.如果两个实体之间的关系是Double Participation呢? 也就是两边都是双横线: 如每个员工都必须有对应的部门, 并且每个部门都必须有对应的员工在ER Diagram中, 是很容易表达出来的, 但是在Table中就有点困难了 - 因为在Table中, 我们无法强制这种关系, 就跟先有鸡还是先有蛋一样: 如果一开始什么都没有, 那如果我想添加员工的话, 是不可以的, 因为没有部门员工也就违反了规则对于这种问题, 我们干脆就不要管, 而是在软件中规定一下就行.SSNNameEmployeesHourlyEmployeeWageSalariedEmployeeBenefitsSalary=IS-A
像上面这种的关系图, 可以先创建三个Entity表示三种员工(其中一个是父类), 然后我们可以看到, 下面两个子类员工是没有Key的, 因为他们引用的是上面的SSN作为Key, 所以就可以写:两个子类实体的key虽然都是SSN, 但他们都是Foreign key, 引用的Employee实体的SSN感觉上面这种方法有点脱裤子放屁: 因为完全可以把数据放在一起, 为什么还要去用SSN再去查找这个员工的Name呢? 所以就有下面这种方法: 只有两种子类Entity, 而这两种子类里面都包含了父类的Attribute至于为什么要有第一种方法是有原因的:
如果一个实体可能同时变成两种子类, 那么最好用方法一: 因为在方法二中, 同一个SSN在不同的实体中可以对应不同的人名, 但在方法一中却不可以, 这增加了安全性
并且如果基类有其他的Relationship的时候, 也最好用方法一表达出来. s用方法2的前提一般都是基类是个抽象类: 就像这里, 不可能有没有工资的员工.]]></description><link>cs5530/er-model.html</link><guid isPermaLink="false">CS5530/ER Model.md</guid><pubDate>Sun, 02 Feb 2025 06:55:16 GMT</pubDate></item><item><title><![CDATA[HW2P7]]></title><description><![CDATA[q1q2aq3b,εq4cbc,ε]]></description><link>cs3100/hw/hw2/hw2p7.html</link><guid isPermaLink="false">CS3100/HW/HW2/HW2P7.md</guid><pubDate>Fri, 31 Jan 2025 00:10:08 GMT</pubDate></item><item><title><![CDATA[Command Line]]></title><description><![CDATA[这节课会使用SSH远程使用CADE LAB的Linux电脑, 因为没有图形界面, 所以就需要使用命令行来进行操作:
如可以用ls来查看文件ls | wc
上面就是查看ls这个指令输出的行数本质上, Shell就是一个运行在Linux上的程序, 当我们输入一个单词, 如果是这个程序的指令, 就会运行并输出, 但ls不是, 他是一个在电脑上的程序, 他会在bin下找这个程序, 并执行它. 我们可以用which ls 这条指令来找到这个程序的所在位置如果写ls -l
表示的是运行这个lsl程序, 并使用参数l至于为什么计算机知道这个程序在哪, 是因为有个PATH环境变量, 如果没有这个变量, 计算机就不能自己找到程序了.在shell中, 它会自动把空格理解成分割两个参数的字符, 如果用"括起来, 则不会把空格理解成分隔符如果想编译一个c语言写的程序, 可以写gcc file.c
上面这个只是单纯的编译, 我们可以给更多的参数, 来指定编译成什么, 和指定它的名字gcc file.c -o my_program
]]></description><link>cs4400/command-line.html</link><guid isPermaLink="false">CS4400/Command Line.md</guid><pubDate>Wed, 29 Jan 2025 22:53:17 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250129141246]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250129141246.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250129141246.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250129141246.png</guid><pubDate>Wed, 29 Jan 2025 21:12:46 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250129140002]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250129140002.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250129140002.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250129140002.png</guid><pubDate>Wed, 29 Jan 2025 21:00:02 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[HW3 MD]]></title><description><![CDATA[CREATE TABLE Cars ( VIN int unsigned NOT NULL, make varchar(255) NOT NULL, model varchar(255) NOT NULL, year int unsigned NOT NULL, color varchar(255) NOT NULL, PRIMARY KEY(VIN)
);
CREATE TABLE Salespeople ( SSN int unsigned NOT NULL, name varchar(255) NOT NULL, PRIMARY KEY(SSN)
);
CREATE TABLE Selling ( SSN int unsigned NOT NULL, VIN int unsigned NOT NULL, PRIMARY KEY(SSN, VIN), FOREIGN KEY(SSN) REFERENCES Salespeople(SSN), FOREIGN KEY(VIN) REFERENCES Cars(VIN)
);
INSERT INTO Cars VALUES(0, 'Toyota', 'Tacoma', 2008, 'Red');
INSERT INTO Cars VALUES(1, 'Toyota', 'Tacoma', 1999, 'Green');
INSERT INTO Cars VALUES(2, 'Tesla', 'Model 3', 2018, 'White');
INSERT INTO Cars VALUES(3, 'Subaru', 'WRX', 2016, 'Blue');
INSERT INTO Cars VALUES(4, 'Ford', 'F150', 2006, 'Red');
INSERT INTO Salespeople VALUES(001, 'Arnold');
INSERT INTO Salespeople VALUES(002, 'Jessica');
INSERT INTO Salespeople VALUES(003, 'Steve');
INSERT INTO Selling VALUES(001, 0);
INSERT INTO Selling VALUES(001, 1);
INSERT INTO Selling VALUES(002, 0);
INSERT INTO Selling VALUES(002, 4);
INSERT INTO Selling VALUES(003, 2);
#3.1 select Title from Titles where Author="..."; #3.2 select Serial from Titles natural join Inventory where Author="...";
#3.3 select Title from Titles natural join Inventory natural join CheckedOut natural join Patrons where Name="Joe";
#3.4 select Phone from Titles natural join Inventory natural join CheckedOut natural join Phones where Title="...";
#4.1 select Title from Inventory natural join Titles order by Serial limit ...;
#4.2 select Name from CheckedOut natural join Patrons order by Serial desc limit 1;
#4.3 select Title from Titles where Author&gt;='K' and Author&lt;'L';
#4.4 select distinct ISBN, Title from Titles natural join Inventory;
#5.1 insert into Patrons(Name) values("Mia");
#5.2 delete from Phones where Phone="555-5555";
#5.3 delete from CheckedOut;
delete from Phones;
delete from Inventory;
delete from Titles;
delete from Patrons;
#5.4 alter table Titles drop primary key;
#5.5
alter table Inventory add foreign key (ISBN) references Titles(ISBN);
]]></description><link>cs5530/hw/hw3/hw3-md.html</link><guid isPermaLink="false">CS5530/HW/HW3/HW3 MD.md</guid><pubDate>Tue, 28 Jan 2025 22:54:04 GMT</pubDate></item><item><title><![CDATA[Relational Algebra]]></title><description><![CDATA[之前我们说过, SQL是一个<a data-href="Query Language" href="cs5530/query-language.html" class="internal-link" target="_self" rel="noopener nofollow">Query Language</a>, 然而还有另外一种语言也可以让我们去查询数据库: Relational Algebra首先, 我们可以知道, 任何一个编程语言, 都可以实现一些计算问题, 但在课上学算法的时候, 我们很可能学的是伪代码://merge function
func merge(left, right){ result = empty list; while left not empty and right not empty: if first(left) &lt;= first(right) ...
}
通过伪代码, 可以不写出代码来讲解算法是如何工作的这个就是我们的关系代数中的代数: 我们会用某些特定的符号去表示运算, 就算运算变得复杂也不会很难看.
当然这种语言程序肯定读不懂, 他是让我们更好理解我们想写什么, 然后更容易变成SQL语言. Relational Algebra可以说是一种Imperative, 我们会描述我们要干什么
除此之外还有一个叫Relational Calculus, 它是Declarative, 我们只需要说我们想要什么, 然后语言自己回去想怎么实现 (听着很牛逼, 其实就是SQL: select * from table1)这个关系代数, 听着就跟"关系"(Table)有关. 实际上, 它的domain就是relational instances. 这个Domain(域), 就是跟代数里的一样, 实数域, 整数域... 一共有5个基本的操作符:
操作关系有闭包性质, 也就是说进去出来的永远只有关系:
select Title, Serial From Titles Join Inventory
关系代数有一点和SQL不同的是它的返回: SQL返回的每行可能会重复, 一方面是产生的数据可能我们都想看到, 还有就是删除重复的数据也需要算力.
但对于关系代数不太一样: 它是对于Relation(表格)进行操作的, 而一个正常的表格(对于SQL来说), 是不能有重复的行的. 并未它只是一个伪代码, 所以不用关心算力的问题select * From Patrons where CardNum &gt; 3
如果有多个同样的列名的话, 也需要指定到底是哪个列名Union
这个比较简单直接, 就是单纯把两组数据合并成一组. 不过有一些要求: 他们需要有同样的列数, 并且两组数据每列的类型都要相等. 在这里, 我们需要的是每列有相等的列明, 也就是表1的列名是{a,b}, 表2的列名也需要是{a,b}合并成一张表后, 重复行会被删除.
把两个表格合并的前后顺序不重要, 因为数据是放到set里的, 没有先后之分.Set Difference
如果Union是加法, 那么这个就是减法了. 如果R1-R2, 就会把所有在R1且也在R2的数据删除掉. 做次操作的前提, 也有和Union同样的要求: 两个表格的列名是相同的 可能会在想: 交集去哪去了? 实际上, 交集是可以用减法去计算出来的: 如果一个数据既存在在A中, 也在B中, 那么我们可以先拿A-B, 得到了一个没有重叠部分的A1, 然后再拿A-A1就可以得到重叠部分了A ∩ B = A - (A - B)这个就是对于Cross product + Select的缩写, 如
上面这么写就是Natural Join, 所以还可以再简化:
我们会用这个字符来重命名表格:
然后下面的公式就可以用带着这个名的新表格来进行运算. 这样能让计算式子更易读一些之前就说过, 如果要Union两个表, 就需要两个表的每列有相同的名字. 这样我们可以也用这个符号来重命名:
现在有一个问题: 如果我们有一个表格, 一列是ID, 一列是数字. 如果我们想找出所有有1且有2数字的ID的话, 那么该怎么办?
我们可以先找出所有有数字1的, 然后再找出所有有数字2的, 然后让他们俩相交就可以
还有一种方法是让这个表格与自己做cross product, 然后得到新的表格, 然后筛选出有1且有2的ID.
然而如果我们要找出同时拥有某10种数字的ID呢? 那么我们就需要重复10遍同样的操作, 这显然很麻烦我们有一种简写就是用Division Operator:/
首先我们需要把我们关心的数字放到一个表格中, 叫做B, 原本表格叫做A
如果我们A/B, 就能得到一个表格, 这个表格会列出所有拥有B中所有数字的ID.
当然, 这个操作也是有要求的: 得到的A/B表格必须是A表格的子集, 并且B表格必须也是A表格的子集如果A表格中还有另外一列数据的话, 得到的结果大概率会不同, 因为Divide的时候, 他会把其他列合并在一起, 每一行当做是一个完整的数据, 并不是靠ID来辨别的: 就像以前是只有ID是key, 现在是ID+x是key. 这个操作虽然很神奇, 但是仍然可以用最基本的五个符号组出来, 毕竟SQL也没有除法操作
我们可以先把A中的ID拿出来, 然后跟B做Cross Product这样会得到所有拥有B中的数字的ID组合, 当然也会包含原本A中没有的组合
然后我们就可以把新得到的表格C减去原本的A表格, 也就是说把所有我们想要的组合删掉.
减完的C表格就是一个记录了所有不合规的ID的表格, 所以, 我们再拿这个表格去减A就可以了
]]></description><link>cs5530/relational-algebra.html</link><guid isPermaLink="false">CS5530/Relational Algebra.md</guid><pubDate>Tue, 28 Jan 2025 05:57:44 GMT</pubDate></item><item><title><![CDATA[HW2P5_2]]></title><description><![CDATA[q1bq2a∪baTo special formq3abq1bq2a∪baq3abq0εq4εεbq2(a∪b)baq3abq0q4εDelete q1(a∪b)∪εba*b((a∪b)ba*b)∪aq3q0q4εDelete q2(a∪b)∪εba*b(((a∪b)ba*b)∪a)*((a∪b)∪ε)∪εq0q4Delete q3]]></description><link>cs3100/hw/hw2/hw2p5_2.html</link><guid isPermaLink="false">CS3100/HW/HW2/HW2P5_2.md</guid><pubDate>Tue, 28 Jan 2025 04:05:09 GMT</pubDate></item><item><title><![CDATA[HW2P5_1]]></title><description><![CDATA[q1aq2babq1aq2babTo special formq0εq3εDelete q1q2bb*a∪aq0b*aq3εDelete q2q0b*a(bb*a∪a)*q3]]></description><link>cs3100/hw/hw2/hw2p5_1.html</link><guid isPermaLink="false">CS3100/HW/HW2/HW2P5_1.md</guid><pubDate>Tue, 28 Jan 2025 03:38:36 GMT</pubDate></item><item><title><![CDATA[HW2P4]]></title><description><![CDATA[q1q20q31q40εε1q5q1q2a,bq3aq4bεε]]></description><link>cs3100/hw/hw2/hw2p4.html</link><guid isPermaLink="false">CS3100/HW/HW2/HW2P4.md</guid><pubDate>Tue, 28 Jan 2025 02:57:25 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250127144651]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250127144651.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250127144651.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250127144651.png</guid><pubDate>Mon, 27 Jan 2025 21:46:51 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[selfLoop]]></title><description><![CDATA[qjyzx]]></description><link>cs3100/automata/attachments/selfloop.html</link><guid isPermaLink="false">CS3100/Automata/attachments/selfLoop.md</guid><pubDate>Mon, 27 Jan 2025 20:49:59 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250127120214]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250127120214.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250127120214.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250127120214.png</guid><pubDate>Mon, 27 Jan 2025 19:02:14 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250124023837]]></title><description><![CDATA[<img src="cs4400/attachments/pasted-image-20250124023837.png" target="_self">]]></description><link>cs4400/attachments/pasted-image-20250124023837.html</link><guid isPermaLink="false">CS4400/attachments/Pasted image 20250124023837.png</guid><pubDate>Fri, 24 Jan 2025 09:38:37 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Part1]]></title><description><![CDATA[D1:CourseClassSectionofSemestercIDM1D2:PersonSSNNameRoomRoomNumberCapacityManagebyDepartmentdIDNameM1MeetingStartingTimeAgendalocatedatAttendMMD3:PlayerNameELOEventNameSiteDateHostM1ResultList ofMoveGameM11MPlayPlayRound NumM1White PlayerBlack Playeris-a]]></description><link>cs5530/hw/hw2/part1.html</link><guid isPermaLink="false">CS5530/HW/HW2/Part1.md</guid><pubDate>Thu, 23 Jan 2025 05:55:16 GMT</pubDate></item><item><title><![CDATA[Phase 1]]></title><description><![CDATA[UsersIDDepartmentsDOBNameTimeGradeContentAssignmentOfferOfferStart TimeTeachStudentProfessorFirst NameLast NameAdminSubjectNameNumberCourseM1LocationSemesterClassEnd TimeM1EnrollM1MMWorkMajorM11MAssignmentCategoryNameDue DateMax PointContentNameGrade WeightBelong1MBelongM1SumbitMMScoreis-a]]></description><link>cs5530/hw/project/phase-1/phase-1.html</link><guid isPermaLink="false">CS5530/HW/Project/Phase 1/Phase 1.md</guid><pubDate>Thu, 23 Jan 2025 05:41:01 GMT</pubDate></item><item><title><![CDATA[Q8]]></title><description><![CDATA[q1q2aabbq5q3a,bbbq4aaq1q3q2q3aabq1q4q1q5bbq2q4q2q5baaaaa:b:q1q2aabbq5q3abbq4aaq0εεbb]]></description><link>cs3100/hw/hw1/q8.html</link><guid isPermaLink="false">CS3100/HW/HW1/Q8.md</guid><pubDate>Thu, 23 Jan 2025 03:22:45 GMT</pubDate></item><item><title><![CDATA[Q7]]></title><description><![CDATA[q0q1εq6εq2q4q31010q50011a:q1q6εq2q4q31010q50011b:εq1εq2q4q31,ε010q5c:εεq0ε]]></description><link>cs3100/hw/hw1/q7.html</link><guid isPermaLink="false">CS3100/HW/HW1/Q7.md</guid><pubDate>Thu, 23 Jan 2025 03:18:59 GMT</pubDate></item><item><title><![CDATA[Q6]]></title><description><![CDATA[q1q2q30q3q11x0,1101]]></description><link>cs3100/hw/hw1/q6.html</link><guid isPermaLink="false">CS3100/HW/HW1/Q6.md</guid><pubDate>Thu, 23 Jan 2025 03:16:10 GMT</pubDate></item><item><title><![CDATA[Q5]]></title><description><![CDATA[a:q1q201q3q410b:q1q201q3c:q1q211q3q410000d:q1q211q3000e:q2q31q411000q101g:q1q211,0q31,0q510,10,10,1]]></description><link>cs3100/hw/hw1/q5.html</link><guid isPermaLink="false">CS3100/HW/HW1/Q5.md</guid><pubDate>Thu, 23 Jan 2025 03:08:55 GMT</pubDate></item><item><title><![CDATA[Q2]]></title><description><![CDATA[q1q2q3q41110,1000a:q1q2q3010q50,1q410101b:c:q1q2q30,10,11q50,1q400,1d:q11q400q5110q21q3001]]></description><link>cs3100/hw/hw1/q2.html</link><guid isPermaLink="false">CS3100/HW/HW1/Q2.md</guid><pubDate>Thu, 23 Jan 2025 02:58:00 GMT</pubDate></item><item><title><![CDATA[HW2]]></title><description><![CDATA[Part1⚠ Switch to EXCALIDRAW VIEW in the MORE OPTIONS menu of this document. ⚠ You can decompress Drawing data with the command palette: 'Decompress current Excalidraw file'. For more info check in plugin settings under 'Saving'D1: Course Class Section of Semester cID M 1 D2: Person SSN Name Room Room Number Capacity Manage by Department dID Name M 1 Meeting Starting
Time Agenda located at Attend M M D3: Player Name ELO Event Name Site Date Host M 1 Result List of Move Game Play M 1 1 M Play Round Num M 1 White Player Black Player is-a D2:Meetings:CREATE TABLE Meetings ( starting_time time NOT NULL, agenda varchar(255) NOT NULL, room_number varchar(32) NOT NULL, PRIMARY KEY(starting_time, room_number), FOREIGN Key(room_number) REFERENCES Rooms(room_number)
);
Persons:CREATE TABLE Persons ( ssn int unsigned NOT NULL, name varchar(255) NOT NULL, PRIMARY KEY(ssn)
);
Attend:CREATE TABLE Attend ( ssn int unsigned NOT NULL, starting_time time NOT NULL, room_number varchar(32) NOT NULL, PRIMARY KEY(ssn, starting_time, room_number), FOREIGN KEY(ssn) REFERENCES Persons(ssn), FOREIGN KEY(starting_time, room_number) REFERENCES Meetings(starting_time, room_number)
);
Rooms:CREATE TABLE Rooms ( room_number varchar(32) NOT NULL, capacity int unsigned NOT NULL, dID int unsigned NOT NULL, PRIMARY KEY(room_number), FOREIGN KEY(dID) REFERENCES Departments(dID)
);
Departments:CREATE TABLE Departments ( dID int unsigned NOT NULL AUTO_INCREMENT, name varchar(255) NOT NULL, PRIMARY KEY(dID)
);
D3:Players:CREATE TABLE Players ( name varchar(255) NOT NULL, elo float NOT NULL, PRIMARY KEY(name)
);
Events:CREATE TABLE Events ( name varchar(255) NOT NULL, site varchar(255) NOT NULL, date date NOT NULL, PRIMARY KEY(name, site, date)
);
Games:CREATE TABLE Games ( round_number int unsigned NOT NULL AUTO_INCREMENT, name varchar(255) NOT NULL, site varchar(255) NOT NULL, date date NOT NULL, player_b varchar(255) NOT NULL, player_w varchar(255) NOT NULL, result char(1) NOT NULL, list_of_moves varchar(1000) NOT NULL, PRIMARY KEY (round_number, name, site, date, player_b, player_w, result, list_of_moves), FOREIGN KEY(name, site, date) REFERENCES Events(name, site, date), FOREIGN KEY(player_b) REFERENCES Players(name), FOREIGN KEY(player_w) REFERENCES Players(name)
);
]]></description><link>cs5530/hw/hw2/hw2.html</link><guid isPermaLink="false">CS5530/HW/HW2/HW2.md</guid><pubDate>Thu, 23 Jan 2025 02:36:00 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250115143937]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250115143937.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250115143937.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250115143937.png</guid><pubDate>Wed, 15 Jan 2025 21:39:37 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[NFA2DFA]]></title><description><![CDATA[q1q2q3011q1q2q1q301x0101NFADFA0q1q2001]]></description><link>cs3100/automata/attachments/nfa2dfa.html</link><guid isPermaLink="false">CS3100/Automata/attachments/NFA2DFA.md</guid><pubDate>Wed, 15 Jan 2025 21:17:07 GMT</pubDate></item><item><title><![CDATA[Q3]]></title><description><![CDATA[q1q3q2q3q2q4q1q410010101]]></description><link>cs3100/hw/hw1/q3.html</link><guid isPermaLink="false">CS3100/HW/HW1/Q3.md</guid><pubDate>Tue, 14 Jan 2025 04:24:00 GMT</pubDate></item><item><title><![CDATA[NFAExample]]></title><description><![CDATA[q1q2q3q10,110,10,1]]></description><link>cs3100/automata/attachments/nfaexample.html</link><guid isPermaLink="false">CS3100/Automata/attachments/NFAExample.md</guid><pubDate>Mon, 13 Jan 2025 21:40:51 GMT</pubDate></item><item><title><![CDATA[NFA]]></title><description><![CDATA[q1q10q1q2q31q1q30no where to goq1q21q3q4q4q1q2q31q4]]></description><link>cs3100/automata/attachments/nfa.html</link><guid isPermaLink="false">CS3100/Automata/attachments/NFA.md</guid><pubDate>Mon, 13 Jan 2025 21:20:37 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250113140920]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250113140920.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250113140920.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250113140920.png</guid><pubDate>Mon, 13 Jan 2025 21:09:20 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Appointment Entity]]></title><description><![CDATA[EmployeesDepartmentsIs Manager1ManagerAppointmentManagedBy11MIDBudgetWorks InM1]]></description><link>cs5530/attachments/appointment-entity.html</link><guid isPermaLink="false">CS5530/attachments/Appointment Entity.md</guid><pubDate>Mon, 13 Jan 2025 05:36:05 GMT</pubDate></item><item><title><![CDATA[ER2RMEx]]></title><description><![CDATA[sIDNameDOBStudentcIDNameCoursesEnrollGradeMM]]></description><link>cs5530/attachments/er2rmex.html</link><guid isPermaLink="false">CS5530/attachments/ER2RMEx.md</guid><pubDate>Sun, 12 Jan 2025 21:34:44 GMT</pubDate></item><item><title><![CDATA[Weak Entity Set]]></title><description><![CDATA[ClassSection OfMCourse1cIDSemesterLocationTeacherProfessorsuID1M]]></description><link>cs5530/attachments/weak-entity-set.html</link><guid isPermaLink="false">CS5530/attachments/Weak Entity Set.md</guid><pubDate>Sun, 12 Jan 2025 21:15:58 GMT</pubDate></item><item><title><![CDATA[IS-A]]></title><description><![CDATA[SSNNameEmployeesHourlyEmployeeWageSalariedEmployeeBenefitsSalary=IS-A]]></description><link>cs5530/attachments/is-a.html</link><guid isPermaLink="false">CS5530/attachments/IS-A.md</guid><pubDate>Sun, 12 Jan 2025 07:13:10 GMT</pubDate></item><item><title><![CDATA[Entity Set]]></title><description><![CDATA[SSNNamePayEmployeesdIDdNameBudgetDepartmentWorks InSince=entity set=attributeunderline=part of the key=relationship set it doesn't need a keyManageManagersubordinateM1]]></description><link>cs5530/attachments/entity-set.html</link><guid isPermaLink="false">CS5530/attachments/Entity Set.md</guid><pubDate>Sun, 12 Jan 2025 07:12:38 GMT</pubDate></item><item><title><![CDATA[Cardinality]]></title><description><![CDATA[............Many To ManyOne To Many......One to One]]></description><link>cs5530/attachments/cardinality.html</link><guid isPermaLink="false">CS5530/attachments/Cardinality.md</guid><pubDate>Sat, 11 Jan 2025 23:37:59 GMT</pubDate></item><item><title><![CDATA[Pasted image 20250108140133]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250108140133.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250108140133.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250108140133.png</guid><pubDate>Wed, 08 Jan 2025 21:01:33 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Pasted image 20250108140021]]></title><description><![CDATA[<img src="cs3100/automata/attachments/pasted-image-20250108140021.png" target="_self">]]></description><link>cs3100/automata/attachments/pasted-image-20250108140021.html</link><guid isPermaLink="false">CS3100/Automata/attachments/Pasted image 20250108140021.png</guid><pubDate>Wed, 08 Jan 2025 21:00:21 GMT</pubDate><enclosure url="." length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;.&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[有限状态机]]></title><description><![CDATA[<img src="cs3100/automata/attachments/有限状态机.png" target="_self">]]></description><link>cs3100/automata/attachments/有限状态机.html</link><guid isPermaLink="false">CS3100/Automata/attachments/有限状态机.png</guid><pubDate>Wed, 08 Jan 2025 20:43:08 GMT</pubDate><enclosure url="cs3100/automata/attachments/有限状态机.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;cs3100/automata/attachments/有限状态机.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Structured data]]></title><description><![CDATA[通常, 信息是储存在这样的表格中的, 并且, 不同的对象是尽可能的用不同的表格表示:
比如借书的数据库, 如果我们让每个人的个人信息是一行, 后面跟上借的书, 则就会导致如果一个人如果借多本书, 就会出现问题, 或者一个人有多个手机号, 也会出现很多的额外数据. 并且无法表示出没借的书.
所以可以这么写:这样, 就算一个人借多本书, 也可以直接在第三个表格中添加, 没借出去的书也会在第二个表格中显示.通过这种方式可以让我们用基础的数据组成更高级更复杂的数据.Students:Attribute: 对于每列的顶部, 都是表示的这列数据的名称和类型(如int, string等), 这里一共有三个attribute.Schema: 所有的Attribute + Relation name(在这里, 这个relation name是Student), 组成了Schema
这里, 我们可以把Schema理解成一个class, 它跟里面存储的数据没有任何关系 - 它只定义了里面存储数据的类型和名字. Instance: 可想而知, 下面的数据就跟编程中的实例一样, 是根据类型规则创建出来的实例. 每行都是一个instance. 也可以说每行都是一个组元 - TupleTable / Relation: Schema + Instance组成了一个表格, 或者说是Relation我们可以创建多个Relation, 如上面的Student表格之外, 还可以创建一个Course表格来记录每节课的数据. 并且, Relation并不必须是定死的数据, 它也可以是临时创建出来的数据 - 我们可以用过滤器把一些一个表格的某些数据筛选出来, 得到一个临时的新的表格.需要注意的是, 每个Instance都必须是不同的, 虽然他们可以有同样的数据 - 如3, 4行都是3.9GPA, 但所有的数据都必须有个不同的sID, 我们也可以把它叫做Key在数据库中, 每个Key只能有一个, 如果某个Key已经存在, 如果想再插入一个相同的Instance进去, 则会拒绝此操作但Key并不是只能使用一列数据, 他也可以用多列数据作为Key: 如汽车的名字可能一样, 但它生产的年份不一样:就如上面的表格, 用户可以把Mode和Year这两列数据一起当作单独的一个Key考虑下面一段代码:Thing* t1 = new Thing();
Thing* t2 = t1;
delete(t1);
cout &lt;&lt; t2-&gt;x;
正常来说, 这个程序可能会崩溃, 或者会打出其他东西, 在数据库中, 我们也同样希望这么做: 比如一个学生表和一个课程表, 如果学生表中的其中一个学生被删掉了, 那么对应课程表的某行或者多行就直接没有意义了, 这叫违反了Referential Integrity, 也就是说每个数据所引用的数据都必须是有意义的, 就算是null也可以.
但我们删掉了学生, 但课表中还存在已经删掉的学生的编号是不能被允许的. 所以我们可以
删掉其他表的对应数据
指向null
不管哪个操作, 如果手动操作都非常容易遗漏, 所以最好的操作就是让DBMS自己去管理. 并且这个管理的过程是原子级的 - 删掉数据后, 其他表格的数据会立刻删除, 中间是无法执行其他指令的这种操作是通过<a data-tooltip-position="top" aria-label="Structured data > Foreign Key" data-href="Structured data#Foreign Key" href="cs5530/structured-data.html#Foreign_Key_0" class="internal-link" target="_self" rel="noopener nofollow">Foreign Key</a>实现的而删掉数据也有一些不同的指令:CASCADE: 删掉它所关联的所有数据
SET NULL: 把与他所有关联的数据的Foreign key都替换成null
RESTRICT: 把这个数据暂时冻结, 无法删除对应的数据.Super Keys: 如果某个 / 多个属性(表格顶部的标题)的每行的值都不一样, 就叫做super key. 比如上面表格的sIDKey: 某个 / 多个属性会组成一个Key如果: 1. 这几个属性组成了一个super key, 2. 这几个属性组成的子集不会组成任何super key(比如三个属性中选两个或者一个组不出super key, 只有三个属性一起才是super key的时候)需要注意的是, 不要掉入寻找"到底哪个是Key"的误区, 因为我们是设计人员, 我们完全是可以创建一个永远不重复的数据作为key, 而不是在现有的数据上选择一个作为key当然, 一个table的key到另一个table的时候就可能不是key了, 比如我们创建了一个sID作为key的student表格, 然后有个新表格, 里面存放每个学生报了什么课, 这时候sID就不能是key了, 因为这样每个学生只能报一个课了. 这种情况, 可以把sID和课号两个属性组成一个新的key
请注意, 这个只是一个key, 如果我们把sID和cID同时作为两个key在选课的table中, 那么每个课只能有一个学生选择, 并且每个学生只能选择一门课并且, key使用的属性可以是重复的, 如sID+cID, sID+GPA, 这样就表示每个学生只能参加每节课一次, 并且每节课的GPA必须不同有如此多的Key, 肯定要表明哪个key是最重要的. 这由数据库管理员规定, 而剩下的所有的Key都是Candidate keyPRIMARY KEY(sID, cID)
UNIQUE(sID, Grade)
第二行表示的就是我们创建一个新的key, 这个key是Candidate key这个指令比想象中的重要, 因为系统会以不同的方式去组织Primary Key, 设置好对应的key, 会带来性能提升<br>Foreign key可以想象成一个指针, 指向了其他表格中存在的当前key(尽管它在那个表格中不是key), 这样就可以方便删除数据, 保持<a data-tooltip-position="top" aria-label="Structured data > Referential Integrity" data-href="Structured data#Referential Integrity" href="cs5530/structured-data.html#Referential_Integrity_0" class="internal-link" target="_self" rel="noopener nofollow">Referential Integrity</a>.比如, 一个学生表中有sID, 在注册课程表中也有sID, 这两个sID就会关联起来, 学生表中的事key, 而注册课程表中的sID是Foreign key并且, Foreign Key也会带来一些限制, 如果我们试图在有Foreign key的表格中加一个Foreign key关联的表中没有的数据, 比如加一个不存在的学生到注册课表里, 系统也会拒绝, 因为打破了数据完整性]]></description><link>cs5530/structured-data.html</link><guid isPermaLink="false">CS5530/Structured data.md</guid><pubDate>Wed, 08 Jan 2025 07:10:36 GMT</pubDate></item><item><title><![CDATA[Intro]]></title><description><![CDATA[在这节课中, 会使用大量的C语言, 来了解如何使用操作系统和了解编译器原理.如果把抽象程度做成一个轴, 则CS3810是最左边, 而2420在最右边. CS4400是夹在中间.]]></description><link>cs4400/intro.html</link><guid isPermaLink="false">CS4400/Intro.md</guid><pubDate>Mon, 06 Jan 2025 19:17:34 GMT</pubDate></item><item><title><![CDATA[团队合作]]></title><description><![CDATA[对于设计一个程序, 可以遵循<a data-tooltip-position="top" aria-label="https://ieeexplore.ieee.org/document/720574" data-href="https://ieeexplore.ieee.org/document/720574" href="https://ieeexplore.ieee.org/document/720574" class="internal-link is-unresolved" target="_self" rel="noopener nofollow">IEEE-830</a>规则
Pro 在开发阶段就可以对程序有具体概念
具体开发计划
易于管理 Con 难以修改
得写文章
测试阶段很晚 Agile（敏捷）是一种项目管理方法论，特别适合在快速变化、需求不断演变的环境中进行产品设计和开发。与传统的 Waterfall（瀑布式）方法不同，Agile 方法更强调适应性、协作、客户参与和持续改进UML（Unified Modeling Language，统一建模语言）标准的发展是指对UML作为一种建模语言的持续改进和规范化的过程。UML是用来帮助软件开发人员、系统架构师和工程师进行可视化、设计和文档化复杂系统的一种图形化语言。下面就是一个对于一个Employee 类的UML表格:可以看到每个元素前面有符号, 不同的符号有不同的作用
A class is a rectangle divided into three parts Class name
Class attributes (i.e. data members, variables)
Class operations (i.e. methods) Modifiers Private: -&nbsp; Public: +
Protected:&nbsp; #
Static: Underlined&nbsp; (i.e. shared among all members of the class)
Types&nbsp; : Type 并且, Class之间可以用箭头表示关系, 比如student 和 course的关系, 他们互相独立, 一个消失另一个不会, 这种弱拥有关系就用空心菱形表示, 而强拥有(如学生和成绩), 则是实心菱形箭头表示(学生指向GPA).]]></description><link>cs3505/团队合作.html</link><guid isPermaLink="false">CS3505/团队合作.md</guid><pubDate>Tue, 29 Oct 2024 22:21:37 GMT</pubDate></item><item><title><![CDATA[Enum]]></title><description><![CDATA[当一个东西有多个形态, 可以用枚举enum Color {red, greed, blue}; Color r = red;
bool isRed(Color c){ return c == red;
}
当然, 如果觉得上方的red不直观, 还可以把这个枚举加入class scope, 然后就可以用Color::red来表示这个红色是颜色类的.enum class Color {red, greed, blue}; Color r = red;
bool isRed(Color c){ return c == Color::red;
}
]]></description><link>cs3505/enum.html</link><guid isPermaLink="false">CS3505/Enum.md</guid><pubDate>Thu, 24 Oct 2024 18:46:43 GMT</pubDate></item><item><title><![CDATA[Code Style]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="https://www.runoob.com/design-pattern/facade-pattern.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.runoob.com/design-pattern/facade-pattern.html" target="_self">在软件设计中，<strong></strong>（外观模式）**&nbsp;是一种结构型设计模式。它提供了一个统一的接口，用于访问子系统中的一组接口，从而隐藏系统的复杂性。通过外观模式，客户端可以更简单地与复杂系统交互，而不需要了解系统内部的细节</a>Facade**<a data-tooltip-position="top" aria-label="https://blog.csdn.net/weixin_45433817/article/details/131214686" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.csdn.net/weixin_45433817/article/details/131214686" target="_self">1</a>。主要特点
简化接口：外观模式为复杂的子系统提供了一个简单的接口，使得客户端可以更方便地使用系统功能。
降低耦合：客户端与子系统之间的依赖减少，客户端只需要与外观类交互。
提高灵活性：子系统的内部变化不会影响客户端，因为外观类封装了这些变化。
使用场景
当你需要为一个复杂的子系统提供一个简单的接口时。
当你希望减少客户端与多个子系统之间的直接交互时。
当你希望隐藏子系统的复杂性并提供一个更易用的接口时。
Code Smell 代表的是一些让代码更不可读的行为, 虽然代码能正常运行, 但会变得更不可维护一些常见的代码异味包括：
重复代码：相同的代码片段出现在多个地方。
过长的方法：方法包含过多的代码，难以理解和维护。
过大的类：类承担了太多的责任，违反了单一职责原则。
长参数列表：方法的参数列表过长，难以使用和理解。
<br><a data-tooltip-position="top" aria-label="https://blog.csdn.net/handsomeway/article/details/105719322" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.csdn.net/handsomeway/article/details/105719322" target="_self"><strong></strong>：一个类需要频繁地因不同的原因进行修改</a>发散式修改<a data-tooltip-position="top" aria-label="https://blog.csdn.net/handsomeway/article/details/105719322" rel="noopener nofollow" class="external-link is-unresolved" href="https://blog.csdn.net/handsomeway/article/details/105719322" target="_self">1</a><a data-tooltip-position="top" aria-label="https://www.cnblogs.com/xinyuxin912/archive/2012/07/09/2582249.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.cnblogs.com/xinyuxin912/archive/2012/07/09/2582249.html" target="_self">2</a>.
考虑下面这段代码:for(int i = 0; i &lt; 10,000; i++){ cout&lt;&lt;i&lt;&lt;endl;
}
乍一看, 似乎会print 0~9999, 但实际上一次都不会print, 因为10,000中间的逗号是个comma operator, 会形成一个表达式, 然后最终的结果是0.]]></description><link>cs3505/code-style.html</link><guid isPermaLink="false">CS3505/Code Style.md</guid><pubDate>Thu, 24 Oct 2024 18:37:00 GMT</pubDate></item><item><title><![CDATA[Qt]]></title><description><![CDATA[用Qt可以像maui那样开发软件在Qt的main.cpp代码中, 最后的return a.exec()是一个无限循环来监听用户操作, 直到关闭窗口在Qt中, 有很多很基础很重要的概念:在Qt中新建cpp文件的时候, 它会问这个类的base class是什么, 其中常用的有: QObject 是 Qt 中的最基础类，几乎所有 Qt 对象类都间接或直接继承自 QObject。它提供了许多核心功能：
<a data-tooltip-position="top" aria-label="Qt > Slot &amp; Signal" data-href="Qt#Slot &amp; Signal" href="cs3505/qt.html#Slot_&amp;_Signal_0" class="internal-link" target="_self" rel="noopener nofollow">Slot &amp; Signal</a>机制：允许对象之间进行异步通信。
内存管理：通过父子关系，QObject 会自动管理对象的生命周期，防止内存泄漏。创建一个 QObject 对象时，如果指定了父对象，当父对象被销毁时，所有子对象也会被自动销毁。
事件处理：QObject 提供了事件系统，允许你处理和过滤事件。
元对象系统：支持动态属性、信号与槽的连接以及反射等功能。
适用场景：QObject 通常用于没有用户界面的非可视对象，如数据管理类、控制类、后台处理类、网络类等。class MyClass : public QObject { Q_OBJECT
public: MyClass(QObject* parent = nullptr) : QObject(parent) {}
public: slots: signals:
};
QWidget 是所有可视化窗口部件的基类，它继承自 QObject，并提供了额外的 GUI 功能。QWidget 是 Qt 中所有界面元素（窗口、按钮、标签等）的基类。
窗口控件：QWidget 是所有窗口和控件（如 QPushButton, QLabel, QLineEdit 等）的基类。它提供了绘制功能、鼠标和键盘事件处理、窗口布局管理等。
布局管理：允许你在窗口中嵌套控件并自动管理控件的位置和大小。
事件处理：可以响应用户输入事件，如鼠标点击、键盘输入等。
适用场景：如果你创建的是带有界面的类，通常会选择 QWidget 作为基类，例如窗口、按钮、文本框等。class MyWidget : public QWidget { Q_OBJECT
public: MyWidget(QWidget* parent = nullptr) : QWidget(parent) {}
};
QMainWindow 是 QWidget 的子类，它提供了标准的主窗口结构，通常用于复杂的应用程序界面。QMainWindow 提供了一些额外的特性，适合构建有多个区域的主窗口应用程序。
菜单栏（Menu Bar）：主窗口通常会有一个标准的菜单栏，你可以通过 QMainWindow::menuBar() 轻松添加菜单。
工具栏（Tool Bar）：可以通过 addToolBar() 添加工具栏。
状态栏（Status Bar）：提供了一个默认的状态栏，通过 statusBar() 可以在主窗口底部显示状态信息。
中心区域：QMainWindow 提供了 setCentralWidget() 函数，可以设置一个中心的窗口部件（如编辑器、浏览器等），并在四周添加停靠窗口（dock widgets）。
适用场景：QMainWindow 通常用于需要标准主窗口布局的复杂应用程序，例如文本编辑器、IDE、绘图应用等。class MyMainWindow : public QMainWindow { Q_OBJECT
public: MyMainWindow(QWidget* parent = nullptr) : QMainWindow(parent) { setCentralWidget(new QWidget(this)); }
};
当我们创建一个Qt app的时候, 会自带一个窗口, 我们这里叫做view, 这个view也是一个QMainWindow, 它和我们创建的有一些不同, 因为他是一个窗口, 所以是有ui布局的.
这就是为什么在他的头文件中有个private: Ui::view *ui;
这个ui指针会在view.cpp的构造函数中赋值, 在函数中的ui-&gt;setupUi()初始化所有的UI在Qt中，槽(slot) 是用于响应信号的函数。信号和槽机制是Qt框架中最重要的特性之一，主要用于对象之间的通信。这一机制允许在一个对象中发出信号，并在另一个对象中响应这个信号。槽是一个普通的C++函数，但它可以通过Qt的元对象系统与信号连接，从而在信号发出时被调用。槽可以是：
普通的成员函数。
静态函数。
lambda 表达式（Qt 5.10 及以上）。
信号（signal) 和 槽（slot) 的组合使得Qt的组件能够在事件发生时进行通信，而不需要显式地调用或引用彼此。
信号：是由对象发出的事件通知。它告诉其他对象某些事情已经发生。例如，一个按钮可以发出 clicked() 信号，表示用户点击了它。
槽：是响应信号的函数。当信号发出时，槽会被调用，槽可以是任何函数、类的成员函数，甚至是lambda表达式。
通过 connect() 函数，信号可以与槽连接，当信号被触发时，槽就会自动执行。在之前说过, 只要是继承了QObject的类都可以使用槽和信号, 在创建了一个类后, Qt会自动生成一个signal:的部分, 我们可以在下面定义一个信号. 例如, 在model类中我们有个让数据增加的方法, 但增加完数据后我们需要通知所有的UI去更新, 因为数据变动了. 所以, 我们就可以在model.h的signal:部分里写signals: void updateView(int);
接着, 在model的实现当中用emit去发送信号void model::increase(){ this-&gt;data ++; emit updateView(data);
}
在定义槽函数时，需要在类的声明(.h文件)部分使用 slots: 关键字（Qt 5 后可选），如下：class model : public QObject
{ Q_OBJECT
public: explicit model(QObject *parent = nullptr); private: int data; //M架构里的自定义数据 public slots: void increase(); //一个槽, 用来data++ signals: void updateView(int); //一个自己的signal
};
在实现部分，槽函数就像普通的C++成员函数一样实现：void model::increase(){ this-&gt;data ++; emit updateView(data);
}
通过 connect() 函数，将信号和槽连接起来
在Qt5及之后，推荐使用函数指针或函数对象的形式来连接信号和槽：connect(sender, &amp;SenderClass::signal, receiver, &amp;ReceiverClass::slot);
一旦信号发出（例如按钮点击），对应的槽函数会立即执行。例如：view::view(model &amp;m, QWidget *parent) : QMainWindow(parent) , ui(new Ui::view)
{ ui-&gt;setupUi(this); // 将按钮的 clicked() 信号连接到 Model 的槽函数 increase //因为我们额外传进来了一个Model的reference, 所以这块要获取地址来得到model的指针 connect(ui-&gt;pushButton,&amp;QPushButton::clicked, &amp;m, &amp;model::increase); //反过来也一样, 我们把model的updateView的Signal和SpinBox的set Value槽连接起来, 具体是m实例和ui-&gt;spinBox实例(指针) connect(&amp;m, &amp;model::updateView, ui-&gt;spinBox, &amp;QSpinBox::setValue);
} 槽函数可以是任何访问权限：槽可以是 public、protected 或 private 的成员函数，这取决于你希望槽函数的可见性。即使是 private slots:，你仍然可以通过 connect() 将信号连接到这些槽。 自动调用：一旦信号发出，槽函数会自动被调用。这使得信号和槽之间的耦合非常松散，发送信号的对象不需要知道谁在处理这个信号。 参数匹配：信号和槽的参数必须匹配，或者槽的参数可以比信号的参数少，但顺序必须一致。多出来的参数会被忽略。例如： 信号：void clicked(int x, int y)
槽：void mySlot(int x)
（信号的 y 参数将被忽略，槽函数只处理 x） 槽（slot）是一个特殊的函数，它可以与信号（signal）连接，在信号触发时自动调用。
槽函数可以是类的成员函数、lambda表达式、静态函数等。
通过信号和槽机制，可以让对象之间以松耦合的方式通信，不需要直接的函数调用。
]]></description><link>cs3505/qt.html</link><guid isPermaLink="false">CS3505/Qt.md</guid><pubDate>Thu, 17 Oct 2024 21:51:33 GMT</pubDate></item><item><title><![CDATA[MVC架构]]></title><description><![CDATA[在程序中, 可以用MVC - model view control 模型来降低代码的耦合性, 这样可以让我们更好的维护代码. Model就是后端, 后端通过Controller来和前端View来和用户沟通. 用户也可以操作Controller来修改model的数据.比如, 我们想在程序里有个按钮和一个数字, 按一下按钮数字加一. 根据MVC架构, 按钮按下后不应该直接修改数字, 而是修改model里的数值, 然后那个数字显示器再读取这个数值显示出来.]]></description><link>cs3505/mvc架构.html</link><guid isPermaLink="false">CS3505/MVC架构.md</guid><pubDate>Thu, 17 Oct 2024 18:59:32 GMT</pubDate></item><item><title><![CDATA[OOP]]></title><description><![CDATA[每个类实例之间可能有关系: 如猫属于动物, 汽车有引擎…
在C++中也是一样: 我们想继承就用冒号来表示class Cat∶ public Animal {}
就代表猫继承了动物, 但虽然继承了动物的所有方法, 但无法继承动物的构造函数, 因为猫类可能有额外的数据, 我们不想用动物构造函数创建一个半初始化的猫.Cat(int age,int lives):Animal(age),lives(lives){}
当然, C++也有多态功能: 如果我们在heap上创建了一个猫的实例, 但我们使用了一个Animal的pointer指向的猫的地址. 我们期望的是: 这样就会导致虽然这是个猫的实例, 但执行的是动物的方法, 除非我们cast过去的时候才会执行猫的方法. 但在C++中, 你不显式的表示出来, 它会把猫永久降级成动物类, 除非我们在Animal类的方法前面加上virtual关键词, 这样才可以让编译器在编译的时候决定到底调用谁的方法.
包括deconstructor也需要加上这个关键词, 不然所有继承的类都会调用父类的方法.
这个叫做虚函数, 当父类的某个函数是虚函数, 则继承它的子类和子子类对应的这个函数都会变成虚函数, 且不需要写多遍virtual.(可以看下面的更多继承)对象切片就是当我们在创建object的时候不用指针, 而是直接创建, 但把子类对象放进了父类对象里面, 这样就会导致对象切片(丢失了子类对象原有的功能) 我们需要创建的时候使用指针来避免这种问题(就像java那样创建object的时候默认就是引用)如果我们写上virtual void foo() = 0这就是一个抽象类中的抽象方法, 我们没有实现这个方法, 只是告诉写代码的人继承这个类应该完成什么方法.在Java中, 我们不可以继承两个父类, 更多的功能需要实现接口. 但在C++中不一样, 我们可以继承多个对象. 在构造函数中也需要调用父类的构造函数这样就会导致问题: 如果两个父类对象有两个相同的方法. 子类对象就不知道该调用哪个方法了, 我们就需要显式的告诉它.并且, 这种继承可能会导致菱形继承: 一个父类有两个子类, 这两个子类又同时被一个子子类继承: 他们的继承关系就跟菱形一样.#include &lt;iostream&gt;
using std::cout;
using std::endl; class Life
{ int life; public: Life(int life) : life(life) { } void getLife() { cout &lt;&lt; life &lt;&lt; endl; } void virtual Talk() { cout &lt;&lt; "Life Talk" &lt;&lt; endl; }
}; class Cat : virtual public Life
{
public: Cat() : Life(9) { cout &lt;&lt; "cat const" &lt;&lt; endl; } void getID() { cout &lt;&lt; "cat id" &lt;&lt; endl; } void Talk() { cout &lt;&lt; "Cat Talk" &lt;&lt; endl; }
}; class Dog : virtual public Life
{
public: Dog() : Life(1) { cout &lt;&lt; "Dog const" &lt;&lt; endl; } void getID() { cout &lt;&lt; "Dog id" &lt;&lt; endl; } void Talk() { cout &lt;&lt; "Dog Talk" &lt;&lt; endl; }
}; class DogCat : public Cat, public Dog
{
public: DogCat() : Life(5), Dog(), Cat() { cout &lt;&lt; "DogCat const" &lt;&lt; endl; } void Talk() { cout &lt;&lt; "DogCat Talk" &lt;&lt; endl; }
}; int main()
{ DogCat dc; dc.Cat::getID(); dc.Dog::getID(); dc.getLife(); Life *dcInLife = new DogCat(); dcInLife-&gt;getLife(); dcInLife-&gt;Talk();
}
-------
//输出
cat const
Dog const
DogCat const
cat id
Dog id
5
cat const
Dog const
DogCat const
5
DogCat Talk
上面这段代码就是因为我们在DogCat对象中又重复的GetID方法, 所以我们就需要指定到底用哪个方法, 并且在构造DogCat类的时候, 还需要手动定义Life的构造函数, 并且如果想这么干, 就需要加上virtual关键词.可以看到, 继承会导致很多问题, 因为继承其实并不是用来节省代码的, 而是为了dynamic binding – 也就是animal array里放不同的动物class Rectangle { int h, w;
public: Rectangle(int h, int w) : h(h), w(w) {} int area() { return h * w; } void changeDimensions(int a, int b) { h = a; w = b;}
}; class Square : public Rectangle {
public: Square(int l) : Rectangle(l,l) {}
};
上面的代码是一个继承的例子, 但有一个问题就是我们会发现正方形也继承了长方形的changeDimensions方法: 这个方法的两个参数可不是我们想要的. 但这个问题又很难修改. 这就是Subclass的劣势.这时候我们就可以用Subtype了:
子类型是类型系统中的一个概念, 表示某种类型是另一种类型的子集或扩展. 在子类型关系中, 子类型必须遵循里氏替换原则 (Liskov Substitution Principle, LSP) , 这意味着子类型的对象可以无缝地替换父类型的对象, 而不影响程序的正确性. Subtype可以通过继承实现, 但不局限于继承; 它更注重行为和语义上的兼容性class Square {
Rectangle r;
Square(l) : r(l,l) { };
int area() { return r.area(); }
}
这样写就可以让方形只又我们想要的方法, 但它还遵从长方形的行为]]></description><link>cs3505/oop.html</link><guid isPermaLink="false">CS3505/OOP.md</guid><pubDate>Thu, 17 Oct 2024 18:56:09 GMT</pubDate></item><item><title><![CDATA[Function Pointer]]></title><description><![CDATA[我们可以在Cpp中用跟C#中的委托类似的东西: Function Pointerint foo(){ cout &lt;&lt; "Hi" &lt;&lt; endl; return 1;
} void doIt(int (*fParam)()){ fParam();
} int main(){ int (*fPtr)() = foo; //第一个int表示返回类型, 中间的表示一个function pointer, 后面的括号表示这个函数没有参数 doIt(fPtr);
}
我们还可以传递类中的方法 - 这个和function pointer 还是有一些区别的, 因为这是method pointerclass Twice { public: int doubleIt(int val) { return 2 * val; } }; int (Twice::*mPtr)(int) = &amp;Twice::doubleIt; Twice d; int result = (d.*mPtr)(5);
但如果想执行就必须有对应类的实例当然, 现在已经简化了, 我们有了std::function, 用这种写法可以让function pointer稍微好看一些#include &lt;functional&gt; int doubleNum(int num){ return num * 2;
} function&lt;int(int)&gt; fPtr = &amp;doubleNum;
auto fPtr2 = &amp;doubleNum;
有意思的是, 我们还可以把一个类的()符号给overload, 这样就可以把一个类实例当做method来用, 这种叫做Functors ]]></description><link>cs3505/function-pointer.html</link><guid isPermaLink="false">CS3505/Function Pointer.md</guid><pubDate>Thu, 17 Oct 2024 18:40:36 GMT</pubDate></item><item><title><![CDATA[Testing]]></title><description><![CDATA[通过测试, 能避免很多问题 Assert:
用&lt;cassert&gt;断言, 就可以检测代码数据有没有问题, 如果有问题则触发运行时错误.
assert(length≥0) 通过#include NDEBUG, 来关闭掉代码里的assert部分 谷歌测试
通过谷歌测试的库, 可以更好的测试代码. 在下载谷歌测试的库后, 我们需要先include.
#include&nbsp;&lt;gtest/gtest.h&gt;, 当然, 我们需要先编译它.
在上面, 我们包含了header file的路径, 这是因为这个头文件里的include也包含了路径, 如果在编译的时候我们告诉g++额外的路径, 在编译谷歌的头文件的时候就会导致找不到文件-两个gtest出现在了路径里
接下来就该测试了. 如果我们有一个阶乘函数, 想让他输入0的时候返回1, 那么就可以
TEST(FactorialTests, HandleZero){ EXPECT_EQ(1,factorial(0)); } 像在JAVA中一样, 我们也可以try catch.牛逼的是, 我们可以用catch(…)来截获一切throw的东西, 我们可以throw一个int, 或者报错, 一个数组等.]]></description><link>cs3505/testing.html</link><guid isPermaLink="false">CS3505/Testing.md</guid><pubDate>Wed, 09 Oct 2024 19:28:50 GMT</pubDate></item><item><title><![CDATA[C++ 特性]]></title><description><![CDATA[C++和Java的区别有一点是Java是Copy by Reference, 但C++是默认直接传递Object. 并且在C++我们我们可以直接操作程序变量的地址-直接输入 就可以查看这个变量的地址(16进制) 当我们获得地址了以后, 就可以Pass by Reference了. 这就引出了Pointer: int* scorePointer = &amp;score
通过上面这个方法, 可以得到一个int 分数的地址存到指针里面. 接着, 我们把函数参数的要求从int改为int* , 就可以接受指针输入.但是当我们开始修改分数的时候, 并不能直接修改这个指针, 因为它只代表地址, 我们需要解引用:*scorePointer
通过星号, 可以让程序知道, 我们在操作地址代表的物体, 而不是地址本身(一个*只能解一层引用)但这样非常麻烦, 如果我们在函数参数那里写上 int&amp; score, 这样就可以正常输入进去int, 并且还是pass by reference. 这种叫reference way, 上面使用pointer的方法是pointerway, 通常使用引用方法更加安全一些需要注意的地方：指针和引用基本相等, 都是指向对象的一个地址数据, 就是类型上有一些区别, 如指针可以修改它指的地址, 引用不可以（这就是为什么不能直接修改指针指向的数据, 需要把他用*变成引用#include &lt;iostream&gt; void testAddbyCopy(int i){ i++; }; void testAddByPtr(int* i){ (*i)++; }; void testAddByRef(int&amp; i){ i++; }; int main(){ int i1 = 1; int* i1ptr = &amp;i1; int&amp; i1ref = i1; std::cout&lt;&lt;"Did nothing, since parm is pass by copy"&lt;&lt;std::endl; testAddbyCopy(i1); std::cout&lt;&lt;i1&lt;&lt;std::endl; testAddbyCopy(*i1ptr); std::cout&lt;&lt;i1&lt;&lt;std::endl; testAddbyCopy(i1ref); std::cout&lt;&lt;i1&lt;&lt;std::endl; std::cout&lt;&lt;"Pass by pointer"&lt;&lt;std::endl; testAddByPtr(i1ptr); std::cout&lt;&lt;i1&lt;&lt;std::endl; testAddByPtr(&amp;i1); std::cout&lt;&lt;i1&lt;&lt;std::endl; testAddByPtr(&amp;i1ref); std::cout&lt;&lt;i1&lt;&lt;std::endl; std::cout&lt;&lt;"Pass by ref"&lt;&lt;std::endl; testAddByRef(*i1ptr); std::cout&lt;&lt;i1&lt;&lt;std::endl; testAddByRef(i1ref); std::cout&lt;&lt;i1&lt;&lt;std::endl; testAddByRef(i1); std::cout&lt;&lt;i1&lt;&lt;std::endl; return 0; } 还有就是Array: 在C++中array声明后是在栈上面的, 并且光声明后, 里面的数值是没有任何初始化的（不是0）, 直接用可能出现问题并且在C++中没有Array out of bound: 当我们访问一个Array bound外面的数值的时候, 这是一个未被定义的行为所以每当我们在创建Array的时候, 最好在后面跟上个花括号, 里面的数值表示的是对应的数, 没有对应的就是0当我们想把Array放进pointer里, 有两种方法, 一种是int* ptr = &amp;arr[0]还有一种是int* ptr = arr因为数组本身就是个引用, 所以可以直接当做地址传递给指针这时候, 这个ptr就可以直接被看做是arr了. 所以解引用以后得到的也就是数组的第一个元素:*ptr. 有意思的是我们还可以让指针进行偏移: 当我们输入*(ptr + 1)的时候得到的会是数组的第二个元素(这个+1表示的是让指针往前偏移一个数据结构的量, 如int array就偏移一个int, long array就偏移一个long)在C++中, 创建一个类没有太大的区别, 但在创建变量的时候跟Java有些不同：如果想声明private 变量或者Public变量, 则可以在上面写 然后下面的所有变量都变成公用的变量了. Private也是一样对于C++class, 默认所有创建的不管是变量还是方法都是private, 且如果想要调用默认构造函数的话, 跟其他语言是有区别的：Point pointA;
因为如果我们如果加上括号的话, 编译器可能认为我们在创建一个函数, 返回一个点且不需要任何参数并且C++中创建的对象里的数据也是在stack中的, 比如一个point里的坐标创建的时候都是在stack中的可以看到, 之前创建一个对象都不需要像其他语言一样写new, 是因为他们都是在stack上的. 如果我们想创建到heap上, 就需要写newint* p = new int(4); delete p; 上面这种写法就可以创建一个在heap上的int, 然后指向它的指针存在p里. 但注意：这么写会消耗更多的时间 (相较于不写new) 并且我们需要手动管理在heap上的内存：当我们创建完并不用了, 就需要把这个指针指向的物体手动删除, 不止是在结束代码的时候要删掉, 我们如果要赋个新int如p=new int(5) , 这样也会导致内存泄漏. 并且如果想删除array也不太一样, 需要在delete后面加个方括号才可以完全删除, 不然只是删除array的第一个元素需要注意的是创建类和array并不相同, 因为array创建出来本身就是个指针, 但类创建出来如果不带星号就是表示的是类自身, 所以传递给函数的时候也会有所不同: 类如果不是指针的话, 传递的就会是那个对象的拷贝, 但数组传递过去本身就是引用class Cat{ int lives; public: Cat(int lives):lives(lives){ } void ReportLives(){ std::cout&lt;&lt;lives&lt;&lt;std::endl; } void LoseLife(){ lives--; } Cat&amp; operator+=(int lives){ this-&gt;lives+=lives; return *this;//We use *this to make pointer turn in to a reference } //If we want to overload operator to do like cat+=1+=2 (is cat+=3), we need to let operator return cat class /* Cat operator+=(int lives){ this-&gt;lives+=lives; return *this; //func need to return a cat type, not a ref, so a new object will be created } */ //this is wrong because it will just return a copy of this object /* Cat* operator+=(int lives){ this-&gt;lives+=lives; return this; } */ //This is wrong because even it return a pointer point to cat object, but compiler don't know it actually a cat object }; int main(){ Cat cat(9); cat.ReportLives(); cat.LoseLife(); cat+=2; cat.ReportLives(); (cat+=1)+=1; cat.ReportLives(); return 0; } 上面是创建一个类常用的一些操作：比如可以在括号后赋值, 或者符号覆写#include &lt;iostream&gt; using namespace std; class Point { private: int x, y; public: Point(int x = 0, int y = 0) : x(x), y(y) {} // 声明友元函数以重载 &lt;&lt; 运算符 friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Point&amp; p); }; // 重载 &lt;&lt; 运算符的定义 ostream&amp; operator&lt;&lt;(ostream&amp; os, const Point&amp; p) { os &lt;&lt; "Point(" &lt;&lt; p.x &lt;&lt; ", " &lt;&lt; p.y &lt;&lt; ")"; return os; } int main() { Point p(3, 4); cout &lt;&lt; p &lt;&lt; endl; return 0; } 在上段代码中, 我们覆写了&lt;&lt;符号, 他会返回ostream这样cout可以直接使用. 但还可以看到在这个覆写符号函数中调用了点的私有变量. 这样是可以的, 因为我们在点类中声明了友元函数, 这样就可以让外部覆写的函数能访问点的私有变量了, 这样写可以让我们实现既不想在类里直接写函数, 又可以在未来完成这个函数时访问类里的私有变量. #include &lt;iostream&gt; using namespace std; class Point { private: double x, y; public: Point(double x = 0, double y = 0) : x(x), y(y) {} // 在类内部声明成员函数 double GetX() const; double GetY() const; }; // 在类外部定义成员函数 double Point::GetX() const { return x; } double Point::GetY() const { return y; } int main() { Point p(3.5, 4.5); cout &lt;&lt; "X: " &lt;&lt; p.GetX() &lt;&lt; ", Y: " &lt;&lt; p.GetY() &lt;&lt; endl; return 0; } 上面这个方法，可以让我们在类的外部定义类的函数，只需要在方法前面加上类型就行, 这种通常是我们在xx.h文件中先定义函数，然后在xxx.cpp文件中再完成这些函数至于为什么不需要在上面的那种友元函数中加上Point类型，是因为友元函数是一个公有的函数，尽管友元函数可以访问类的私有和受保护成员，但它本质上是一个全局函数或另一个类的成员函数。因此，在定义友元函数时，不需要使用作用域解析运算符::Const在C++有很多用处, 我们在Java中就知道可以用这个关键词来避免数值做出修改, 在C++中也是一样的效果, 而且在C++中, 它可以保证传递进来的参数就算是引用也不会被修改void method(bigObject b){} void method(bigObject&amp; b){} void method(const bigObject&amp; b){} 通过上面这种方法, 我们可以在调用方法的时候避免复制对象, 还可以避免修改对象数据.当我们在写一个class的时候, 需要注意三个事情:
第一个就是内存管理, 如果使用new, 一定要记得delete ~BT() { cout &lt;&lt; "deleting" &lt;&lt; endl; delete left; delete right; // 当给root删除的时候, 左右会开始调用这个函数, 然后一直递归下去 }
&nbsp; &nbsp; 第二个就是copy constructor: 当我们写Object obj1(obj2)想创建一个obj2的副本的时候, C++自带的处理不好对象里的指针: 他们会复制指针, 导致两个对象里的数据指针指向同一个地址, 这样会互相影响
DynamicArray(const DynamicArray &amp;other){ length = other.length; data = new int[length]; for(int i = 0; i &lt; length; i++){ data[i] = other.data[i]; } } 第三个就是=赋值, 对于一个对象, 我们希望赋值是创建一个新的对象, 而不是把引用复制过去. 所以我们需要覆写等于号
BT &amp;operator=(BT other) { std::swap(this-&gt;word, other.word); std::swap(this-&gt;left, other.left); std::swap(this-&gt;right, other.right); } 上面这个就是覆写过后的一个二叉树的复制方法: 这里有一个很隐秘的地方: 等号后面的(也就是这里的other)其实已经被完美的复制过了. 因为我们是直接传递的object进来而不是指针, 所以函数会先调用copy constructor, 然后我们再通过swap函数进行地址调换, 把所有的数据交换过后离开这个scope, 旧的数据也就随着deconstructor删除掉了元编程就是我们提前定义了代码的格式, 但并没有定义真正的类型, 就像模板一样.模板代码只有在真正编译的时候才会生成, 并且模板代码可以全部写在头文件中. 模板具体分为函数模板和类模板函数模板:template &lt;typename T&gt; T max(T a, T b) { return (a &gt; b) ? a : b; } int main() { std::cout &lt;&lt; max(3, 7) &lt;&lt; std::endl; // 输出 7 std::cout &lt;&lt; max(3.5, 2.1) &lt;&lt; std::endl; // 输出 3.5 std::cout &lt;&lt; max('a', 'z') &lt;&lt; std::endl; // 输出 z return 0; } 类模板:template &lt;typename T&gt; class Stack { private: std::vector&lt;T&gt; elements; public: void push(const T&amp; element) { elements.push_back(element); } void pop() { if (!elements.empty()) { elements.pop_back(); } } T top() const { if (!elements.empty()) { return elements.back(); } throw std::out_of_range("Stack&lt;&gt;::top(): empty stack"); } bool empty() const { return elements.empty(); } }; int main() { Stack&lt;int&gt; intStack; intStack.push(1); intStack.push(2); std::cout &lt;&lt; intStack.top() &lt;&lt; std::endl; // 输出 2 Stack&lt;std::string&gt; stringStack; stringStack.push("Hello"); stringStack.push("World"); std::cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; // 输出 World return 0; } 你可能在其他地方看到template &lt;class T&gt; 这其实是等价于上面的typename的. 这么写只是为了兼容早期C++语法. 这个typename是为了让编译器知道这个T是个类型. 并且, 模板类只有在编译的时候才会生成真正的代码, 每使用一个新的数据类型, 他就会生成一个新的代码, 专门为那个类型写的.当我们创建了数据结构, 当然就绕不开遍历, 就像JAVA中, 我们可以给类添加迭代器, 这样就可以直接用foreach来进行遍历std::vector&lt;int&gt; vec = {1, 2, 3, 4, 5}; // 使用正向迭代器遍历 vector for (std::vector&lt;int&gt;::iterator it = vec.begin(); it != vec.end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; " "; } std::cout &lt;&lt; std::endl; 除了正常的for, 还可以用上面这种foreach来进行遍历, 这样的好处是它是通用的:只要实现了iterator接口, 都可以进行遍历. 并且还不用担心index out of bount等问题.
我们还可以进行Structured Binding:for(auto const&amp;[key,val]:data)
在上面我们就是用auto拆解了一个dictionary的键值对成一个组元. ]]></description><link>cs3505/c++-特性.html</link><guid isPermaLink="false">CS3505/C++ 特性.md</guid><pubDate>Wed, 02 Oct 2024 20:35:03 GMT</pubDate></item><item><title><![CDATA[Doker & Compile]]></title><description><![CDATA[Docker可以让我们在Win系统上运行Linux程序, 并且支持链接VSCode
当在VS Code中写完代码, 可以使用VS Code的控制台输入g++ -o test helloworld.cpp
来把helloworld.cpp 文件编译成名test的执行文件
再输入./test 来运行对于一个make file, 他的格式是这样：testCompile: Sine.o testSine.o g++ -o testCompile Sine.o testSine.o Sine.o: Sine.cpp Sine.h g++ -c Sine.cpp testSine.o : testSine.cpp Sine.h g++ -c testSine.cpp test : testCompile ./testCompile &gt; SineData.txt 这算是一种依赖关系, 如果我们想输出最终的文件: test compile, 我们需要两个class文件Sine.o和testSine.o 制作这个文件需要的是g++ -o testCompile Sine.o testSine.o
指令, 表示的是连接两个文件,然后组成一个可执行文件, 而这两个文件又需要下面的指令来合成.冒号前面的是我们输出的文件, 冒号后面的是它所需要的文件, 也就是如果这些文件变动了, 那么就得重新编译前面的输出文件.文件一多, 就需要把文件分一下类: 如把所有的header file 放进include文件夹, 然后把剩下来的.cpp代码放进src文件夹.
这就会导致一个问题: Make file文件运行不了了: 他们找不到所需要的文件了, 因为他们只会在makefile的文件夹里找那些编译所需要的文件.INCLUDE = ./include CFLAGS = -Wall #INCLUDE只是个变量 main: Car.o main.o $(INCLUDE)/Car.h g++ $(CFLAGS) -I$(INCLUDE) -o main main.o Car.o Car.o: Car.cpp $(INCLUDE)/Car.h g++ $(CFLAGS) -I$(INCLUDE) -c Car.cpp main.o: main.cpp $(INCLUDE)/Car.h g++ $(CFLAGS) -I$(INCLUDE) -c main.cpp clean : rm -f main *.o 通过这么写, 我们可以让编译器链接我们的头文件: 定义了一个 变量, 它存储了那些头文件的路径, 然后在编译指令中加上个flag &nbsp;来表示头文件在那里.当然上面这样只能解决头文件的问题, 我们还需要解决.cpp的问题; 但是我们已经厌烦这么一个个的加.o 文件了, 我们可以用链接库来实现:这里我们拿静态链接库举例ar -rcs libPoint.a Point.o other.o这样就可以把一堆.o文件变成一个链接库
注意, 对于库来说, 我们默认是它很少做出改动, 所以都是不会把库加入dependency中CAR = ./Car CARINCLUDE = $(CAR)/include CARSRC = $(CAR)/src CFLAGS = -Wall #INCLUDE只是个变量 main: main.o g++ $(CFLAGS) -I$(CARINCLUDE) -o main main.o -L$(CARSRC) -lCar #-lCar 会自动转换成libCar.a, 这个-L 和 -l可以写多个 main.o: main.cpp $(CARINCLUDE)/Car.h g++ $(CFLAGS) -I$(CARINCLUDE) -c main.cpp clean : rm -f main *.o 需要注意的是: 对于C++来说, 编译o文件只需要头文件和本体CPP文件就行, 因为他们只需要一个接口来查看这些语法合不合法. 在真正的链接阶段(就是编译最终可执行文件的时候)才会使用其他的o文件和a文件]]></description><link>cs3505/doker-&amp;-compile.html</link><guid isPermaLink="false">CS3505/Doker &amp; Compile.md</guid><pubDate>Mon, 30 Sep 2024 03:43:01 GMT</pubDate></item></channel></rss>